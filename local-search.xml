<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>利用Colab玩转Onnx——包括可以同时编写和运行Python和C++代码</title>
    <link href="/2025/11/15/Onnx&amp;Colab/"/>
    <url>/2025/11/15/Onnx&amp;Colab/</url>
    
    <content type="html"><![CDATA[<p>公司没有提供带显卡的笔记本（贼抠门），也不敢瞎用公司的服务器显卡，双十一犹豫了半天也没买新电脑（经济下行啊）。但是最近有点迷AI部署，所以想到了用Colab，试试能不能搭建Onnx环境，没想到可以。</p><p>Colab 本质上是一个运行在 Google 服务器上的 Ubuntu Linux 虚拟机，它预装了 C++ 编译器（如 <code>g++</code>）。</p><p>我们将通过以下步骤实现：</p><ol><li><strong>挂载 Google Drive</strong>：用于访问和保存模型、代码。</li><li><strong>安装 C++ ONNX Runtime 库</strong>：下载预编译的 C++ 库文件。</li><li><strong>准备一个 ONNX 模型</strong>：我们将用 Python (Colab 的强项) 创建一个简单的模型并保存到 Drive。</li><li><strong>编写 C++ 推理代码</strong>：使用 Colab 的 “cell magic” <code>%%writefile</code> 将 C++ 代码写入文件。</li><li><strong>编译 C++ 代码</strong>：使用 <code>g++</code> 编译，并链接到 ONNX Runtime 库。</li><li><strong>运行 C++ 程序</strong>：执行编译后的文件。</li></ol><p>下面是一个完整的 Colab 笔记本单元格，可以<strong>按顺序复制并运行</strong>它们。</p><hr><h3 id="完整的-Colab-运行步骤"><a href="#完整的-Colab-运行步骤" class="headerlink" title="完整的 Colab 运行步骤"></a>完整的 Colab 运行步骤</h3><p>在 Colab 中打开一个新的 Notebook，然后依次执行以下代码单元格。</p><h4 id="步骤-1：挂载-Google-Drive"><a href="#步骤-1：挂载-Google-Drive" class="headerlink" title="步骤 1：挂载 Google Drive"></a>步骤 1：挂载 Google Drive</h4><p>这会弹出一个授权窗口，允许 Colab 访问 Google Drive。</p><p>Python</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> google.colab <span class="hljs-keyword">import</span> drive<br>drive.mount(<span class="hljs-string">&#x27;/content/drive&#x27;</span>)<br><br># 为了方便，我们创建一个工作目录<br># 可以改成任何路径<br>WORK_DIR = <span class="hljs-string">&#x27;/content/drive/MyDrive/Colab_CPP_ONNX&#x27;</span><br>!mkdir -p <span class="hljs-string">&quot;&#123;WORK_DIR&#125;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="步骤-2：下载并解压-C-ONNX-Runtime"><a href="#步骤-2：下载并解压-C-ONNX-Runtime" class="headerlink" title="步骤 2：下载并解压 C++ ONNX Runtime"></a>步骤 2：下载并解压 C++ ONNX Runtime</h4><p>我们将从 GitHub 下载官方的预编译版本。</p><p>Python</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 我们将把它安装在 Colab 临时的 /content/ 目录下</span><br>%cd <span class="hljs-regexp">/content/</span><br><br><span class="hljs-comment"># 下载 ONNX Runtime (以 1.16.3 版本为例，你可以去官网查看最新版)</span><br><span class="hljs-comment"># 注意：这是一个后台命令，前面的 ! 很重要</span><br>!wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/microsoft/</span>onnxruntime<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v1.16.3/</span>onnxruntime-linux-x64-<span class="hljs-number">1.16</span>.<span class="hljs-number">3</span>.tgz<br><br><span class="hljs-comment"># 解压缩</span><br>!tar -xzf onnxruntime-linux-x64-<span class="hljs-number">1.16</span>.<span class="hljs-number">3</span>.tgz<br><br><span class="hljs-comment"># 为方便后续编译，我们定义一个路径变量</span><br>ORT_DIR = <span class="hljs-string">&#x27;/content/onnxruntime-linux-x64-1.16.3&#x27;</span><br>print(f<span class="hljs-string">&quot;ONNX Runtime C++ 库已解压到: &#123;ORT_DIR&#125;&quot;</span>)<br><br><span class="hljs-comment"># 安装onnx包</span><br>%pip install onnx<br></code></pre></td></tr></table></figure><h4 id="步骤-3：使用-Python-创建一个简单的-ONNX-模型"><a href="#步骤-3：使用-Python-创建一个简单的-ONNX-模型" class="headerlink" title="步骤 3：使用 Python 创建一个简单的 ONNX 模型"></a>步骤 3：使用 Python 创建一个简单的 ONNX 模型</h4><p>我们将创建一个非常简单的模型：<code>y = 2 * x</code>。我们用 Python&#x2F;Torch 来创建它，并保存到你的 Google Drive。</p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><span class="hljs-comment"># 1. 定义一个简单的 PyTorch 模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 2. 实例化模型并准备导出</span><br>model = SimpleModel()<br>model.<span class="hljs-built_in">eval</span>()<br>dummy_input = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-comment"># 假设输入是一个 [1, 3] 的张量</span><br><br><span class="hljs-comment"># 3. 定义模型保存路径</span><br>MODEL_PATH = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;WORK_DIR&#125;</span>/simple_model.onnx&quot;</span><br><br><span class="hljs-comment"># 4. 导出为 ONNX</span><br>torch.onnx.export(<br>    model,<br>    dummy_input,<br>    MODEL_PATH,<br>    input_names=[<span class="hljs-string">&#x27;input_x&#x27;</span>],   <span class="hljs-comment"># C++ 代码中需要用到</span><br>    output_names=[<span class="hljs-string">&#x27;output_y&#x27;</span>], <span class="hljs-comment"># C++ 代码中需要用到</span><br>    opset_version=<span class="hljs-number">11</span><br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;模型已保存到: <span class="hljs-subst">&#123;MODEL_PATH&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="步骤-4：编写-C-推理代码"><a href="#步骤-4：编写-C-推理代码" class="headerlink" title="步骤 4：编写 C++ 推理代码"></a>步骤 4：编写 C++ 推理代码</h4><p>我们使用 <code>%%writefile</code> 将这个单元格的内容保存为 <code>infer.cpp</code> 文件。</p><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp">%%writefile infer.cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;onnxruntime_cxx_api.h&gt;</span> <span class="hljs-comment">// ONNX Runtime C++ API</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 初始化 ONNX Runtime 环境</span><br>    <span class="hljs-comment">// Ort::Env 是线程安全的，建议全局创建一个</span><br>    <span class="hljs-function">Ort::Env <span class="hljs-title">env</span><span class="hljs-params">(ORT_LOGGING_LEVEL_WARNING, <span class="hljs-string">&quot;test_env&quot;</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 2. 设置会话选项 (Session Options)</span><br>    Ort::SessionOptions session_options;<br>    session_options.<span class="hljs-built_in">SetIntraOpNumThreads</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置线程数</span><br>    <br>    <span class="hljs-comment">// 3. 定义模型路径 (这里使用了硬编码的路径)</span><br>    <span class="hljs-comment">// 注意：路径必须和步骤 3 中保存的路径一致</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* model_path = <span class="hljs-string">&quot;/content/drive/MyDrive/Colab_CPP_ONNX/simple_model.onnx&quot;</span>;<br><br>    <span class="hljs-comment">// 4. 创建会话 (Session)</span><br>    <span class="hljs-function">Ort::Session <span class="hljs-title">session</span><span class="hljs-params">(env, model_path, session_options)</span></span>;<br>    <br>    <span class="hljs-comment">// 5. 获取输入/输出节点信息</span><br>    <span class="hljs-comment">// 我们需要知道输入/输出的名称（在步骤3中定义过）</span><br>    Ort::AllocatorWithDefaultOptions allocator;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* input_name = <span class="hljs-string">&quot;input_x&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* output_name = <span class="hljs-string">&quot;output_y&quot;</span>;<br><br>    <span class="hljs-comment">// 6. 准备输入数据</span><br>    std::vector&lt;<span class="hljs-type">float</span>&gt; input_data = &#123;<span class="hljs-number">1.0f</span>, <span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>&#125;;<br>    std::vector&lt;<span class="hljs-type">int64_t</span>&gt; input_shape = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 形状 [1, 3]</span><br>    <br>    <span class="hljs-comment">// 7. 创建输入张量 (Tensor)</span><br>    <span class="hljs-keyword">auto</span> memory_info = Ort::MemoryInfo::<span class="hljs-built_in">CreateCpu</span>(OrtArenaAllocator, OrtMemTypeDefault);<br>    Ort::Value input_tensor = Ort::Value::<span class="hljs-built_in">CreateTensor</span>&lt;<span class="hljs-type">float</span>&gt;(<br>        memory_info, <br>        input_data.<span class="hljs-built_in">data</span>(), <br>        input_data.<span class="hljs-built_in">size</span>(), <br>        input_shape.<span class="hljs-built_in">data</span>(), <br>        input_shape.<span class="hljs-built_in">size</span>()<br>    );<br><br>    <span class="hljs-comment">// 8. 运行推理</span><br>    std::vector&lt;Ort::Value&gt; output_tensors = session.<span class="hljs-built_in">Run</span>(<br>        Ort::RunOptions&#123;<span class="hljs-literal">nullptr</span>&#125;, <br>        &amp;input_name,   <span class="hljs-comment">// 输入节点名称</span><br>        &amp;input_tensor, <span class="hljs-comment">// 输入张量</span><br>        <span class="hljs-number">1</span>,             <span class="hljs-comment">// 输入数量</span><br>        &amp;output_name,  <span class="hljs-comment">// 输出节点名称</span><br>        <span class="hljs-number">1</span>              <span class="hljs-comment">// 输出数量</span><br>    );<br><br>    <span class="hljs-comment">// 9. 获取输出结果</span><br>    <span class="hljs-type">float</span>* output_data = output_tensors[<span class="hljs-number">0</span>].<span class="hljs-built_in">GetTensorMutableData</span>&lt;<span class="hljs-type">float</span>&gt;();<br>    <span class="hljs-type">size_t</span> output_size = output_tensors[<span class="hljs-number">0</span>].<span class="hljs-built_in">GetTensorTypeAndShapeInfo</span>().<span class="hljs-built_in">GetElementCount</span>();<br><br>    <span class="hljs-comment">// 10. 打印结果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;--- C++ ONNX Runtime 推理结果 ---&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;输入数据: [ &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> val : input_data) &#123; std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;输出数据 (y = 2 * x): [ &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; output_size; ++i) &#123;<br>        std::cout &lt;&lt; output_data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="步骤-5：编译-C-代码"><a href="#步骤-5：编译-C-代码" class="headerlink" title="步骤 5：编译 C++ 代码"></a>步骤 5：编译 C++ 代码</h4><p>这是关键一步。我们将使用 <code>g++</code> 编译器，并指定 ONNX Runtime 的 <code>include</code>（头文件）和 <code>lib</code>（库文件）路径。</p><p>Python</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment"># ORT_DIR 变量是我们在步骤 2 中定义的</span><br>!g++ infer.cpp <span class="hljs-string">\</span><br>    -o run_infer <span class="hljs-string">\</span><br>    -I <span class="hljs-string">&quot;&#123;ORT_DIR&#125;/include&quot;</span> <span class="hljs-string">\</span><br>    -L <span class="hljs-string">&quot;&#123;ORT_DIR&#125;/lib&quot;</span> <span class="hljs-string">\</span><br>    -lonnxruntime <span class="hljs-string">\</span><br>    -std=c++<span class="hljs-number">17</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;编译完成！生成了可执行文件 &#x27;run_infer&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="步骤-6：运行-C-程序！"><a href="#步骤-6：运行-C-程序！" class="headerlink" title="步骤 6：运行 C++ 程序！"></a>步骤 6：运行 C++ 程序！</h4><p>编译成功后，当前目录 (<code>/content/</code>) 下会有一个名为 <code>run_infer</code> 的可执行文件。</p><p>Python</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 动态链接库 (.so 文件) 需要被系统找到</span><br><span class="hljs-comment"># 我们将 ONNX 库的路径添加到 LD_LIBRARY_PATH 环境变量中</span><br><span class="hljs-comment"># &quot;&amp;&amp;&quot; 确保在同一 shell 会话中执行</span><br>!<span class="hljs-built_in">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=<span class="hljs-string">&quot;&#123;ORT_DIR&#125;/lib&quot;</span> &amp;&amp; ./run_infer<br></code></pre></td></tr></table></figure><h3 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h3><p>如果你正确执行了所有步骤，步骤 6 的输出应该是：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">---</span> <span class="hljs-comment">C</span><span class="hljs-literal">++</span> <span class="hljs-comment">ONNX Runtime 推理结果</span> <span class="hljs-literal">---</span><br><span class="hljs-comment">输入数据:</span> <span class="hljs-title">[</span> <span class="hljs-comment">1 2 3</span> <span class="hljs-title">]</span><br><span class="hljs-comment">输出数据 (y = 2 * x):</span> <span class="hljs-title">[</span> <span class="hljs-comment">2 4 6</span> <span class="hljs-title">]</span><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个流程展示了如何将 Colab 的 Python 环境（用于模型准备）和其底层的 Linux C++ 环境（用于编译和运行）结合起来。后续可以基于这个 <code>infer.cpp</code> 模板，将其修改为你需要的、更复杂的 ONNX 模型。后续应该还是不买笔记本（还是好希望有个本地跑的N卡）。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Onnx Colab CXX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brpc编译环境搭建</title>
    <link href="/2025/01/02/BrpcBuild/"/>
    <url>/2025/01/02/BrpcBuild/</url>
    
    <content type="html"><![CDATA[<p>众所周知，C++编译是个大难题，之前的brpc环境学习环境是放在公司电脑的，现在在自己电脑的虚机Ubuntu16.04上，重新搭建个学习环境。以下是艰苦奋战的结果。</p><h2 id="升级-CMake"><a href="#升级-CMake" class="headerlink" title="升级 CMake"></a>升级 <code>CMake</code></h2><p>以下是升级 <code>CMake</code> 的详细步骤：</p><hr><h3 id="1-检查当前版本"><a href="#1-检查当前版本" class="headerlink" title="1. 检查当前版本"></a><strong>1. 检查当前版本</strong></h3><p>先确认当前系统已安装的 <code>CMake</code> 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --version<br></code></pre></td></tr></table></figure><hr><h3 id="2-从官方网站下载最新版本"><a href="#2-从官方网站下载最新版本" class="headerlink" title="2. 从官方网站下载最新版本"></a><strong>2. 从官方网站下载最新版本</strong></h3><p>访问 <a href="https://cmake.org/download/">CMake 官方下载页面</a> 选择适合你的系统版本（通常是 <code>Linux x86_64</code> 的 tar.gz 文件）。</p><p>或者使用命令下载最新的稳定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/Kitware/CMake/releases/latest/download/cmake-&lt;version&gt;-linux-x86_64.sh<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：将 <code>&lt;version&gt;</code> 替换为所需的版本号，例如 <code>3.27.6</code>。</p></blockquote><hr><h3 id="3-安装前准备"><a href="#3-安装前准备" class="headerlink" title="3. 安装前准备"></a><strong>3. 安装前准备</strong></h3><p>赋予下载的安装文件执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x cmake-&lt;version&gt;-linux-x86_64.sh<br></code></pre></td></tr></table></figure><hr><h3 id="4-安装-CMake"><a href="#4-安装-CMake" class="headerlink" title="4. 安装 CMake"></a><strong>4. 安装 CMake</strong></h3><p>运行安装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ./cmake-&lt;version&gt;-linux-x86_64.sh --prefix=/usr/local --skip-license<br></code></pre></td></tr></table></figure><h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul><li><code>--prefix=/usr/local</code>: 安装路径，默认是 <code>/usr/local</code>。</li><li><code>--skip-license</code>: 跳过显示许可证的确认。</li></ul><hr><h3 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5. 验证安装"></a><strong>5. 验证安装</strong></h3><p>验证新版本是否成功安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --version<br></code></pre></td></tr></table></figure><hr><h3 id="6-替换旧版本（如果必要）"><a href="#6-替换旧版本（如果必要）" class="headerlink" title="6. 替换旧版本（如果必要）"></a><strong>6. 替换旧版本（如果必要）</strong></h3><p>如果仍然显示旧版本的 <code>CMake</code>，可能是系统路径未更新导致。通过以下命令更新路径：</p><h4 id="检查当前的-CMake-路径："><a href="#检查当前的-CMake-路径：" class="headerlink" title="检查当前的 CMake 路径："></a>检查当前的 CMake 路径：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> cmake<br></code></pre></td></tr></table></figure><h4 id="更新系统路径："><a href="#更新系统路径：" class="headerlink" title="更新系统路径："></a>更新系统路径：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -sf /usr/local/bin/cmake /usr/bin/cmake<br></code></pre></td></tr></table></figure><p>再次验证版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake --version<br></code></pre></td></tr></table></figure><hr><h3 id="7-清理临时文件"><a href="#7-清理临时文件" class="headerlink" title="7. 清理临时文件"></a><strong>7. 清理临时文件</strong></h3><p>安装完成后，可以删除下载的安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -f cmake-&lt;version&gt;-linux-x86_64.sh<br></code></pre></td></tr></table></figure><hr><h2 id="安装-autoreconf-工具"><a href="#安装-autoreconf-工具" class="headerlink" title="安装 autoreconf 工具"></a>安装 <code>autoreconf</code> 工具</h2><p>安装Protobuf前，需要安装 <code>autoreconf</code> 工具。</p><hr><h4 id="1-安装-autoconf-和相关工具"><a href="#1-安装-autoconf-和相关工具" class="headerlink" title="1. 安装 autoconf 和相关工具"></a>1. <strong>安装 <code>autoconf</code> 和相关工具</strong></h4><p>根据操作系统安装所需的软件包：</p><h5 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu&#x2F;Debian"></a><strong>Ubuntu&#x2F;Debian</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install -y autoconf automake libtool<br></code></pre></td></tr></table></figure><h5 id="CentOS-RHEL"><a href="#CentOS-RHEL" class="headerlink" title="CentOS&#x2F;RHEL"></a><strong>CentOS&#x2F;RHEL</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y autoconf automake libtool<br></code></pre></td></tr></table></figure><h5 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a><strong>Fedora</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dnf install -y autoconf automake libtool<br></code></pre></td></tr></table></figure><h5 id="MacOS-Homebrew"><a href="#MacOS-Homebrew" class="headerlink" title="MacOS (Homebrew)"></a><strong>MacOS (Homebrew)</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install autoconf automake libtool<br></code></pre></td></tr></table></figure><h2 id="源码安装Protobuf"><a href="#源码安装Protobuf" class="headerlink" title="源码安装Protobuf"></a>源码安装Protobuf</h2><p>安装 Protobuf（Protocol Buffers）有多种方式，可以根据操作系统和具体需求选择适合的方法。以下是安装 Protobuf 的详细步骤，包括通过包管理器、源码安装以及其他方法。</p><hr><h3 id="1-通过包管理器安装"><a href="#1-通过包管理器安装" class="headerlink" title="1. 通过包管理器安装"></a>1. <strong>通过包管理器安装</strong></h3><h4 id="Ubuntu-Debian-1"><a href="#Ubuntu-Debian-1" class="headerlink" title="Ubuntu&#x2F;Debian"></a><strong>Ubuntu&#x2F;Debian</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install -y protobuf-compiler libprotobuf-dev<br></code></pre></td></tr></table></figure><h4 id="CentOS-RHEL-1"><a href="#CentOS-RHEL-1" class="headerlink" title="CentOS&#x2F;RHEL"></a><strong>CentOS&#x2F;RHEL</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y protobuf protobuf-devel<br></code></pre></td></tr></table></figure><h4 id="Fedora-1"><a href="#Fedora-1" class="headerlink" title="Fedora"></a><strong>Fedora</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dnf install -y protobuf protobuf-devel<br></code></pre></td></tr></table></figure><h4 id="MacOS-Homebrew-1"><a href="#MacOS-Homebrew-1" class="headerlink" title="MacOS (Homebrew)"></a><strong>MacOS (Homebrew)</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install protobuf<br></code></pre></td></tr></table></figure><p>通过包管理器安装是最快捷的方法，但版本可能较旧。如果需要特定版本，请选择源码安装。</p><hr><h3 id="2-从源码安装"><a href="#2-从源码安装" class="headerlink" title="2. 从源码安装"></a>2. <strong>从源码安装</strong></h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ol><li><p><strong>下载源码</strong> 前往 <a href="https://github.com/protocolbuffers/protobuf/releases">Protobuf Releases 页面</a>，选择需要的版本，下载源码包或克隆仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/protocolbuffers/protobuf.git<br><span class="hljs-built_in">cd</span> protobuf<br>git checkout v3.6.0 <span class="hljs-comment"># 或者指定其他版本</span><br></code></pre></td></tr></table></figure></li><li><p><strong>构建和安装</strong> 确保安装了构建工具（如 <code>cmake</code> 或 <code>autotools</code>）：</p><ul><li><p>使用 <code>autotools</code>（推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./autogen.sh<br>./configure<br>make -j$(<span class="hljs-built_in">nproc</span>)<br><span class="hljs-built_in">sudo</span> make install<br><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>cmake</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake .. -DCMAKE_BUILD_TYPE=Release<br>make -j$(<span class="hljs-built_in">nproc</span>)<br><span class="hljs-built_in">sudo</span> make install<br><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>验证安装</strong> 检查 <code>protoc</code> 的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --version<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="3-通过预编译的二进制文件安装"><a href="#3-通过预编译的二进制文件安装" class="headerlink" title="3. 通过预编译的二进制文件安装"></a>3. <strong>通过预编译的二进制文件安装</strong></h3><p>如果不想自己构建，可以使用官方提供的预编译二进制文件：</p><ol><li><p>下载对应系统的二进制包：<a href="https://github.com/protocolbuffers/protobuf/releases">Protobuf Releases</a></p></li><li><p>解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf protobuf-all-&lt;version&gt;.tar.gz<br></code></pre></td></tr></table></figure></li><li><p>将二进制文件移动到系统路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> bin/protoc /usr/local/bin/<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x /usr/local/bin/protoc<br></code></pre></td></tr></table></figure></li><li><p><strong>验证</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">protoc --version<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="4-安装到特定目录（可选）"><a href="#4-安装到特定目录（可选）" class="headerlink" title="4. 安装到特定目录（可选）"></a>4. <strong>安装到特定目录（可选）</strong></h3><p>如果需要将 Protobuf 安装到自定义路径，例如 <code>/opt/protobuf</code>，可以在 <code>./configure</code> 或 <code>cmake</code> 时指定路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/opt/protobuf<br>make -j$(<span class="hljs-built_in">nproc</span>)<br>make install<br></code></pre></td></tr></table></figure><p>然后将路径添加到环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/opt/protobuf/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/opt/protobuf/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></table></figure><hr><h3 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5. 常见问题"></a>5. <strong>常见问题</strong></h3><h4 id="找不到-Protobuf-的头文件或库"><a href="#找不到-Protobuf-的头文件或库" class="headerlink" title="找不到 Protobuf 的头文件或库"></a><strong>找不到 Protobuf 的头文件或库</strong></h4><p>确保 Protobuf 的 <code>include</code> 和 <code>lib</code> 路径已经正确配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> CXXFLAGS=<span class="hljs-string">&quot;-I/usr/local/include&quot;</span><br><span class="hljs-built_in">export</span> LDFLAGS=<span class="hljs-string">&quot;-L/usr/local/lib&quot;</span><br></code></pre></td></tr></table></figure><h4 id="Protobuf-版本不兼容"><a href="#Protobuf-版本不兼容" class="headerlink" title="Protobuf 版本不兼容"></a><strong>Protobuf 版本不兼容</strong></h4><p>如果依赖项目对 Protobuf 有版本要求，建议使用源码安装并选择特定版本。</p><h4 id="构建速度慢"><a href="#构建速度慢" class="headerlink" title="构建速度慢"></a><strong>构建速度慢</strong></h4><p>可以使用 <code>make -j$(nproc)</code>，利用多核加速编译。</p><hr><h2 id="源码安装-gflags"><a href="#源码安装-gflags" class="headerlink" title="源码安装 gflags"></a>源码安装 <code>gflags</code></h2><p>以下是从源码安装 <code>gflags</code> 的完整步骤：</p><h3 id="0-卸载旧的-gflags"><a href="#0-卸载旧的-gflags" class="headerlink" title="0. 卸载旧的 gflags"></a><strong>0. 卸载旧的 gflags</strong></h3><p>如果你之前安装了 gflags，可以先清除它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /usr/local/lib/libgflags.*<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /usr/include/gflags<br></code></pre></td></tr></table></figure><hr><h3 id="1-安装必要的工具和依赖"><a href="#1-安装必要的工具和依赖" class="headerlink" title="1. 安装必要的工具和依赖"></a><strong>1. 安装必要的工具和依赖</strong></h3><p>确保你的系统中安装了构建工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install -y build-essential cmake git<br></code></pre></td></tr></table></figure><hr><h3 id="2-下载-gflags-源码"><a href="#2-下载-gflags-源码" class="headerlink" title="2. 下载 gflags 源码"></a><strong>2. 下载 <code>gflags</code> 源码</strong></h3><p>从 <code>gflags</code> 官方仓库克隆源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/gflags/gflags.git<br><span class="hljs-built_in">cd</span> gflags<br></code></pre></td></tr></table></figure><hr><h3 id="3-创建和进入构建目录"><a href="#3-创建和进入构建目录" class="headerlink" title="3. 创建和进入构建目录"></a><strong>3. 创建和进入构建目录</strong></h3><p>创建独立的构建目录以保持源码整洁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><hr><h3 id="4-配置编译选项"><a href="#4-配置编译选项" class="headerlink" title="4. 配置编译选项"></a><strong>4. 配置编译选项</strong></h3><p>运行 <code>cmake</code> 命令配置编译选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake .. -DCMAKE_CXX_FLAGS=<span class="hljs-string">&quot;-fPIC&quot;</span> -DCMAKE_POSITION_INDEPENDENT_CODE=ON -DBUILD_SHARED_LIBS=ON<br></code></pre></td></tr></table></figure><hr><h3 id="5-编译"><a href="#5-编译" class="headerlink" title="5. 编译"></a><strong>5. 编译</strong></h3><p>使用 <code>make</code> 命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><ul><li><code>$(nproc)</code> 会根据 CPU 核心数并行编译，加速构建过程。</li></ul><hr><h3 id="6-安装"><a href="#6-安装" class="headerlink" title="6. 安装"></a><strong>6. 安装</strong></h3><p>编译完成后，安装到指定路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><hr><h3 id="7-验证安装"><a href="#7-验证安装" class="headerlink" title="7. 验证安装"></a><strong>7. 验证安装</strong></h3><p>验证 <code>gflags</code> 的头文件和库文件是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /usr/local/include/gflags<br><span class="hljs-built_in">ls</span> /usr/local/lib | grep gflags<br></code></pre></td></tr></table></figure><p>如果看到类似以下内容，说明安装成功：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/include/g</span>flags/gflags.h<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>libgflags.so<br></code></pre></td></tr></table></figure><hr><h3 id="8-配置环境变量（如果必要）"><a href="#8-配置环境变量（如果必要）" class="headerlink" title="8. 配置环境变量（如果必要）"></a><strong>8. 配置环境变量（如果必要）</strong></h3><p>如果库文件安装到非标准路径（如 <code>/usr/local/lib</code>），需要配置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LIBRARY_PATH=/usr/local/lib:<span class="hljs-variable">$LIBRARY_PATH</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></table></figure><p>将上述命令添加到 <code>~/.bashrc</code> 以永久生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><hr><h3 id="9-清理源码（可选）"><a href="#9-清理源码（可选）" class="headerlink" title="9. 清理源码（可选）"></a><strong>9. 清理源码（可选）</strong></h3><p>安装完成后，可以删除源码目录以节省空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ../..<br><span class="hljs-built_in">rm</span> -rf gflags<br></code></pre></td></tr></table></figure><h2 id="源码安装-glog"><a href="#源码安装-glog" class="headerlink" title="源码安装 glog"></a>源码安装 <code>glog</code></h2><p>以下是从源码安装 <code>glog</code> 的完整步骤：</p><hr><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a><strong>1. 安装依赖</strong></h3><p>确保系统已安装必要的工具和库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install -y build-essential cmake git<br></code></pre></td></tr></table></figure><hr><h3 id="2-下载-glog-源码"><a href="#2-下载-glog-源码" class="headerlink" title="2. 下载 glog 源码"></a><strong>2. 下载 <code>glog</code> 源码</strong></h3><p>从 <code>glog</code> 官方仓库克隆源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google/glog.git<br><span class="hljs-built_in">cd</span> glog<br></code></pre></td></tr></table></figure><hr><h3 id="3-创建和进入构建目录-1"><a href="#3-创建和进入构建目录-1" class="headerlink" title="3. 创建和进入构建目录"></a><strong>3. 创建和进入构建目录</strong></h3><p>创建独立的构建目录以保持源码整洁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><hr><h3 id="4-配置编译选项-1"><a href="#4-配置编译选项-1" class="headerlink" title="4. 配置编译选项"></a><strong>4. 配置编译选项</strong></h3><p>运行 <code>cmake</code> 配置构建环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local<br></code></pre></td></tr></table></figure><h4 id="参数解释：-1"><a href="#参数解释：-1" class="headerlink" title="参数解释："></a>参数解释：</h4><ul><li><code>-DCMAKE_BUILD_TYPE=Release</code>: 构建优化后的发布版本。</li><li><code>-DCMAKE_INSTALL_PREFIX=/usr/local</code>: 安装到 <code>/usr/local</code>。</li></ul><hr><h3 id="5-编译-1"><a href="#5-编译-1" class="headerlink" title="5. 编译"></a><strong>5. 编译</strong></h3><p>使用 <code>make</code> 编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><p><code>$(nproc)</code> 会根据 CPU 核心数并行编译，加速构建过程。</p><hr><h3 id="6-安装-1"><a href="#6-安装-1" class="headerlink" title="6. 安装"></a><strong>6. 安装</strong></h3><p>安装 <code>glog</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><hr><h3 id="7-验证安装-1"><a href="#7-验证安装-1" class="headerlink" title="7. 验证安装"></a><strong>7. 验证安装</strong></h3><p>检查 <code>glog</code> 是否安装成功：</p><h4 id="检查头文件："><a href="#检查头文件：" class="headerlink" title="检查头文件："></a>检查头文件：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /usr/local/include/glog<br></code></pre></td></tr></table></figure><p>输出类似以下内容表示成功：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">logging.h<br></code></pre></td></tr></table></figure><h4 id="检查库文件："><a href="#检查库文件：" class="headerlink" title="检查库文件："></a>检查库文件：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /usr/local/lib | grep glog<br></code></pre></td></tr></table></figure><p>输出类似以下内容表示成功：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">libglog.so<br>libglog.<span class="hljs-keyword">a</span><br></code></pre></td></tr></table></figure><hr><h3 id="8-配置环境变量（如果必要）-1"><a href="#8-配置环境变量（如果必要）-1" class="headerlink" title="8. 配置环境变量（如果必要）"></a><strong>8. 配置环境变量（如果必要）</strong></h3><p>如果库文件安装到了 <code>/usr/local/lib</code> 等非标准路径，添加以下环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LIBRARY_PATH=/usr/local/lib:<span class="hljs-variable">$LIBRARY_PATH</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></table></figure><p>将命令添加到 <code>~/.bashrc</code> 中以永久生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><hr><h3 id="9-清理源码（可选）-1"><a href="#9-清理源码（可选）-1" class="headerlink" title="9. 清理源码（可选）"></a><strong>9. 清理源码（可选）</strong></h3><p>安装完成后，可以删除源码以节省空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ../..<br><span class="hljs-built_in">rm</span> -rf glog<br></code></pre></td></tr></table></figure><hr><h3 id="10-如果需要指定-glog-位置"><a href="#10-如果需要指定-glog-位置" class="headerlink" title="10. 如果需要指定 glog 位置"></a><strong>10. 如果需要指定 <code>glog</code> 位置</strong></h3><p>在使用依赖 <code>glog</code> 的项目（如 <code>brpc</code>）时，手动指定 <code>glog</code> 的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake .. -DGLOG_INCLUDE_DIR=/usr/local/include -DGLOG_LIBRARY=/usr/local/lib/libglog.so<br></code></pre></td></tr></table></figure><hr><h2 id="源码安装-zlib"><a href="#源码安装-zlib" class="headerlink" title="源码安装 zlib"></a>源码安装 <code>zlib</code></h2><p>以下是从源码安装 <code>zlib</code> 的步骤：</p><hr><h3 id="1-下载-zlib-源码"><a href="#1-下载-zlib-源码" class="headerlink" title="1. 下载 zlib 源码"></a><strong>1. 下载 zlib 源码</strong></h3><p>访问 <a href="https://zlib.net/">zlib 官方网站</a> 下载最新版本的源码压缩包，或者直接使用以下命令下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://zlib.net/zlib-1.2.13.tar.gz<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：将 <code>1.2.13</code> 替换为你需要的具体版本号。</p></blockquote><hr><h3 id="2-解压源码包"><a href="#2-解压源码包" class="headerlink" title="2. 解压源码包"></a><strong>2. 解压源码包</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvzf zlib-1.2.13.tar.gz<br><span class="hljs-built_in">cd</span> zlib-1.2.13<br></code></pre></td></tr></table></figure><hr><h3 id="3-配置编译选项"><a href="#3-配置编译选项" class="headerlink" title="3. 配置编译选项"></a><strong>3. 配置编译选项</strong></h3><p>运行配置脚本，准备编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/usr/local/zlib<br></code></pre></td></tr></table></figure><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a><strong>参数说明</strong>：</h4><ul><li><code>--prefix=/usr/local/zlib</code>: 指定安装路径（可以根据需要更改）。</li></ul><hr><h3 id="4-编译-zlib"><a href="#4-编译-zlib" class="headerlink" title="4. 编译 zlib"></a><strong>4. 编译 zlib</strong></h3><p>使用 <code>make</code> 编译源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="5-安装-zlib"><a href="#5-安装-zlib" class="headerlink" title="5. 安装 zlib"></a><strong>5. 安装 zlib</strong></h3><p>运行以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><hr><h3 id="6-配置共享库路径"><a href="#6-配置共享库路径" class="headerlink" title="6. 配置共享库路径"></a><strong>6. 配置共享库路径</strong></h3><p>如果 <code>zlib</code> 被安装到非默认路径（例如 <code>/usr/local/zlib</code>），需要将其库路径加入系统库配置：</p><h4 id="添加到-etc-ld-so-conf-d-："><a href="#添加到-etc-ld-so-conf-d-：" class="headerlink" title="**添加到 /etc/ld.so.conf.d/**："></a>**添加到 <code>/etc/ld.so.conf.d/</code>**：</h4><p>创建一个新的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/local/zlib/lib&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/ld.so.conf.d/zlib.conf<br></code></pre></td></tr></table></figure><h4 id="更新共享库缓存："><a href="#更新共享库缓存：" class="headerlink" title="更新共享库缓存："></a><strong>更新共享库缓存</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure><hr><h3 id="7-验证安装-2"><a href="#7-验证安装-2" class="headerlink" title="7. 验证安装"></a><strong>7. 验证安装</strong></h3><p>通过以下命令确认 <code>zlib</code> 是否正确安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldconfig -p | grep zlib<br></code></pre></td></tr></table></figure><hr><h3 id="8-清理安装包（可选）"><a href="#8-清理安装包（可选）" class="headerlink" title="8. 清理安装包（可选）"></a><strong>8. 清理安装包（可选）</strong></h3><p>安装完成后，可以删除下载的压缩包和源码目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">rm</span> -rf zlib-1.2.13 zlib-1.2.13.tar.gz<br></code></pre></td></tr></table></figure><hr><h2 id="源码安装-OpenSSL"><a href="#源码安装-OpenSSL" class="headerlink" title="源码安装 OpenSSL"></a>源码安装 OpenSSL</h2><p>以下是从源码安装 OpenSSL 的详细步骤：</p><hr><h3 id="1-下载-OpenSSL-源码"><a href="#1-下载-OpenSSL-源码" class="headerlink" title="1. 下载 OpenSSL 源码"></a><strong>1. 下载 OpenSSL 源码</strong></h3><p>访问 <a href="https://www.openssl.org/source/">OpenSSL 官方网站</a> 下载最新稳定版本的源码，或者使用以下命令下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://www.openssl.org/source/openssl-1.1.1u.tar.gz<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：将 <code>1.1.1u</code> 替换为你需要的具体版本号。</p></blockquote><hr><h3 id="2-解压源码包-1"><a href="#2-解压源码包-1" class="headerlink" title="2. 解压源码包"></a><strong>2. 解压源码包</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvzf openssl-1.1.1u.tar.gz<br><span class="hljs-built_in">cd</span> openssl-1.1.1u<br></code></pre></td></tr></table></figure><hr><h3 id="3-配置编译选项-1"><a href="#3-配置编译选项-1" class="headerlink" title="3. 配置编译选项"></a><strong>3. 配置编译选项</strong></h3><p>运行配置脚本，准备编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl shared zlib<br></code></pre></td></tr></table></figure><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a><strong>参数说明</strong>：</h4><ul><li><code>--prefix=/usr/local/openssl</code>: 指定安装路径（可以根据需要更改）。</li><li><code>--openssldir=/usr/local/openssl</code>: 指定配置文件路径。</li><li><code>shared</code>: 编译共享库（<code>.so</code> 文件）。</li><li><code>zlib</code>: 启用 <code>zlib</code> 压缩支持（需要系统中已安装 <code>zlib</code>）。</li></ul><hr><h3 id="4-编译-OpenSSL"><a href="#4-编译-OpenSSL" class="headerlink" title="4. 编译 OpenSSL"></a><strong>4. 编译 OpenSSL</strong></h3><p>运行以下命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="5-安装-OpenSSL"><a href="#5-安装-OpenSSL" class="headerlink" title="5. 安装 OpenSSL"></a><strong>5. 安装 OpenSSL</strong></h3><p>使用以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><hr><h3 id="6-配置共享库路径-1"><a href="#6-配置共享库路径-1" class="headerlink" title="6. 配置共享库路径"></a><strong>6. 配置共享库路径</strong></h3><p>如果 OpenSSL 被安装到非默认路径（如 <code>/usr/local/openssl</code>），需要将其库路径加入系统库配置：</p><h4 id="添加到-etc-ld-so-conf-d-：-1"><a href="#添加到-etc-ld-so-conf-d-：-1" class="headerlink" title="**添加到 /etc/ld.so.conf.d/**："></a>**添加到 <code>/etc/ld.so.conf.d/</code>**：</h4><p>创建一个新的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/local/openssl/lib&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/ld.so.conf.d/openssl.conf<br></code></pre></td></tr></table></figure><h4 id="更新共享库缓存：-1"><a href="#更新共享库缓存：-1" class="headerlink" title="更新共享库缓存："></a><strong>更新共享库缓存</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure><hr><h3 id="7-替换系统默认的-OpenSSL（可选）"><a href="#7-替换系统默认的-OpenSSL（可选）" class="headerlink" title="7. 替换系统默认的 OpenSSL（可选）"></a><strong>7. 替换系统默认的 OpenSSL（可选）</strong></h3><p>如果需要使用新版本替换系统默认的 OpenSSL，可以更新路径：</p><h4 id="备份旧版本的-OpenSSL-可执行文件："><a href="#备份旧版本的-OpenSSL-可执行文件：" class="headerlink" title="备份旧版本的 OpenSSL 可执行文件："></a><strong>备份旧版本的 OpenSSL 可执行文件</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> /usr/bin/openssl /usr/bin/openssl.bak<br></code></pre></td></tr></table></figure><h4 id="创建新版本的软链接："><a href="#创建新版本的软链接：" class="headerlink" title="创建新版本的软链接："></a><strong>创建新版本的软链接</strong>：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> -s /usr/local/openssl/bin/openssl /usr/bin/openssl<br></code></pre></td></tr></table></figure><hr><h3 id="8-验证安装"><a href="#8-验证安装" class="headerlink" title="8. 验证安装"></a><strong>8. 验证安装</strong></h3><p>检查 OpenSSL 是否安装成功以及版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl version -a<br></code></pre></td></tr></table></figure><hr><h3 id="9-清理安装包（可选）"><a href="#9-清理安装包（可选）" class="headerlink" title="9. 清理安装包（可选）"></a><strong>9. 清理安装包（可选）</strong></h3><p>完成安装后，可以删除下载的压缩包和源码目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">rm</span> -rf openssl-1.1.1u openssl-1.1.1u.tar.gz<br></code></pre></td></tr></table></figure><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li><p>确保安装过程中未覆盖系统关键依赖的 OpenSSL，否则可能导致系统组件异常。</p></li><li><p>如果需要保留旧版本的 OpenSSL，可以同时维护多个版本，通过环境变量动态切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/openssl/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="源码安装brpc"><a href="#源码安装brpc" class="headerlink" title="源码安装brpc"></a>源码安装brpc</h2><p>从源码安装 bRPC 的过程包括获取源码、安装依赖项、构建和安装。以下是详细步骤：</p><hr><h3 id="1-获取-bRPC-源码"><a href="#1-获取-bRPC-源码" class="headerlink" title="1. 获取 bRPC 源码"></a>1. <strong>获取 bRPC 源码</strong></h3><p>bRPC 的源码托管在 GitHub 上。你可以通过以下命令克隆代码仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/apache/brpc.git<br><span class="hljs-built_in">cd</span> brpc<br></code></pre></td></tr></table></figure><hr><h3 id="2-安装依赖项"><a href="#2-安装依赖项" class="headerlink" title="2. 安装依赖项"></a>2. <strong>安装依赖项</strong></h3><p>bRPC 需要以下依赖项：</p><ul><li><strong>Protobuf</strong>: 用于序列化数据结构。</li><li><strong>gflags</strong>: 用于命令行参数解析。</li><li><strong>glog</strong>: 用于日志记录。</li><li><strong>zlib</strong>: 用于压缩支持。</li><li><strong>OpenSSL</strong>（可选）: 用于加密支持。</li></ul><p>以上依赖，都已经在上述步骤介绍过了，不在赘述。</p><h4 id="安装依赖项（以-Ubuntu-为例）"><a href="#安装依赖项（以-Ubuntu-为例）" class="headerlink" title="安装依赖项（以 Ubuntu 为例）"></a>安装依赖项（以 Ubuntu 为例）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install -y build-essential cmake git libprotobuf-dev protobuf-compiler libssl-dev zlib1g-dev libgflags-dev libgoogle-glog-dev<br></code></pre></td></tr></table></figure><p>如果你还没有安装 Protobuf，可以选择源码编译（推荐 3.x 版本）。</p><hr><h3 id="3-编译和安装-bRPC"><a href="#3-编译和安装-bRPC" class="headerlink" title="3. 编译和安装 bRPC"></a>3. <strong>编译和安装 bRPC</strong></h3><p>bRPC 支持两种构建系统：<code>cmake</code> 和 <code>make</code>。以下以两种方式分别介绍：</p><h4 id="方法一：使用-CMake"><a href="#方法一：使用-CMake" class="headerlink" title="方法一：使用 CMake"></a><strong>方法一：使用 CMake</strong></h4><p><strong>这也是我编译成功的方法。</strong></p><ol><li><p><strong>生成构建文件</strong> 确保你的 CMake 版本满足要求（建议 CMake 3.10+）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake .. -DGFLAGS_INCLUDE_DIR=/usr/local/include -DGFLAGS_LIBRARIES=/usr/local/lib/libgflags.so<br></code></pre></td></tr></table></figure></li><li><p><strong>编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><p>默认安装路径是 <code>/usr/local/</code>。你可以通过设置 <code>CMAKE_INSTALL_PREFIX</code> 更改安装路径，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -DCMAKE_INSTALL_PREFIX=/your/custom/path ..<br></code></pre></td></tr></table></figure></li></ol><h4 id="方法二：使用-Make"><a href="#方法二：使用-Make" class="headerlink" title="方法二：使用 Make"></a><strong>方法二：使用 Make</strong></h4><ol><li><p><strong>配置环境</strong> 在 bRPC 源码根目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh config_brpc.sh --headers=/usr/include --libs=/usr/lib<br></code></pre></td></tr></table></figure></li><li><p><strong>编译</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>安装</strong> 如果没有安装错误，可以手动将生成的文件拷贝到目标路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> -r output/include/* /usr/local/include/<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> -r output/lib/* /usr/local/lib/<br><span class="hljs-built_in">sudo</span> ldconfig<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4. 验证安装"></a>4. <strong>验证安装</strong></h3><p>通过运行 bRPC 自带的单元测试验证是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span><br>./run_tests.sh<br></code></pre></td></tr></table></figure><hr><h3 id="5-常见问题排查"><a href="#5-常见问题排查" class="headerlink" title="5. 常见问题排查"></a>5. <strong>常见问题排查</strong></h3><h4 id="找不到-Protobuf"><a href="#找不到-Protobuf" class="headerlink" title="找不到 Protobuf"></a>找不到 Protobuf</h4><p>如果 CMake 或 Make 报错找不到 Protobuf，你可以通过设置环境变量指定 Protobuf 的路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> Protobuf_INCLUDE_DIR=/path/to/protobuf/include<br><span class="hljs-built_in">export</span> Protobuf_LIB_DIR=/path/to/protobuf/lib<br></code></pre></td></tr></table></figure><p>或者在编译时传递相关路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake -DProtobuf_INCLUDE_DIR=/path/to/protobuf/include -DProtobuf_LIB_DIR=/path/to/protobuf/lib ..<br></code></pre></td></tr></table></figure><h4 id="找不到依赖的库"><a href="#找不到依赖的库" class="headerlink" title="找不到依赖的库"></a>找不到依赖的库</h4><p>如果编译时报缺少某些依赖库，可以尝试重新安装或检查路径是否正确。确保 <code>LD_LIBRARY_PATH</code> 中包含相关库路径，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/usr/local/lib<br></code></pre></td></tr></table></figure><hr><h3 id="6-使用示例"><a href="#6-使用示例" class="headerlink" title="6. 使用示例"></a>6. <strong>使用示例</strong></h3><p>安装完成后，可以参考 <a href="https://github.com/apache/brpc/blob/master/example/">bRPC 官方示例</a> 来测试 bRPC 的基本功能。例如运行 <code>echo_c++</code> 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> example/echo_c++/<br>sh run.sh<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CXX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>brpc CXX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程调用系统函数会发生什么？</title>
    <link href="/2024/11/16/Coroutine%E2%85%A0/"/>
    <url>/2024/11/16/Coroutine%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<p>前几天被人问及协程调用系统函数会发生什么，这个问题还是很有趣的，不同的语言和模型实现的机制会有所不同，今天特地用几种流行的语言实现研究了一下，结果也是非常有趣。</p><p>在协程中调用系统调用函数是否成功，取决于以下几个因素： </p><ol><li><strong>系统调用的类型</strong>（阻塞&#x2F;非阻塞）。  </li><li><strong>协程的实现机制</strong>（用户态、内核态，或者语言特性）。  </li><li><strong>语言运行时及其调度模型</strong>。</li></ol><p>不同语言和运行时对协程的实现差异会导致行为不同。以下是详细分析：</p><hr><h2 id="1-系统调用和协程的交互：基本原理"><a href="#1-系统调用和协程的交互：基本原理" class="headerlink" title="1. 系统调用和协程的交互：基本原理"></a><strong>1. 系统调用和协程的交互：基本原理</strong></h2><ul><li><strong>系统调用（System Call）</strong><br>系统调用通常会涉及操作系统内核。如果是 <strong>阻塞型系统调用</strong>，线程会被挂起，直到调用完成。  </li><li><strong>协程</strong><br>协程是轻量级的用户态调度任务，本质上是线程内的逻辑划分。协程本身无法直接控制线程的阻塞行为。</li></ul><p>如果协程中的阻塞型系统调用阻塞了线程，那么该线程上的所有协程都会被阻塞。</p><hr><h2 id="2-不同语言对协程和系统调用的处理"><a href="#2-不同语言对协程和系统调用的处理" class="headerlink" title="2. 不同语言对协程和系统调用的处理"></a><strong>2. 不同语言对协程和系统调用的处理</strong></h2><h3 id="1-C-（依赖库实现，如-Boost-或-C-20-协程）"><a href="#1-C-（依赖库实现，如-Boost-或-C-20-协程）" class="headerlink" title="(1) C++（依赖库实现，如 Boost 或 C++20 协程）"></a><strong>(1) C++（依赖库实现，如 Boost 或 C++20 协程）</strong></h3><ul><li><strong>协程实现</strong>  <ul><li>C++协程通常是用户态协程（如 <code>Boost.Context</code> 或 C++20 <code>co_await</code>）。</li><li>调用阻塞系统调用时，整个线程会被阻塞，因为没有协程调度机制去避免线程阻塞。</li></ul></li><li><strong>结果</strong>  <ul><li>系统调用会成功，但调用期间会导致整个线程和其协程挂起。</li><li>需要依赖非阻塞系统调用（如 <code>epoll</code>、<code>io_uring</code>）或使用第三方 I&#x2F;O 库（如 libuv）实现高效协作。</li></ul></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> &#123;<br>        <span class="hljs-function">Task <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function">std::suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function">std::suspend_never <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_void</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;;<br>&#125;;<br><br><span class="hljs-function">Task <span class="hljs-title">myCoroutine</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; starts.\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 阻塞系统调用</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Coroutine &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; ends.\n&quot;</span>;<br>    <span class="hljs-keyword">co_return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">myCoroutine</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">myCoroutine</span>(<span class="hljs-number">2</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;All done.\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs erlang">Coroutine <span class="hljs-number">1</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br>Coroutine <span class="hljs-number">1</span> ends.<br>Coroutine <span class="hljs-number">2</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br>Coroutine <span class="hljs-number">2</span> ends.<br>All done.<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-Java（如虚拟线程或常规线程池协程）"><a href="#2-Java（如虚拟线程或常规线程池协程）" class="headerlink" title="(2) Java（如虚拟线程或常规线程池协程）"></a><strong>(2) Java（如虚拟线程或常规线程池协程）</strong></h3><ul><li><strong>协程实现</strong>  <ul><li>Java 协程（如 Loom 项目的虚拟线程）利用语言级的调度模型，允许阻塞系统调用时挂起虚拟线程，而不是物理线程。</li></ul></li><li><strong>结果</strong>  <ul><li>系统调用会成功。对于虚拟线程，阻塞型系统调用只会挂起当前协程，不会阻塞底层物理线程。</li><li>传统线程池模型中，阻塞型调用会阻塞线程，进而影响其他协程。</li></ul></li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaCoroutineExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Using traditional thread pool:&quot;</span>);<br>        runWithThreadPool();<br><br>        System.out.println(<span class="hljs-string">&quot;\nUsing virtual threads:&quot;</span>);<br>        runWithVirtualThreads();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWithThreadPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> java.util.concurrent.Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        executor.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Task 1 starts.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 阻塞系统调用</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Task 1 ends.&quot;</span>);<br>        &#125;);<br><br>        executor.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Task 2 starts.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 阻塞系统调用</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Task 2 ends.&quot;</span>);<br>        &#125;);<br><br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">5</span>, java.util.concurrent.TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWithVirtualThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> java.util.concurrent.Executors.newThreadPerTaskExecutor(<br>                java.util.concurrent.Thread.ofVirtual().factory()<br>        );<br><br>        executor.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Task 1 starts.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 阻塞系统调用</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Task 1 ends.&quot;</span>);<br>        &#125;);<br><br>        executor.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Task 2 starts.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 阻塞系统调用</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Task 2 ends.&quot;</span>);<br>        &#125;);<br><br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">5</span>, java.util.concurrent.TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Using traditional thread pool:<br><span class="hljs-built_in">Task</span> <span class="hljs-number">1</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-built_in">Task</span> <span class="hljs-number">1</span> ends.<br><span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> ends.<br><br>Using <span class="hljs-keyword">virtual</span> threads:<br><span class="hljs-built_in">Task</span> <span class="hljs-number">1</span> starts.<br><span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-built_in">Task</span> <span class="hljs-number">1</span> ends.<br><span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> ends.<br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="3-Go（基于-Goroutine-的实现）"><a href="#3-Go（基于-Goroutine-的实现）" class="headerlink" title="(3) Go（基于 Goroutine 的实现）"></a><strong>(3) Go（基于 Goroutine 的实现）</strong></h3><ul><li><strong>协程实现</strong>  <ul><li>Go 的 Goroutine 是 M:N 的用户态线程模型。调度器能够检测到阻塞系统调用，通过线程劫持将其他 Goroutine 调度到不同的线程上执行。</li></ul></li><li><strong>结果</strong>  <ul><li>系统调用会成功。即使是阻塞型系统调用，也只会阻塞当前 Goroutine，其他 Goroutine 不受影响。</li><li>Go 调度器动态分配物理线程来避免阻塞问题。</li></ul></li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">task</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Task %d starts.\n&quot;</span>, id)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">// 阻塞系统调用</span><br>fmt.Printf(<span class="hljs-string">&quot;Task %d ends.\n&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> task(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> task(<span class="hljs-number">2</span>)<br>time.Sleep(<span class="hljs-number">3</span> * time.Second) <span class="hljs-comment">// 等待所有 Goroutine 完成</span><br>fmt.Println(<span class="hljs-string">&quot;All done.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> starts.<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> ends.<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> ends.<br><span class="hljs-keyword">All</span> done.<br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="4-Python（基于-asyncio-或协程库实现）"><a href="#4-Python（基于-asyncio-或协程库实现）" class="headerlink" title="(4) Python（基于 asyncio 或协程库实现）"></a><strong>(4) Python（基于 <code>asyncio</code> 或协程库实现）</strong></h3><ul><li><strong>协程实现</strong>  <ul><li>Python 的 <code>asyncio</code> 使用事件循环管理协程，依赖非阻塞 I&#x2F;O 实现并行任务。</li></ul></li><li><strong>结果</strong>  <ul><li>如果在 <code>asyncio</code> 中调用阻塞型系统调用，会阻塞事件循环，导致整个程序挂起。</li><li>为避免这种问题，可以将阻塞任务交给线程池或进程池处理（如 <code>loop.run_in_executor</code>）。</li></ul></li></ul><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span> starts.&quot;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 阻塞系统调用</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span> ends.&quot;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">await</span> asyncio.gather(task(<span class="hljs-number">1</span>), task(<span class="hljs-number">2</span>))<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> ends.<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> ends.<br></code></pre></td></tr></table></figure><h3 id="改进（避免阻塞）"><a href="#改进（避免阻塞）" class="headerlink" title="改进（避免阻塞）"></a>改进（避免阻塞）</h3><p>使用 <code>await asyncio.sleep()</code> 替代 <code>time.sleep()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span> starts.&quot;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 非阻塞</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span> ends.&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> starts.<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> starts.<br>(<span class="hljs-number">2</span>秒后)<br><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> ends.<br><span class="hljs-keyword">Task</span> <span class="hljs-number">2</span> ends.<br></code></pre></td></tr></table></figure><hr><hr><h2 id="3-总结对比"><a href="#3-总结对比" class="headerlink" title="3. 总结对比"></a><strong>3. 总结对比</strong></h2><table><thead><tr><th>语言&#x2F;运行时</th><th>调用阻塞系统调用的行为</th><th>协程调度模型</th><th>解决方案</th></tr></thead><tbody><tr><td><strong>C++</strong></td><td>阻塞整个线程和所有协程</td><td>用户态协程</td><td>使用非阻塞 I&#x2F;O 或库支持</td></tr><tr><td><strong>Java</strong></td><td>阻塞虚拟线程（对物理线程无影响）或阻塞线程池线程</td><td>虚拟线程&#x2F;线程池协程</td><td>使用 Loom 虚拟线程优化</td></tr><tr><td><strong>Go</strong></td><td>只阻塞当前 Goroutine，其他 Goroutine 不受影响</td><td>M:N 用户态协程</td><td>调度器自动分配线程</td></tr><tr><td><strong>Python</strong></td><td>阻塞事件循环，导致所有协程暂停</td><td>单线程事件循环（<code>asyncio</code>）</td><td>使用线程池&#x2F;进程池避免阻塞问题</td></tr></tbody></table><hr><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a><strong>4. 注意事项</strong></h2><ol><li><p><strong>阻塞型调用和协程性能瓶颈</strong></p><ul><li>阻塞型调用会带来性能问题，尤其在高并发环境下。</li><li>推荐使用非阻塞 I&#x2F;O 或异步库（如 <code>aiofiles</code>、<code>aiohttp</code>）。</li></ul></li><li><p><strong>运行时支持的重要性</strong></p><ul><li>高效协程调度模型（如 Go 和 Loom）能够避免阻塞型调用对系统整体性能的影响。</li></ul></li><li><p><strong>上下文切换代价</strong></p><ul><li>协程通过减少线程的上下文切换提高性能，但这并不意味着能完全替代非阻塞 I&#x2F;O。</li></ul></li></ol><hr><p>如果目标是实现高效的 I&#x2F;O 密集型任务，推荐采用支持非阻塞 I&#x2F;O 和高效协程模型的语言&#x2F;运行时，比如 Go 或 Java 的 Loom。</p>]]></content>
    
    
    <categories>
      
      <category>Coroutine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coroutine 系统调用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的常用查询语句集锦</title>
    <link href="/2024/11/13/MySQLQuery/"/>
    <url>/2024/11/13/MySQLQuery/</url>
    
    <content type="html"><![CDATA[<p>最近参加了一些传统企业的面试，通常都会写一份笔试题，和大厂不一样，他们是真的笔试题（纸质试卷，考察技术基础题：比如语言特性、计算机体系结构、SQL等），虽然说是技术基础，但是很多题目难度还是很高的，比如MySQL的查询语句，不仅考察基础知识，还考察如何解决复杂的业务问题。故此，我翻阅了一些博客和书籍，记录了一些典型的MySQL查询场景，提供建表语句和解答，而且难度是依次递增，非常有趣。</p><h2 id="1-查询条件和排序"><a href="#1-查询条件和排序" class="headerlink" title="1. 查询条件和排序"></a>1. 查询条件和排序</h2><h3 id="题目-1：查找价格大于-50-的产品，并按照创建日期降序排列"><a href="#题目-1：查找价格大于-50-的产品，并按照创建日期降序排列" class="headerlink" title="题目 1：查找价格大于 50 的产品，并按照创建日期降序排列"></a>题目 1：查找价格大于 50 的产品，并按照创建日期降序排列</h3><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> products (<br>    product_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    product_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    price <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br>    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> products (product_name, price) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Product A&#x27;</span>, <span class="hljs-number">55.50</span>), <br>(<span class="hljs-string">&#x27;Product B&#x27;</span>, <span class="hljs-number">45.00</span>), <br>(<span class="hljs-string">&#x27;Product C&#x27;</span>, <span class="hljs-number">60.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_name, price <br><span class="hljs-keyword">FROM</span> products <br><span class="hljs-keyword">WHERE</span> price <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> created_at <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h2 id="2-复杂条件查询"><a href="#2-复杂条件查询" class="headerlink" title="2. 复杂条件查询"></a>2. 复杂条件查询</h2><h3 id="题目-2：查询在2023年内购买的订单，且订单金额在100到500之间的订单记录"><a href="#题目-2：查询在2023年内购买的订单，且订单金额在100到500之间的订单记录" class="headerlink" title="题目 2：查询在2023年内购买的订单，且订单金额在100到500之间的订单记录"></a>题目 2：查询在2023年内购买的订单，且订单金额在100到500之间的订单记录</h3><h4 id="建表语句-1"><a href="#建表语句-1" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    order_date <span class="hljs-type">DATE</span>,<br>    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (order_date, amount) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;2023-02-15&#x27;</span>, <span class="hljs-number">120.00</span>), <br>(<span class="hljs-string">&#x27;2023-07-19&#x27;</span>, <span class="hljs-number">300.00</span>), <br>(<span class="hljs-string">&#x27;2022-10-10&#x27;</span>, <span class="hljs-number">250.00</span>),<br>(<span class="hljs-string">&#x27;2023-05-10&#x27;</span>, <span class="hljs-number">95.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-1"><a href="#查询语句-1" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_id, amount <br><span class="hljs-keyword">FROM</span> orders <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(order_date) <span class="hljs-operator">=</span> <span class="hljs-number">2023</span> <br><span class="hljs-keyword">AND</span> amount <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><h2 id="3-分组和聚合函数"><a href="#3-分组和聚合函数" class="headerlink" title="3. 分组和聚合函数"></a>3. 分组和聚合函数</h2><h3 id="题目-3：按客户统计订单数量，并筛选出订单数量超过-2-的客户"><a href="#题目-3：按客户统计订单数量，并筛选出订单数量超过-2-的客户" class="headerlink" title="题目 3：按客户统计订单数量，并筛选出订单数量超过 2 的客户"></a>题目 3：按客户统计订单数量，并筛选出订单数量超过 2 的客户</h3><h4 id="建表语句-2"><a href="#建表语句-2" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customers (<br>    customer_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_id <span class="hljs-type">INT</span>,<br>    order_date <span class="hljs-type">DATE</span>,<br>    <span class="hljs-keyword">FOREIGN</span> KEY (customer_id) <span class="hljs-keyword">REFERENCES</span> customers(customer_id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (customer_name) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>), <br>(<span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-05-01&#x27;</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-06-15&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-07-20&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-08-10&#x27;</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-09-01&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-2"><a href="#查询语句-2" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customer_id, <span class="hljs-built_in">COUNT</span>(order_id) <span class="hljs-keyword">AS</span> order_count <br><span class="hljs-keyword">FROM</span> orders <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> customer_id <br><span class="hljs-keyword">HAVING</span> order_count <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="4-联表查询（JOIN）"><a href="#4-联表查询（JOIN）" class="headerlink" title="4. 联表查询（JOIN）"></a>4. 联表查询（JOIN）</h2><h3 id="题目-4：查询所有订单信息，包括每个订单的客户姓名"><a href="#题目-4：查询所有订单信息，包括每个订单的客户姓名" class="headerlink" title="题目 4：查询所有订单信息，包括每个订单的客户姓名"></a>题目 4：查询所有订单信息，包括每个订单的客户姓名</h3><h4 id="建表语句-3"><a href="#建表语句-3" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customers (<br>    customer_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_id <span class="hljs-type">INT</span>,<br>    order_date <span class="hljs-type">DATE</span>,<br>    <span class="hljs-keyword">FOREIGN</span> KEY (customer_id) <span class="hljs-keyword">REFERENCES</span> customers(customer_id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (customer_name) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-05-01&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-06-15&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-3"><a href="#查询语句-3" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> o.order_id, o.order_date, c.customer_name <br><span class="hljs-keyword">FROM</span> orders o <br><span class="hljs-keyword">JOIN</span> customers c <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id;<br></code></pre></td></tr></table></figure><h2 id="5-子查询和嵌套查询"><a href="#5-子查询和嵌套查询" class="headerlink" title="5. 子查询和嵌套查询"></a>5. 子查询和嵌套查询</h2><h3 id="题目-5：查询订单总金额排名第二的客户姓名"><a href="#题目-5：查询订单总金额排名第二的客户姓名" class="headerlink" title="题目 5：查询订单总金额排名第二的客户姓名"></a>题目 5：查询订单总金额排名第二的客户姓名</h3><h4 id="建表语句-4"><a href="#建表语句-4" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customers (<br>    customer_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_id <span class="hljs-type">INT</span>,<br>    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (customer_name) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>), <br>(<span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, amount) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-number">120.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-number">300.00</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-number">200.00</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-number">250.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-4"><a href="#查询语句-4" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customer_name <br><span class="hljs-keyword">FROM</span> customers <br><span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">SELECT</span> customer_id <br>    <span class="hljs-keyword">FROM</span> orders <br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> customer_id <br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">DESC</span> <br>    LIMIT <span class="hljs-number">1</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">1</span><br>);<br></code></pre></td></tr></table></figure><h2 id="6-窗口函数"><a href="#6-窗口函数" class="headerlink" title="6. 窗口函数"></a>6. 窗口函数</h2><h3 id="题目-6：对于每个客户，按订单日期排序，获取每个订单的累计金额"><a href="#题目-6：对于每个客户，按订单日期排序，获取每个订单的累计金额" class="headerlink" title="题目 6：对于每个客户，按订单日期排序，获取每个订单的累计金额"></a>题目 6：对于每个客户，按订单日期排序，获取每个订单的累计金额</h3><h4 id="建表语句-5"><a href="#建表语句-5" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_id <span class="hljs-type">INT</span>,<br>    order_date <span class="hljs-type">DATE</span>,<br>    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date, amount) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-05-01&#x27;</span>, <span class="hljs-number">120.00</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-06-15&#x27;</span>, <span class="hljs-number">200.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-07-20&#x27;</span>, <span class="hljs-number">300.00</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-09-01&#x27;</span>, <span class="hljs-number">150.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-5"><a href="#查询语句-5" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customer_id, order_date, amount,<br>       <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> customer_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_date) <span class="hljs-keyword">AS</span> cumulative_amount<br><span class="hljs-keyword">FROM</span> orders;<br></code></pre></td></tr></table></figure><p>注意，以上是累计金额。</p><p>以上就是关于MySQL查询语句的部分面试题示例。每道题都从不同的场景入手，涵盖了条件查询、排序、分组、联表、子查询、窗口函数等内容，希望能帮助你加深对MySQL复杂查询的理解。</p><p>继续进阶</p><h2 id="7-窗口函数排名"><a href="#7-窗口函数排名" class="headerlink" title="7. 窗口函数排名"></a>7. 窗口函数排名</h2><h3 id="题目-7：查找每个部门中薪资排名前-2-的员工"><a href="#题目-7：查找每个部门中薪资排名前-2-的员工" class="headerlink" title="题目 7：查找每个部门中薪资排名前 2 的员工"></a>题目 7：查找每个部门中薪资排名前 2 的员工</h3><h4 id="建表语句-6"><a href="#建表语句-6" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    department_id <span class="hljs-type">INT</span>,<br>    salary <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees (employee_name, department_id, salary) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8000.00</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7500.00</span>), <br>(<span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9000.00</span>),<br>(<span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6000.00</span>), <br>(<span class="hljs-string">&#x27;Eve&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8500.00</span>), <br>(<span class="hljs-string">&#x27;Frank&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7000.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-6"><a href="#查询语句-6" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_name, department_id, salary <br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> employee_name, department_id, salary,<br>           <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rank<br>    <span class="hljs-keyword">FROM</span> employees<br>) <span class="hljs-keyword">AS</span> ranked_employees <br><span class="hljs-keyword">WHERE</span> rank <span class="hljs-operator">&lt;=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="8-递归查询（层级结构）"><a href="#8-递归查询（层级结构）" class="headerlink" title="8. 递归查询（层级结构）"></a>8. 递归查询（层级结构）</h2><h3 id="题目-8：查询员工的所有上级，要求从直接上级到最高上级按顺序排列"><a href="#题目-8：查询员工的所有上级，要求从直接上级到最高上级按顺序排列" class="headerlink" title="题目 8：查询员工的所有上级，要求从直接上级到最高上级按顺序排列"></a>题目 8：查询员工的所有上级，要求从直接上级到最高上级按顺序排列</h3><h4 id="建表语句-7"><a href="#建表语句-7" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hierarchy (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    manager_id <span class="hljs-type">INT</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hierarchy (employee_id, manager_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-keyword">NULL</span>),   <span class="hljs-comment">-- CEO (最高管理层)</span><br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>),      <span class="hljs-comment">-- 直接上级为 CEO</span><br>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>),      <span class="hljs-comment">-- 上级为 2</span><br>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), <br>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-7"><a href="#查询语句-7" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> managers <span class="hljs-keyword">AS</span> (<br>    <span class="hljs-keyword">SELECT</span> employee_id, manager_id, <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> level<br>    <span class="hljs-keyword">FROM</span> hierarchy<br>    <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>  <span class="hljs-comment">-- 假设要查询员工 ID 为 5 的所有上级</span><br>    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>    <span class="hljs-keyword">SELECT</span> h.employee_id, h.manager_id, m.level <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">FROM</span> hierarchy h<br>    <span class="hljs-keyword">JOIN</span> managers m <span class="hljs-keyword">ON</span> h.employee_id <span class="hljs-operator">=</span> m.manager_id<br>)<br><span class="hljs-keyword">SELECT</span> employee_id, manager_id, level<br><span class="hljs-keyword">FROM</span> managers<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> level;<br></code></pre></td></tr></table></figure><hr><h2 id="9-复杂联表查询和条件过滤"><a href="#9-复杂联表查询和条件过滤" class="headerlink" title="9. 复杂联表查询和条件过滤"></a>9. 复杂联表查询和条件过滤</h2><h3 id="题目-9：查找所有项目中参与人数超过-5-人，且项目完成时间少于-3-个月的项目"><a href="#题目-9：查找所有项目中参与人数超过-5-人，且项目完成时间少于-3-个月的项目" class="headerlink" title="题目 9：查找所有项目中参与人数超过 5 人，且项目完成时间少于 3 个月的项目"></a>题目 9：查找所有项目中参与人数超过 5 人，且项目完成时间少于 3 个月的项目</h3><h4 id="建表语句-8"><a href="#建表语句-8" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> projects (<br>    project_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    project_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    start_date <span class="hljs-type">DATE</span>,<br>    end_date <span class="hljs-type">DATE</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> project_assignments (<br>    project_id <span class="hljs-type">INT</span>,<br>    employee_id <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (project_id, employee_id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> projects (project_id, project_name, start_date, end_date) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Project Alpha&#x27;</span>, <span class="hljs-string">&#x27;2023-01-01&#x27;</span>, <span class="hljs-string">&#x27;2023-03-01&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Project Beta&#x27;</span>, <span class="hljs-string">&#x27;2023-02-01&#x27;</span>, <span class="hljs-string">&#x27;2023-05-01&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> project_assignments (project_id, employee_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-8"><a href="#查询语句-8" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> p.project_name<br><span class="hljs-keyword">FROM</span> projects p<br><span class="hljs-keyword">JOIN</span> project_assignments pa <span class="hljs-keyword">ON</span> p.project_id <span class="hljs-operator">=</span> pa.project_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> p.project_id, p.project_name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(pa.employee_id) <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br>   <span class="hljs-keyword">AND</span> DATEDIFF(p.end_date, p.start_date) <span class="hljs-operator">&lt;</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="10-组合查询与聚合函数"><a href="#10-组合查询与聚合函数" class="headerlink" title="10. 组合查询与聚合函数"></a>10. 组合查询与聚合函数</h2><h3 id="题目-10：统计每个月新增客户数和订单总额，显示月份、客户数、订单金额，并按月份排序"><a href="#题目-10：统计每个月新增客户数和订单总额，显示月份、客户数、订单金额，并按月份排序" class="headerlink" title="题目 10：统计每个月新增客户数和订单总额，显示月份、客户数、订单金额，并按月份排序"></a>题目 10：统计每个月新增客户数和订单总额，显示月份、客户数、订单金额，并按月份排序</h3><h4 id="建表语句-9"><a href="#建表语句-9" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customers (<br>    customer_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    registration_date <span class="hljs-type">DATE</span><br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    customer_id <span class="hljs-type">INT</span>,<br>    order_date <span class="hljs-type">DATE</span>,<br>    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (customer_name, registration_date) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;2023-01-10&#x27;</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;2023-02-20&#x27;</span>), <br>(<span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-string">&#x27;2023-02-25&#x27;</span>), <br>(<span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;2023-03-01&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date, amount) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-01-20&#x27;</span>, <span class="hljs-number">150.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-02-25&#x27;</span>, <span class="hljs-number">200.00</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;2023-02-27&#x27;</span>, <span class="hljs-number">250.00</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;2023-03-15&#x27;</span>, <span class="hljs-number">300.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-9"><a href="#查询语句-9" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(registration_date, <span class="hljs-string">&#x27;%Y-%m&#x27;</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">month</span>,<br>       <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> customer_id) <span class="hljs-keyword">AS</span> new_customers,<br>       <span class="hljs-built_in">COALESCE</span>(<span class="hljs-built_in">SUM</span>(amount), <span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> total_orders<br><span class="hljs-keyword">FROM</span> customers c<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> o.customer_id <br><span class="hljs-keyword">AND</span> DATE_FORMAT(c.registration_date, <span class="hljs-string">&#x27;%Y-%m&#x27;</span>) <span class="hljs-operator">=</span> DATE_FORMAT(o.order_date, <span class="hljs-string">&#x27;%Y-%m&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">month</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">month</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="11-复杂子查询和条件过滤"><a href="#11-复杂子查询和条件过滤" class="headerlink" title="11. 复杂子查询和条件过滤"></a>11. 复杂子查询和条件过滤</h2><h3 id="题目-11：查询每位员工在所有项目中的平均工资排名"><a href="#题目-11：查询每位员工在所有项目中的平均工资排名" class="headerlink" title="题目 11：查询每位员工在所有项目中的平均工资排名"></a>题目 11：查询每位员工在所有项目中的平均工资排名</h3><h4 id="建表语句-10"><a href="#建表语句-10" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> salaries (<br>    employee_id <span class="hljs-type">INT</span>,<br>    project_id <span class="hljs-type">INT</span>,<br>    salary <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (employee_id, project_id)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees (employee_name) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>), <br>(<span class="hljs-string">&#x27;Charlie&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> salaries (employee_id, project_id, salary) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5000.00</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5500.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6000.00</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4500.00</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4800.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-10"><a href="#查询语句-10" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, <br>       <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> avg_salary,<br>       <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> salary_rank<br><span class="hljs-keyword">FROM</span> salaries<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> employee_id;<br></code></pre></td></tr></table></figure><hr><h2 id="12-使用-JSON-函数的复杂查询"><a href="#12-使用-JSON-函数的复杂查询" class="headerlink" title="12. 使用 JSON 函数的复杂查询"></a>12. 使用 JSON 函数的复杂查询</h2><h3 id="题目-12：查找包含某个特定技能的员工及其技能等级"><a href="#题目-12：查找包含某个特定技能的员工及其技能等级" class="headerlink" title="题目 12：查找包含某个特定技能的员工及其技能等级"></a>题目 12：查找包含某个特定技能的员工及其技能等级</h3><h4 id="建表语句-11"><a href="#建表语句-11" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employee_skills (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    skills JSON<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee_skills (employee_id, skills) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&#123; &quot;Java&quot;: &quot;Intermediate&quot;, &quot;Python&quot;: &quot;Advanced&quot; &#125;&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;&#123; &quot;Java&quot;: &quot;Beginner&quot;, &quot;SQL&quot;: &quot;Expert&quot; &#125;&#x27;</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;&#123; &quot;Python&quot;: &quot;Intermediate&quot;, &quot;SQL&quot;: &quot;Advanced&quot; &#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-11"><a href="#查询语句-11" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_id, JSON_UNQUOTE(skills<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.Python&quot;) <span class="hljs-keyword">AS</span> python_level<br><span class="hljs-keyword">FROM</span> employee_skills<br><span class="hljs-keyword">WHERE</span> JSON_CONTAINS_PATH(skills, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;$.Python&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这些题目涵盖了窗口函数、递归查询、条件过滤、组合查询、子查询、JSON数据查询等多种复杂查询情境，能够有效检验MySQL查询技能的广度和深度。</p><p>继续进阶</p><h2 id="13-公共表表达式（CTE）与递归查询"><a href="#13-公共表表达式（CTE）与递归查询" class="headerlink" title="13. 公共表表达式（CTE）与递归查询"></a>13. 公共表表达式（CTE）与递归查询</h2><h3 id="题目-13：查询某员工及其所有直接和间接下属，要求层级显示（层级越高，值越大）"><a href="#题目-13：查询某员工及其所有直接和间接下属，要求层级显示（层级越高，值越大）" class="headerlink" title="题目 13：查询某员工及其所有直接和间接下属，要求层级显示（层级越高，值越大）"></a>题目 13：查询某员工及其所有直接和间接下属，要求层级显示（层级越高，值越大）</h3><h4 id="建表语句-12"><a href="#建表语句-12" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    manager_id <span class="hljs-type">INT</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees (employee_id, employee_name, manager_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;CEO&#x27;</span>, <span class="hljs-keyword">NULL</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;VP1&#x27;</span>, <span class="hljs-number">1</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;VP2&#x27;</span>, <span class="hljs-number">1</span>), <br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Manager1&#x27;</span>, <span class="hljs-number">2</span>), <br>(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Manager2&#x27;</span>, <span class="hljs-number">2</span>), <br>(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Staff1&#x27;</span>, <span class="hljs-number">4</span>), <br>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Staff2&#x27;</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-12"><a href="#查询语句-12" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> employee_hierarchy <span class="hljs-keyword">AS</span> (<br>    <span class="hljs-keyword">SELECT</span> employee_id, employee_name, manager_id, <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> level<br>    <span class="hljs-keyword">FROM</span> employees<br>    <span class="hljs-keyword">WHERE</span> employee_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>  <span class="hljs-comment">-- 假设查询 VP1 的所有下属</span><br>    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>    <span class="hljs-keyword">SELECT</span> e.employee_id, e.employee_name, e.manager_id, eh.level <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">FROM</span> employees e<br>    <span class="hljs-keyword">JOIN</span> employee_hierarchy eh <span class="hljs-keyword">ON</span> e.manager_id <span class="hljs-operator">=</span> eh.employee_id<br>)<br><span class="hljs-keyword">SELECT</span> employee_name, level<br><span class="hljs-keyword">FROM</span> employee_hierarchy<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> level <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="14-复杂的时间间隔查询"><a href="#14-复杂的时间间隔查询" class="headerlink" title="14. 复杂的时间间隔查询"></a>14. 复杂的时间间隔查询</h2><h3 id="题目-14：查询每位客户最近两次下单的时间间隔（以天为单位）"><a href="#题目-14：查询每位客户最近两次下单的时间间隔（以天为单位）" class="headerlink" title="题目 14：查询每位客户最近两次下单的时间间隔（以天为单位）"></a>题目 14：查询每位客户最近两次下单的时间间隔（以天为单位）</h3><h4 id="建表语句-13"><a href="#建表语句-13" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    order_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    customer_id <span class="hljs-type">INT</span>,<br>    order_date <span class="hljs-type">DATE</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-01-10&#x27;</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-02-15&#x27;</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-03-20&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-02-25&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-03-10&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-13"><a href="#查询语句-13" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> customer_orders <span class="hljs-keyword">AS</span> (<br>    <span class="hljs-keyword">SELECT</span> customer_id, order_date,<br>           <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> customer_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_date <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> order_rank<br>    <span class="hljs-keyword">FROM</span> orders<br>)<br><span class="hljs-keyword">SELECT</span> c1.customer_id,<br>       DATEDIFF(c1.order_date, c2.order_date) <span class="hljs-keyword">AS</span> days_between<br><span class="hljs-keyword">FROM</span> customer_orders c1<br><span class="hljs-keyword">JOIN</span> customer_orders c2 <span class="hljs-keyword">ON</span> c1.customer_id <span class="hljs-operator">=</span> c2.customer_id<br><span class="hljs-keyword">WHERE</span> c1.order_rank <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> c2.order_rank <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="15-多表自关联查询"><a href="#15-多表自关联查询" class="headerlink" title="15. 多表自关联查询"></a>15. 多表自关联查询</h2><h3 id="题目-15：查找同一部门中工资差距最大的两位员工及其差距"><a href="#题目-15：查找同一部门中工资差距最大的两位员工及其差距" class="headerlink" title="题目 15：查找同一部门中工资差距最大的两位员工及其差距"></a>题目 15：查找同一部门中工资差距最大的两位员工及其差距</h3><h4 id="建表语句-14"><a href="#建表语句-14" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employees (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    department_id <span class="hljs-type">INT</span>,<br>    salary <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees (employee_name, department_id, salary) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7000.00</span>), <br>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8000.00</span>), <br>(<span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9500.00</span>), <br>(<span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6000.00</span>), <br>(<span class="hljs-string">&#x27;Eve&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7200.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-14"><a href="#查询语句-14" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e1.department_id, e1.employee_name <span class="hljs-keyword">AS</span> emp1, e2.employee_name <span class="hljs-keyword">AS</span> emp2,<br>       <span class="hljs-built_in">ABS</span>(e1.salary <span class="hljs-operator">-</span> e2.salary) <span class="hljs-keyword">AS</span> salary_difference<br><span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">JOIN</span> employees e2 <span class="hljs-keyword">ON</span> e1.department_id <span class="hljs-operator">=</span> e2.department_id <br><span class="hljs-keyword">AND</span> e1.employee_id <span class="hljs-operator">&lt;</span> e2.employee_id<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary_difference <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="16-组合查询：统计类和动态窗口查询"><a href="#16-组合查询：统计类和动态窗口查询" class="headerlink" title="16. 组合查询：统计类和动态窗口查询"></a>16. 组合查询：统计类和动态窗口查询</h2><h3 id="题目-16：查询所有员工中每月的工资发放总额，按月份排序"><a href="#题目-16：查询所有员工中每月的工资发放总额，按月份排序" class="headerlink" title="题目 16：查询所有员工中每月的工资发放总额，按月份排序"></a>题目 16：查询所有员工中每月的工资发放总额，按月份排序</h3><h4 id="建表语句-15"><a href="#建表语句-15" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> payroll (<br>    payroll_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    employee_id <span class="hljs-type">INT</span>,<br>    payment_date <span class="hljs-type">DATE</span>,<br>    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> payroll (employee_id, payment_date, amount) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-01-15&#x27;</span>, <span class="hljs-number">5000.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-01-15&#x27;</span>, <span class="hljs-number">6000.00</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-02-15&#x27;</span>, <span class="hljs-number">5000.00</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;2023-02-15&#x27;</span>, <span class="hljs-number">4500.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-02-15&#x27;</span>, <span class="hljs-number">6000.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-15"><a href="#查询语句-15" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(payment_date, <span class="hljs-string">&#x27;%Y-%m&#x27;</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">month</span>,<br>       <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> total_payout<br><span class="hljs-keyword">FROM</span> payroll<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">month</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">month</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="17-JSON-操作与条件过滤"><a href="#17-JSON-操作与条件过滤" class="headerlink" title="17. JSON 操作与条件过滤"></a>17. JSON 操作与条件过滤</h2><h3 id="题目-17：查找有技能“Python”且等级在“Advanced”或以上的员工姓名及其技能等级"><a href="#题目-17：查找有技能“Python”且等级在“Advanced”或以上的员工姓名及其技能等级" class="headerlink" title="题目 17：查找有技能“Python”且等级在“Advanced”或以上的员工姓名及其技能等级"></a>题目 17：查找有技能“Python”且等级在“Advanced”或以上的员工姓名及其技能等级</h3><h4 id="建表语句-16"><a href="#建表语句-16" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employee_skills (<br>    employee_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    skills JSON<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employee_skills (employee_id, employee_name, skills) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;&#123; &quot;Java&quot;: &quot;Intermediate&quot;, &quot;Python&quot;: &quot;Advanced&quot; &#125;&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;&#123; &quot;Python&quot;: &quot;Expert&quot;, &quot;SQL&quot;: &quot;Advanced&quot; &#125;&#x27;</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-string">&#x27;&#123; &quot;Python&quot;: &quot;Intermediate&quot; &#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-16"><a href="#查询语句-16" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> employee_name, JSON_UNQUOTE(skills<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>&quot;$.Python&quot;) <span class="hljs-keyword">AS</span> python_level<br><span class="hljs-keyword">FROM</span> employee_skills<br><span class="hljs-keyword">WHERE</span> JSON_EXTRACT(skills, <span class="hljs-string">&#x27;$.Python&#x27;</span>) <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;&quot;Advanced&quot;&#x27;</span>, <span class="hljs-string">&#x27;&quot;Expert&quot;&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="18-复杂条件过滤和计算"><a href="#18-复杂条件过滤和计算" class="headerlink" title="18. 复杂条件过滤和计算"></a>18. 复杂条件过滤和计算</h2><h3 id="题目-8：统计所有产品每个季度的销售总额，只统计销售额超过1000的季度记录"><a href="#题目-8：统计所有产品每个季度的销售总额，只统计销售额超过1000的季度记录" class="headerlink" title="题目 8：统计所有产品每个季度的销售总额，只统计销售额超过1000的季度记录"></a>题目 8：统计所有产品每个季度的销售总额，只统计销售额超过1000的季度记录</h3><h4 id="建表语句-17"><a href="#建表语句-17" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sales (<br>    sale_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    product_id <span class="hljs-type">INT</span>,<br>    sale_date <span class="hljs-type">DATE</span>,<br>    sale_amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sales (product_id, sale_date, sale_amount) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-01-15&#x27;</span>, <span class="hljs-number">500.00</span>), <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-03-20&#x27;</span>, <span class="hljs-number">600.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-04-10&#x27;</span>, <span class="hljs-number">1200.00</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;2023-05-15&#x27;</span>, <span class="hljs-number">800.00</span>),<br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2023-07-25&#x27;</span>, <span class="hljs-number">900.00</span>);<br></code></pre></td></tr></table></figure><h4 id="查询语句-17"><a href="#查询语句-17" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_id,<br>       QUARTER(sale_date) <span class="hljs-keyword">AS</span> quarter,<br>       <span class="hljs-built_in">SUM</span>(sale_amount) <span class="hljs-keyword">AS</span> total_sales<br><span class="hljs-keyword">FROM</span> sales<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> product_id, quarter<br><span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>这些题目进一步考察了公共表表达式（CTE）、自关联、JSON 数据处理、动态窗口查询等技巧。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成器在Python和Java中的实践</title>
    <link href="/2024/10/30/Generator/"/>
    <url>/2024/10/30/Generator/</url>
    
    <content type="html"><![CDATA[<p>AI训练的代码中，包括很多教学代码，有很多Python的生成器实践（尤其李沐的课件），但是Web端写日常业务到是很少用到，就顺手查了一下资料，比较了一下各自的实现方式和原理。</p><h3 id="Python-中的生成器"><a href="#Python-中的生成器" class="headerlink" title="Python 中的生成器"></a>Python 中的生成器</h3><p>Python 生成器使用 <code>yield</code> 关键字和协程特性，能够在延迟计算的基础上节省内存并实现流式处理。生成器的实现基于协程（Coroutine）机制，使得函数可以暂停和恢复，从而可以在迭代过程中按需生成值。</p><hr><h4 id="常用写法"><a href="#常用写法" class="headerlink" title="常用写法"></a>常用写法</h4><h5 id="1-基于-yield-的生成器"><a href="#1-基于-yield-的生成器" class="headerlink" title="1. 基于 yield 的生成器"></a>1. 基于 <code>yield</code> 的生成器</h5><p><code>yield</code> 关键字将函数变成生成器，每次调用 <code>__next__()</code> 时都会恢复函数的执行，直到下一个 <code>yield</code> 表达式。</p><p><strong>代码示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci_generator</span>():<br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> a<br>        a, b = b, a + b<br><br><span class="hljs-comment"># 使用生成器</span><br>fib_gen = fibonacci_generator()<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib_gen))<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>按需生成</strong>：需要逐个生成数据的情况，如惰性计算和无限序列。</li><li><strong>流数据处理</strong>：处理大数据流和无限数据源，避免一次性加载全部数据。</li></ul><h5 id="2-生成器表达式"><a href="#2-生成器表达式" class="headerlink" title="2. 生成器表达式"></a>2. 生成器表达式</h5><p>生成器表达式类似列表推导式，但使用小括号 <code>()</code>。它不会一次性生成所有数据，而是按需生成。</p><p><strong>代码示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">gen_exp = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> gen_exp:<br>    <span class="hljs-built_in">print</span>(value)<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>轻量级生成</strong>：在简单生成和过滤中按需生成数据。</li><li><strong>内存节省</strong>：在不需要将数据全部存储为列表时使用生成器表达式节省内存。</li></ul><h5 id="3-异步生成器（Python-3-6-）"><a href="#3-异步生成器（Python-3-6-）" class="headerlink" title="3. 异步生成器（Python 3.6+）"></a>3. 异步生成器（Python 3.6+）</h5><p>异步生成器结合 <code>async</code> 和 <code>await</code> 实现异步协程，适合 I&#x2F;O 密集型任务，如数据流的异步处理。</p><p><strong>代码示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_counter</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 异步暂停</span><br>        <span class="hljs-keyword">yield</span> i<br><br><span class="hljs-comment"># 使用异步生成器</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> async_counter():<br>        <span class="hljs-built_in">print</span>(value)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>I&#x2F;O 密集型操作</strong>：如异步网络请求或文件读取。</li><li><strong>大规模异步并发</strong>：通过协程并发处理大量 I&#x2F;O 操作，提高效率。</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>协程与控制流</strong>：生成器使用协程机制控制函数的执行流程，<code>yield</code> 会保存当前执行状态，暂停函数运行，函数可以在下次调用时继续。</li><li><strong>异步生成器与异步调度</strong>：异步生成器使用 <code>await</code> 异步等待操作，使得在 I&#x2F;O 密集场景中可以在等待时处理其他任务，实现非阻塞操作。</li></ul><hr><h3 id="Java-中的生成器"><a href="#Java-中的生成器" class="headerlink" title="Java 中的生成器"></a>Java 中的生成器</h3><p>Java 没有原生的生成器支持，因此需要通过 <code>Iterator</code> 接口、<code>Stream</code>、<code>Spliterator</code> 等方法来实现按需生成和流式计算。Java 生成器的实现依赖接口设计，通过控制生成器函数的调用和延迟计算实现生成效果。</p><hr><h4 id="常用写法-1"><a href="#常用写法-1" class="headerlink" title="常用写法"></a>常用写法</h4><h5 id="1-使用-Iterator-接口"><a href="#1-使用-Iterator-接口" class="headerlink" title="1. 使用 Iterator 接口"></a>1. 使用 <code>Iterator</code> 接口</h5><p>通过实现 <code>Iterator</code> 接口的 <code>hasNext()</code> 和 <code>next()</code> 方法来控制数据生成。每次调用 <code>next()</code> 返回一个值，<code>hasNext()</code> 则控制生成终止条件。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 无限生成</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> current;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newNext</span> <span class="hljs-operator">=</span> current + next;<br>        current = next;<br>        next = newNext;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用生成器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FibonacciIterator</span> <span class="hljs-variable">fibonacci</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciIterator</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(fibonacci.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>自定义序列生成</strong>：通过手动控制生成逻辑实现自定义序列，如数学序列。</li><li><strong>无限序列</strong>：生成无限数据流（例如斐波那契数列）时有很大优势。</li></ul><h5 id="2-使用-Stream-API"><a href="#2-使用-Stream-API" class="headerlink" title="2. 使用 Stream API"></a>2. 使用 <code>Stream</code> API</h5><p>Java 8 引入了 <code>Stream</code>，支持 <code>Stream.generate()</code> 和 <code>Stream.iterate()</code> 实现惰性计算和流式生成。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamGeneratorExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream&lt;Integer&gt; fibonacci = Stream.iterate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            arr -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;arr[<span class="hljs-number">1</span>], arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>]&#125;)<br>            .map(arr -&gt; arr[<span class="hljs-number">0</span>]);<br>        <br>        fibonacci.limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>延迟计算</strong>：流式处理大型数据集，避免一次性加载，适合处理大数据。</li><li><strong>无限序列</strong>：通过 <code>Stream.generate()</code> 按需生成无限数据。</li></ul><h5 id="3-使用-Spliterator"><a href="#3-使用-Spliterator" class="headerlink" title="3. 使用 Spliterator"></a>3. 使用 <code>Spliterator</code></h5><p><code>Spliterator</code> 可以自定义生成器逻辑，支持并行分割，适用于大数据的并行处理。</p><p><strong>代码示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Spliterator;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfiniteSpliterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Spliterator</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAdvance</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> Integer&gt; action)</span> &#123;<br>        action.accept(value++);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Spliterator&lt;Integer&gt; <span class="hljs-title function_">trySplit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 不支持拆分</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">estimateSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Long.MAX_VALUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characteristics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ORDERED | NONNULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>并行处理</strong>：通过 <code>Spliterator</code> 分割并行处理大数据集。</li><li><strong>自定义流式生成</strong>：在需要精确控制生成逻辑和并行化时非常有用。</li></ul><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>接口设计</strong>：生成器通过 <code>Iterator</code> 接口实现 <code>next()</code> 方法按需生成数据，避免存储整个序列。</li><li><strong>流式处理与延迟计算</strong>：<code>Stream</code> API 提供了延迟计算特性，只有在真正需要数据时才会调用生成函数，避免一次性加载。</li><li><strong>并行生成</strong>：<code>Spliterator</code> 支持并行分割，可以将生成器分割成多个部分并行处理，适合大数据集的高效并行处理。</li></ul><hr><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th>特性</th><th>Python 生成器</th><th>Java 生成器</th></tr></thead><tbody><tr><td>实现方式</td><td>协程与 <code>yield</code>，支持异步生成器</td><td><code>Iterator</code> 接口、<code>Stream</code>、<code>Spliterator</code></td></tr><tr><td>延迟计算</td><td>是，通过 <code>yield</code> 实现</td><td>是，通过 <code>Stream</code> 或 <code>Iterator</code> 实现</td></tr><tr><td>内存管理</td><td>保留局部状态，避免整个序列加载</td><td>通过接口和流实现延迟计算，避免存储整个序列</td></tr><tr><td>并行和异步生成</td><td>支持异步生成器</td><td><code>Stream.parallel()</code> 或 <code>Spliterator</code> 支持并行</td></tr><tr><td>使用复杂度</td><td>简洁，生成器函数直接使用 <code>yield</code></td><td>依赖接口和流，需要手动控制生成逻辑</td></tr></tbody></table><p>Python 的生成器通过 <code>yield</code> 和协程提供轻量化、简便的延迟生成方式，而 Java 借助接口和流式 API 提供了灵活且适合并行计算的生成器实现。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python Java Generator 生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI在MySQL JDBC Connector 和 Flink Table Connector的实践</title>
    <link href="/2024/10/27/SPI/"/>
    <url>/2024/10/27/SPI/</url>
    
    <content type="html"><![CDATA[<p>最近在看Flink的时候，发现 Flink Table Connector也是使用了SPI技术的，结合很早之前MySQL JDBC Connector的使用，将两者的SPI实践记录下这篇文章。</p><h3 id="1-Java-SPI-技术概述"><a href="#1-Java-SPI-技术概述" class="headerlink" title="1. Java SPI 技术概述"></a>1. Java SPI 技术概述</h3><p>Java SPI（Service Provider Interface）是一种机制，允许模块化开发和服务提供者的动态加载。通过 SPI，可以在运行时发现和加载实现特定接口的服务提供者。SPI 的基本步骤包括：</p><ul><li><strong>定义服务接口</strong>：创建一个接口，描述服务的行为。</li><li><strong>实现服务提供者</strong>：为接口提供多个实现类。</li><li><strong>注册服务提供者</strong>：在 <code>META-INF/services</code> 目录下创建一个文件，文件名为接口的完全限定名，内容为服务提供者的完全限定名。</li><li><strong>加载服务</strong>：使用 <code>ServiceLoader</code> 加载服务实现。</li></ul><h3 id="2-实践案例"><a href="#2-实践案例" class="headerlink" title="2. 实践案例"></a>2. 实践案例</h3><h4 id="2-1-MySQL-JDBC-Connector"><a href="#2-1-MySQL-JDBC-Connector" class="headerlink" title="2.1 MySQL JDBC Connector"></a>2.1 MySQL JDBC Connector</h4><h5 id="1-定义服务接口"><a href="#1-定义服务接口" class="headerlink" title="1. 定义服务接口"></a>1. 定义服务接口</h5><p>创建一个数据库连接接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DatabaseConnector</span> &#123;<br>    Connection <span class="hljs-title function_">connect</span><span class="hljs-params">(String url, String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-实现服务提供者"><a href="#2-实现服务提供者" class="headerlink" title="2. 实现服务提供者"></a>2. 实现服务提供者</h5><p>实现 MySQL 和 PostgreSQL 的连接器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLConnector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DatabaseConnector</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">connect</span><span class="hljs-params">(String url, String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostgreSQLConnector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DatabaseConnector</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">connect</span><span class="hljs-params">(String url, String user, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, user, password);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-注册服务提供者"><a href="#3-注册服务提供者" class="headerlink" title="3. 注册服务提供者"></a>3. 注册服务提供者</h5><p>在 <code>META-INF/services/com.example.DatabaseConnector</code> 文件中列出实现类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MySQLConnector</span><br>com<span class="hljs-selector-class">.example</span>.PostgreSQLConnector<br></code></pre></td></tr></table></figure><h5 id="4-加载服务"><a href="#4-加载服务" class="headerlink" title="4. 加载服务"></a>4. 加载服务</h5><p>使用 <code>ServiceLoader</code> 动态加载数据库连接器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.ServiceLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ServiceLoader&lt;DatabaseConnector&gt; loader = ServiceLoader.load(DatabaseConnector.class);<br>        <span class="hljs-keyword">for</span> (DatabaseConnector connector : loader) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> connector.connect(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;Connected using: &quot;</span> + connector.getClass().getSimpleName());<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-Flink-Table-Connector"><a href="#2-2-Flink-Table-Connector" class="headerlink" title="2.2 Flink Table Connector"></a>2.2 Flink Table Connector</h4><h5 id="1-定义表源接口"><a href="#1-定义表源接口" class="headerlink" title="1. 定义表源接口"></a>1. 定义表源接口</h5><p>定义一个表源接口，用于读取数据流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableSource</span> &#123;<br>    DataStream&lt;Row&gt; <span class="hljs-title function_">getDataStream</span><span class="hljs-params">(StreamExecutionEnvironment env)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-实现表源提供者"><a href="#2-实现表源提供者" class="headerlink" title="2. 实现表源提供者"></a>2. 实现表源提供者</h5><p>实现 MySQL 和 PostgreSQL 的表源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLTableSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TableSource</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DataStream&lt;Row&gt; <span class="hljs-title function_">getDataStream</span><span class="hljs-params">(StreamExecutionEnvironment env)</span> &#123;<br>        <span class="hljs-comment">// 实现从 MySQL 数据库读取数据的逻辑</span><br>        <span class="hljs-keyword">return</span> env.fromElements(<span class="hljs-comment">/* 数据元素 */</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PostgreSQLTableSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TableSource</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DataStream&lt;Row&gt; <span class="hljs-title function_">getDataStream</span><span class="hljs-params">(StreamExecutionEnvironment env)</span> &#123;<br>        <span class="hljs-comment">// 实现从 PostgreSQL 数据库读取数据的逻辑</span><br>        <span class="hljs-keyword">return</span> env.fromElements(<span class="hljs-comment">/* 数据元素 */</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-注册表源"><a href="#3-注册表源" class="headerlink" title="3. 注册表源"></a>3. 注册表源</h5><p>在 <code>META-INF/services/com.example.TableSource</code> 文件中列出实现类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MySQLTableSource</span><br>com<span class="hljs-selector-class">.example</span>.PostgreSQLTableSource<br></code></pre></td></tr></table></figure><h5 id="4-加载表源"><a href="#4-加载表源" class="headerlink" title="4. 加载表源"></a>4. 加载表源</h5><p>使用 <code>ServiceLoader</code> 加载表源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;<br><span class="hljs-keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlinkClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();<br>        ServiceLoader&lt;TableSource&gt; loader = ServiceLoader.load(TableSource.class);<br>        <span class="hljs-keyword">for</span> (TableSource source : loader) &#123;<br>            DataStream&lt;Row&gt; stream = source.getDataStream(env);<br>            System.out.println(<span class="hljs-string">&quot;Loaded TableSource: &quot;</span> + source.getClass().getSimpleName());<br>            <span class="hljs-comment">// 进行数据流操作...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-桥接模式分析"><a href="#3-桥接模式分析" class="headerlink" title="3. 桥接模式分析"></a>3. 桥接模式分析</h3><p>桥接模式的核心思想是将抽象与实现分离，使它们能够独立变化。在 SPI 的上下文中，接口（如 <code>DatabaseConnector</code> 和 <code>TableSource</code>）代表了抽象部分，而具体的实现类（如 <code>MySQLConnector</code> 和 <code>PostgreSQLConnector</code>）则是实现部分。通过使用 SPI，我们能够在运行时选择不同的实现，而不需要修改客户端代码。</p><h4 id="桥接模式图示"><a href="#桥接模式图示" class="headerlink" title="桥接模式图示"></a>桥接模式图示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">+--------------------+          +--------------------+<br>|  DatabaseConnector |&lt;&gt;--------|  MySQLConnector    |<br>+--------------------+          +--------------------+<br>|                    |          |                    |<br>|  connect(url, user, password) |                    |<br>|                    |          +--------------------+<br>+--------------------+          <br>|                    |          +--------------------+<br>|  TableSource       |&lt;&gt;--------|  MySQLTableSource  |<br>+--------------------+          +--------------------+<br>|                    |          |                    |<br>|  getDataStream(env)|          |  getDataStream(env)|<br>|                    |          |                    |<br>+--------------------+          +--------------------+<br></code></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>结合 Java SPI 和桥接模式，我们实现了灵活的服务扩展，允许系统在运行时选择不同的数据库连接和数据源。通过抽象与实现的分离，用户可以方便地扩展系统功能，而无需修改现有代码。这种结构不仅提高了代码的可维护性，也增强了系统的灵活性和可扩展性。桥接模式的引入进一步提升了设计的清晰度，使得不同的实现可以独立演化，适应不断变化的需求。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SPI Flink MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发——管程模型</title>
    <link href="/2024/10/22/JavaMonitorI/"/>
    <url>/2024/10/22/JavaMonitorI/</url>
    
    <content type="html"><![CDATA[<p>最近在翻操作系统的资料的时候，看到信号量和管程，联想到JDK的实践，记录一下管程的一些思想。操作系统的话，南大蒋炎炎老师的课不错，有时间实践完，后续全面记录一下心得。</p><p>管程（Monitor）是一种用于同步并发程序中线程访问共享资源的机制，它提供了对临界区的自动管理，避免了线程之间的竞争条件。不同的管程模型在处理同步和线程唤醒方面有差异，主要有三种经典模型：<strong>Hasen 模型</strong>、<strong>Hoare 模型</strong> 和 <strong>Mesa 模型</strong>。</p><h3 id="1-Hasen-模型"><a href="#1-Hasen-模型" class="headerlink" title="1. Hasen 模型"></a>1. Hasen 模型</h3><p>Hasen 模型是一个最简单的管程模型，采用条件变量和锁机制来同步线程。这个模型的特点是，当线程 <code>wait</code> 时，它必须显式地释放锁，并进入等待队列。当被唤醒时，线程会被放回就绪队列，但不保证立即获得锁。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>线程在 <code>wait()</code> 时进入等待队列，释放管程锁。</li><li>线程被唤醒时，只进入就绪队列，不保证立即执行。</li></ul><h3 id="2-Hoare-模型"><a href="#2-Hoare-模型" class="headerlink" title="2. Hoare 模型"></a>2. Hoare 模型</h3><p>Hoare 模型由 Tony Hoare 提出，在管程的经典实现中，当某个线程执行 <code>wait()</code>，它会立即释放管程锁，并进入等待队列。而当条件满足时，线程被 <code>signal()</code> 唤醒并<strong>立即执行</strong>，而唤醒它的线程会让出管程锁。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li>被 <code>signal()</code> 唤醒的线程立即获得锁并开始执行。</li><li>唤醒它的线程会暂停，直到该被唤醒的线程执行完。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>假设有一个简单的生产者-消费者问题，Hoare 模型保证生产者和消费者直接交替执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HoareMonitor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (count == LIMIT) &#123;<br>            wait();<br>        &#125;<br>        count++;<br>        System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + count);<br>        notify();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            wait();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + count);<br>        count--;<br>        notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Hoare 模型中，当生产者生产或消费者消费之后，<code>notify()</code> 会唤醒对方线程，唤醒的线程会立刻开始执行。</p><h3 id="3-Mesa-模型"><a href="#3-Mesa-模型" class="headerlink" title="3. Mesa 模型"></a>3. Mesa 模型</h3><p>Mesa 模型是基于 Hoare 模型的扩展，是现代操作系统中更常见的管程实现模型。与 Hoare 模型不同，Mesa 模型的 <code>signal()</code> 只是将等待的线程放入就绪队列，被唤醒的线程并不会立刻执行，而是需要重新竞争锁，可能会导致其他线程先执行。</p><h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul><li>被 <code>signal()</code> 唤醒的线程进入就绪队列，必须再次竞争锁才能执行。</li><li>可能存在<strong>信号丢失</strong>问题：即线程被唤醒后，条件可能再次不满足。</li></ul><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MesaMonitor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (count == LIMIT) &#123;<br>            wait();<br>        &#125;<br>        count++;<br>        System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + count);<br>        notify();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            wait();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + count);<br>        count--;<br>        notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Mesa 模型中，当生产者或消费者通过 <code>notify()</code> 唤醒对方时，唤醒的线程并不会立刻执行，而是进入就绪队列，必须重新争夺锁。</p><h3 id="Java-对管程的实现"><a href="#Java-对管程的实现" class="headerlink" title="Java 对管程的实现"></a>Java 对管程的实现</h3><p>Java 提供了内置的 <code>synchronized</code> 关键字和 <code>Object</code> 类中的 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 方法来实现管程。Java 的管程更接近 <strong>Mesa 模型</strong>，因为 <code>notify()</code> 唤醒的线程不会立即执行，而是进入就绪队列，等待重新竞争锁。</p><h4 id="Java-synchronized-代码示例："><a href="#Java-synchronized-代码示例：" class="headerlink" title="Java synchronized 代码示例："></a>Java <code>synchronized</code> 代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (count == LIMIT) &#123;<br>            wait(); <span class="hljs-comment">// 释放锁并等待</span><br>        &#125;<br>        count++;<br>        System.out.println(<span class="hljs-string">&quot;Produced: &quot;</span> + count);<br>        notify(); <span class="hljs-comment">// 唤醒其他等待线程</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            wait();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Consumed: &quot;</span> + count);<br>        count--;<br>        notify();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SharedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedResource</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    resource.produce();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    resource.consume();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;);<br><br>        producer.start();<br>        consumer.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Hasen 模型</strong>：线程被唤醒后进入就绪队列，但不保证立即执行。</li><li><strong>Hoare 模型</strong>：被唤醒的线程立刻执行，并暂时让出当前线程。</li><li><strong>Mesa 模型</strong>（Java的实现）：线程被 <code>notify()</code> 唤醒后进入就绪队列，需要重新竞争锁。</li></ul><p>Java 的 <code>synchronized</code> 关键字和 <code>wait()</code>、<code>notify()</code> 实现了接近 Mesa 模型的管程机制，是通过对共享资源进行加锁和同步来避免线程竞争的典型方式。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发 管程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式文件系统——FastDFS和HDFS的一些比较</title>
    <link href="/2024/10/16/FastDFS&amp;HDFS/"/>
    <url>/2024/10/16/FastDFS&amp;HDFS/</url>
    
    <content type="html"><![CDATA[<p>最近发现很多开发很喜欢问分布式存储相关的问题，下面简单记录下目前我自己使用比较多的两种开源分布式文件系统。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>FastDFS 和 HDFS 是常用的分布式文件系统组件，它们各自具有不同的设计理念和应用场景。以下是两者的对比分析，以及简单的代码使用示例。</p><h3 id="1-FastDFS"><a href="#1-FastDFS" class="headerlink" title="1. FastDFS"></a>1. FastDFS</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>高效的文件上传和下载</strong>：FastDFS 适用于文件大小较小且需要高效上传&#x2F;下载的场景，尤其是需要文件的快速存储与访问（如图片、音视频等）。</li><li><strong>支持大规模分布式文件管理</strong>：它通过 Tracker 和 Storage 的分布式架构，提供文件的管理、分配和存储能力。</li><li><strong>扩展性好</strong>：FastDFS 易于扩展，通过增加节点可以水平扩展系统的存储容量。</li><li><strong>自动均衡存储负载</strong>：当新加入存储节点时，可以通过 Tracker 服务器实现负载均衡。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>不支持大文件拆分</strong>：适合处理中小型文件（&lt;500MB），对大文件的存储能力有限。</li><li><strong>功能单一</strong>：FastDFS 仅仅是一个文件存储系统，不具备 HDFS 的分布式计算能力（如 MapReduce 集成）。</li><li><strong>文件访问方式受限</strong>：文件通过 URL 访问，但并不支持 POSIX 文件系统标准。</li></ul><h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><ul><li>图片服务器、音视频文件服务器</li><li>短视频、图片库、日志文件等中小文件的分布式存储</li><li>静态资源 CDN 分发</li></ul><h4 id="FastDFS-示例代码："><a href="#FastDFS-示例代码：" class="headerlink" title="FastDFS 示例代码："></a>FastDFS 示例代码：</h4><p>首先需要安装 FastDFS 的客户端库 <code>fastdfs-client-java</code>，可以通过 Maven 依赖引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.csource<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.29-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>上传文件示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.csource.fastdfs.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastDFSDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 加载 FastDFS 配置文件</span><br>        ClientGlobal.init(<span class="hljs-string">&quot;fastdfs_client.conf&quot;</span>);<br><br>        <span class="hljs-comment">// 创建 TrackerClient 对象</span><br>        <span class="hljs-type">TrackerClient</span> <span class="hljs-variable">trackerClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrackerClient</span>();<br>        <span class="hljs-type">TrackerServer</span> <span class="hljs-variable">trackerServer</span> <span class="hljs-operator">=</span> trackerClient.getConnection();<br><br>        <span class="hljs-comment">// 获取 StorageServer 对象</span><br>        <span class="hljs-type">StorageServer</span> <span class="hljs-variable">storageServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 创建 StorageClient 对象</span><br>        <span class="hljs-type">StorageClient</span> <span class="hljs-variable">storageClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StorageClient</span>(trackerServer, storageServer);<br><br>        <span class="hljs-comment">// 上传文件</span><br>        String[] result = storageClient.upload_file(<span class="hljs-string">&quot;/path/to/local/file.jpg&quot;</span>, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Upload successful. Group: &quot;</span> + result[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;, Path: &quot;</span> + result[<span class="hljs-number">1</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Upload failed.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-HDFS（Hadoop-Distributed-File-System）"><a href="#2-HDFS（Hadoop-Distributed-File-System）" class="headerlink" title="2. HDFS（Hadoop Distributed File System）"></a>2. HDFS（Hadoop Distributed File System）</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>处理大文件能力强</strong>：HDFS 能够有效处理大文件，适合批量数据处理场景，特别是 100MB 以上的大文件。</li><li><strong>高容错性</strong>：数据会以副本的方式存储，默认配置下，每个文件块会存储三个副本，提高数据的可用性和容错性。</li><li><strong>与 Hadoop 生态系统的集成</strong>：HDFS 是 Hadoop 的核心组件，易于与其他 Hadoop 组件（如 MapReduce、Hive、Spark 等）集成，适用于分布式计算场景。</li><li><strong>线性扩展性</strong>：可以通过增加节点扩展存储和计算能力。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>不适合低延迟访问</strong>：HDFS 主要设计用于批量处理大文件，不适合实时低延迟的文件读写场景。</li><li><strong>小文件处理效率低</strong>：对于大量小文件（如 KB 级别的文件），HDFS 的处理效率较低。</li><li><strong>高写低读设计</strong>：HDFS 适合一次写入、多次读取的场景，对于频繁写入修改的场景不合适。</li></ul><h4 id="适用场景：-1"><a href="#适用场景：-1" class="headerlink" title="适用场景："></a>适用场景：</h4><ul><li>大规模数据存储，如日志数据、传感器数据、大型文件的分布式存储</li><li>数据分析和批处理，如数据仓库、数据湖</li><li>与 Hadoop、Spark 等大数据处理框架配合</li></ul><h4 id="HDFS-示例代码："><a href="#HDFS-示例代码：" class="headerlink" title="HDFS 示例代码："></a>HDFS 示例代码：</h4><p>首先需要引入 Hadoop 的相关依赖库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hadoop-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>上传文件到 HDFS：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HDFSDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// HDFS 配置</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">hdfsUri</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://localhost:9000&quot;</span>;<br><br>        <span class="hljs-comment">// 获取文件系统对象</span><br>        <span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(URI.create(hdfsUri), configuration);<br><br>        <span class="hljs-comment">// 本地文件路径</span><br>        <span class="hljs-type">Path</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/path/to/local/file.txt&quot;</span>);<br><br>        <span class="hljs-comment">// HDFS 目标路径</span><br>        <span class="hljs-type">Path</span> <span class="hljs-variable">hdfsPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(<span class="hljs-string">&quot;/user/hdfs/test/file.txt&quot;</span>);<br><br>        <span class="hljs-comment">// 上传文件</span><br>        fs.copyFromLocalFile(localPath, hdfsPath);<br><br>        System.out.println(<span class="hljs-string">&quot;File uploaded to HDFS successfully.&quot;</span>);<br>        <br>        <span class="hljs-comment">// 关闭文件系统</span><br>        fs.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-适用场景总结"><a href="#3-适用场景总结" class="headerlink" title="3. 适用场景总结"></a>3. 适用场景总结</h3><table><thead><tr><th>特性</th><th>FastDFS</th><th>HDFS</th></tr></thead><tbody><tr><td>文件大小</td><td>适合小文件（&lt;500MB）</td><td>适合大文件（&gt;100MB）</td></tr><tr><td>扩展性</td><td>水平扩展，增加存储节点</td><td>水平扩展，增加存储和计算节点</td></tr><tr><td>容错性</td><td>通过冗余和负载均衡实现容错</td><td>副本机制，副本数可配置</td></tr><tr><td>低延迟</td><td>适合低延迟文件访问（如图片、视频）</td><td>不适合低延迟访问，适合批处理</td></tr><tr><td>数据分析能力</td><td>无</td><td>与 Hadoop 生态系统紧密集成</td></tr><tr><td>应用场景</td><td>图片服务器、CDN 分发、音视频存储等</td><td>大数据存储、日志分析、数据仓库</td></tr></tbody></table><p>FastDFS 适合对小文件要求高效上传下载的场景，而 HDFS 更适合处理大规模数据存储和分析任务。根据需求选择合适的分布式文件系统能够更好地提升系统的性能和可扩展性。</p><h2 id="备份机制"><a href="#备份机制" class="headerlink" title="备份机制"></a>备份机制</h2><p>FastDFS 和 HDFS 在备份机制上的设计理念和实现方式有显著的区别，主要体现在数据副本管理、容错和可用性等方面。</p><h3 id="1-FastDFS-的备份机制"><a href="#1-FastDFS-的备份机制" class="headerlink" title="1. FastDFS 的备份机制"></a>1. <strong>FastDFS 的备份机制</strong></h3><h4 id="数据副本机制："><a href="#数据副本机制：" class="headerlink" title="数据副本机制："></a>数据副本机制：</h4><ul><li><strong>主从结构</strong>：FastDFS 的备份机制依赖于 <strong>主从同步机制</strong>。每个 Storage 节点可以配置成主节点和从节点，主节点负责文件的存储和管理，当主节点写入文件后，会将数据同步到配置的从节点，从节点承担数据的备份功能。</li><li><strong>文件存储副本</strong>：FastDFS 没有默认的多副本机制，数据的冗余是通过配置多台 Storage 服务器实现的。不同于 HDFS 的三副本机制，FastDFS 中的副本是通过手动配置的多台存储节点之间的同步来实现的，备份的频率和策略可以根据具体业务需求调整。</li></ul><h4 id="容错和恢复："><a href="#容错和恢复：" class="headerlink" title="容错和恢复："></a>容错和恢复：</h4><ul><li><strong>Tracker 负责调度</strong>：FastDFS 中的 Tracker 负责监控各个 Storage 节点的状态，一旦某个 Storage 节点失效，Tracker 会将请求路由到其他可用的节点，避免数据访问中断。</li><li><strong>主从切换</strong>：当主节点发生故障时，从节点可以快速接管数据的读写请求，实现数据的容灾和故障恢复。</li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>单一副本</strong>：默认没有多副本机制，副本的数量和节点配置依赖用户的手动设置。</li><li><strong>实时同步</strong>：主从节点间数据会进行实时同步，以保持数据一致性。</li><li><strong>局部容错性</strong>：由于没有全局统一的副本机制，容错能力相对较弱，依赖于手动设置的节点同步。</li></ul><h4 id="适用场景：-2"><a href="#适用场景：-2" class="headerlink" title="适用场景："></a>适用场景：</h4><ul><li>数据备份需求相对简单，文件存储不需要多副本冗余。</li><li>适合中小型企业的文件存储和访问需求，不需要复杂的大规模数据恢复和容灾。</li></ul><h3 id="2-HDFS-的备份机制"><a href="#2-HDFS-的备份机制" class="headerlink" title="2. HDFS 的备份机制"></a>2. <strong>HDFS 的备份机制</strong></h3><h4 id="数据副本机制：-1"><a href="#数据副本机制：-1" class="headerlink" title="数据副本机制："></a>数据副本机制：</h4><ul><li><strong>三副本机制</strong>：HDFS 默认采用 <strong>三副本</strong> 的策略。每个文件会被划分为若干数据块（block），并将每个数据块存储为三份副本，分布在不同的节点上，确保即使单个或多个节点发生故障，数据也能正常恢复。<ul><li>第一个副本会存储在写入数据的节点上。</li><li>第二个副本存储在同一机架（rack）中的其他节点。</li><li>第三个副本则会存储在不同机架上的其他节点，确保不同机架间的数据安全。</li></ul></li></ul><h4 id="容错和恢复：-1"><a href="#容错和恢复：-1" class="headerlink" title="容错和恢复："></a>容错和恢复：</h4><ul><li><strong>NameNode 管理副本</strong>：HDFS 的 <strong>NameNode</strong> 负责管理文件系统的元数据（包括副本的存储位置）。当某个 DataNode 发生故障时，NameNode 会检测到并触发副本的重新复制，确保副本数量保持在设定值（默认 3 副本）。</li><li><strong>自动副本恢复</strong>：如果某个节点上的副本丢失，HDFS 会自动在其他节点上重新复制数据，以恢复到设定的副本数量，确保系统的高可用性。</li><li><strong>副本调度和负载均衡</strong>：HDFS 会根据节点的存储情况进行副本的负载均衡，确保副本在集群中的均匀分布，避免存储节点过载或某些节点没有数据。</li></ul><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>高冗余性和容错性</strong>：HDFS 通过多副本机制（默认三副本）确保数据高可用性和容错能力，即使多个节点失效，仍能从其他副本中恢复数据。</li><li><strong>跨机架容灾</strong>：HDFS 在不同机架存储副本，避免因机架级别的故障（如电源或网络故障）导致数据丢失。</li><li><strong>自动副本恢复</strong>：HDFS 提供了自动的副本恢复机制，能够应对节点故障并确保数据可用性。</li></ul><h4 id="适用场景：-3"><a href="#适用场景：-3" class="headerlink" title="适用场景："></a>适用场景：</h4><ul><li>大规模分布式数据存储，特别是需要高度冗余的场景，如日志、传感器数据、视频存储等。</li><li>高容错、高可用要求的场景，特别是在分布式数据分析中（如 Hadoop、Spark）依赖的数据存储。</li></ul><h3 id="3-FastDFS-与-HDFS-备份机制对比"><a href="#3-FastDFS-与-HDFS-备份机制对比" class="headerlink" title="3. FastDFS 与 HDFS 备份机制对比"></a>3. <strong>FastDFS 与 HDFS 备份机制对比</strong></h3><table><thead><tr><th>特性</th><th>FastDFS</th><th>HDFS</th></tr></thead><tbody><tr><td><strong>备份机制</strong></td><td>主从结构，通过手动配置 Storage 节点实现备份</td><td>三副本机制，默认三个副本分布在不同节点和机架</td></tr><tr><td><strong>副本数量</strong></td><td>无默认副本机制，需要手动设置</td><td>默认 3 副本，数量可配置</td></tr><tr><td><strong>容错性</strong></td><td>依赖 Tracker 路由和主从切换，容错性相对较弱</td><td>自动副本管理和恢复，容错能力强</td></tr><tr><td><strong>数据恢复</strong></td><td>需要手动恢复或依赖从节点接管主节点的职责</td><td>自动副本恢复，NameNode 负责管理副本重建和均衡</td></tr><tr><td><strong>副本分布</strong></td><td>手动设置冗余节点，副本通常在本地局部网络中</td><td>跨机架存储副本，确保数据跨物理机架容灾</td></tr><tr><td><strong>适用场景</strong></td><td>适合中小型文件存储，备份需求简单的场景</td><td>适合大规模分布式存储，数据高冗余和高容错要求的场景</td></tr></tbody></table><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><ul><li><p><strong>FastDFS</strong> 的备份机制相对简单，通过主从结构手动配置副本，适合轻量级的文件存储场景。它的备份机制偏重实时同步和局部容灾，适合中小型文件的快速存储与分发，且备份需求不复杂。</p></li><li><p><strong>HDFS</strong> 的三副本机制则是为大规模分布式存储设计，提供高冗余性、自动恢复和跨机架容灾能力，适合对数据容错和可用性要求较高的大数据存储和处理场景。</p></li></ul><h2 id="文件处理能力"><a href="#文件处理能力" class="headerlink" title="文件处理能力"></a>文件处理能力</h2><p>FastDFS 和 HDFS 各自在处理文件时，由于架构设计的不同，导致 FastDFS 处理大文件的能力有限，而 HDFS 处理小文件的效率低。这两个问题的根本原因来自系统的设计理念和适用场景。以下分别解释两者在处理文件时的局限性。</p><h3 id="1-FastDFS-处理大文件能力有限的原因"><a href="#1-FastDFS-处理大文件能力有限的原因" class="headerlink" title="1. FastDFS 处理大文件能力有限的原因"></a>1. <strong>FastDFS 处理大文件能力有限的原因</strong></h3><h4 id="1-1-文件存储架构设计"><a href="#1-1-文件存储架构设计" class="headerlink" title="1.1 文件存储架构设计"></a>1.1 <strong>文件存储架构设计</strong></h4><p>FastDFS 的设计目标是为了高效处理大量中小型文件（如图片、音视频、日志文件等）。它采用的是文件切片、文件名索引的方式，通过 Tracker 和 Storage 节点快速定位和存储文件。对于中小型文件，FastDFS 可以很快地找到存储位置并完成数据上传和下载。</p><p>但是对于大文件（通常指超过 500MB 的文件），FastDFS 会遇到以下问题：</p><ul><li><strong>内存占用大</strong>：大文件上传时，需要占用较多的内存资源，FastDFS 的 Tracker 和 Storage 节点在传输数据时都需要处理完整文件，导致内存压力较大。</li><li><strong>文件传输效率低</strong>：FastDFS 采用的是点到点的文件传输模式，大文件的传输会占用较长的时间，影响其他并发请求的处理。尤其是在网络带宽有限的情况下，大文件的传输速度会显著下降。</li><li><strong>没有内置文件分块机制</strong>：与 HDFS 的大文件切分存储不同，FastDFS 默认不会对大文件进行拆分存储。大文件存储在单一节点上，当某个节点负载较大时，文件的上传和下载速度会明显受限。</li></ul><h4 id="1-2-负载均衡和容错机制"><a href="#1-2-负载均衡和容错机制" class="headerlink" title="1.2 负载均衡和容错机制"></a>1.2 <strong>负载均衡和容错机制</strong></h4><p>FastDFS 的负载均衡主要依靠 Tracker 节点，但对于大文件存储时，数据无法有效地在多个存储节点之间拆分和均衡。由于没有自动的分块机制，大文件只能存储在单个 Storage 节点上，难以充分利用集群的存储和带宽资源。</p><h4 id="1-3-适用场景"><a href="#1-3-适用场景" class="headerlink" title="1.3 适用场景"></a>1.3 <strong>适用场景</strong></h4><ul><li>FastDFS 适用于需要快速存储和分发大量中小型文件的场景，如图片、音频、视频片段等。对于大文件的处理效率不高，因此不适合处理超过数百 MB 的大文件。</li></ul><h3 id="2-HDFS-处理小文件效率低的原因"><a href="#2-HDFS-处理小文件效率低的原因" class="headerlink" title="2. HDFS 处理小文件效率低的原因"></a>2. <strong>HDFS 处理小文件效率低的原因</strong></h3><h4 id="2-1-文件系统元数据管理"><a href="#2-1-文件系统元数据管理" class="headerlink" title="2.1 文件系统元数据管理"></a>2.1 <strong>文件系统元数据管理</strong></h4><p>HDFS 的核心组件 <strong>NameNode</strong> 负责管理文件系统的元数据，包括文件块（block）的位置和文件名的映射关系。每个文件无论大小，都会被拆分成若干个块（默认块大小为 128MB），这些块会存储在 <strong>DataNode</strong> 上。</p><p>当文件非常小（如 KB 级别的文件）时，HDFS 需要为每个小文件维护独立的元数据条目，这会导致以下问题：</p><ul><li><strong>元数据开销大</strong>：每个文件的元数据（文件名、块位置、副本数量等）都需要存储在内存中。对于大量小文件，NameNode 的内存会被迅速占用，导致系统性能下降。而 HDFS 是依赖于元数据内存化管理的，这意味着处理大量小文件会带来严重的内存负担。</li><li><strong>小文件过多时 NameNode 容易成为瓶颈</strong>：由于 HDFS 的设计中，NameNode 是一个单点组件，当系统中存储的大量小文件占用过多元数据时，NameNode 的响应速度会变慢，最终成为系统的性能瓶颈。</li></ul><h4 id="2-2-文件块存储效率低"><a href="#2-2-文件块存储效率低" class="headerlink" title="2.2 文件块存储效率低"></a>2.2 <strong>文件块存储效率低</strong></h4><p>HDFS 的设计是为大文件优化的，每个文件被划分为块存储，默认每块大小为 128MB。当处理小文件时，每个文件可能只会占用一小部分块的空间。比如一个 1KB 的文件仍然需要占用整个块，这就导致了 <strong>存储空间的浪费</strong>，因为剩余的大部分块空间无法被其他文件利用。</p><h4 id="2-3-数据访问和传输开销"><a href="#2-3-数据访问和传输开销" class="headerlink" title="2.3 数据访问和传输开销"></a>2.3 <strong>数据访问和传输开销</strong></h4><p>由于 HDFS 偏重大文件的批处理模式，读取和传输小文件的效率相对较低。对于小文件的随机读写操作，HDFS 会经历与大文件相同的传输过程（副本管理、块校验、网络调度等），这导致每个小文件的读写操作都带来了不必要的额外开销。</p><h4 id="2-4-适用场景"><a href="#2-4-适用场景" class="headerlink" title="2.4 适用场景"></a>2.4 <strong>适用场景</strong></h4><ul><li>HDFS 适合处理大文件，特别是在分布式计算框架（如 Hadoop、Spark）中，适用于大数据存储和处理。小文件（数 KB 级别的文件）由于元数据管理和存储效率问题，并不适合在 HDFS 中存储。</li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. <strong>总结</strong></h3><table><thead><tr><th>特性</th><th>FastDFS 处理大文件能力有限的原因</th><th>HDFS 处理小文件效率低的原因</th></tr></thead><tbody><tr><td><strong>架构设计</strong></td><td>没有内置的大文件分块存储机制，只能依赖单节点存储</td><td>NameNode 管理元数据，存储大量小文件导致元数据负载</td></tr><tr><td><strong>内存和带宽占用</strong></td><td>大文件传输占用大量内存和带宽，影响系统性能</td><td>NameNode 内存占用过大，小文件占用过多元数据</td></tr><tr><td><strong>存储效率</strong></td><td>无法对大文件做分块，数据分布和负载均衡效果较差</td><td>每个小文件占用一个块，存储空间浪费严重</td></tr><tr><td><strong>适用场景</strong></td><td>中小型文件快速存储和访问，如图片、视频等</td><td>大规模数据存储和处理，如日志、大型数据集</td></tr></tbody></table><ul><li><strong>FastDFS</strong> 适合处理中小型文件，因为其设计目标是高效上传和下载分布式文件，但对于大文件，由于无法分块存储，内存占用和传输效率受限。</li><li><strong>HDFS</strong> 适合大文件的存储和处理，尤其是在大数据处理场景下，但由于元数据管理机制的限制，处理大量小文件时效率较低。</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式文件存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastDFS HDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TBB和Java并行库的一些对比</title>
    <link href="/2024/10/16/ParallelOfCXX&amp;Java/"/>
    <url>/2024/10/16/ParallelOfCXX&amp;Java/</url>
    
    <content type="html"><![CDATA[<p>最近看到TBB的一些资料，然后自然而然地想到了java的一些并行库，就记录了两者的一些简单的比对。</p><p>在 C++ 中，Intel TBB（Threading Building Blocks）提供了一套高效的并行编程模型，而在 Java 中，也有丰富的并发库供开发者使用，比如 <code>ForkJoinPool</code>、<code>CompletableFuture</code>、<code>Stream.parallel()</code> 等。通过对这两者的功能进行比对，你可以更好地理解在不同的场景下该如何选择合适的库。</p><h3 id="场景-1：并行循环处理"><a href="#场景-1：并行循环处理" class="headerlink" title="场景 1：并行循环处理"></a>场景 1：并行循环处理</h3><p>C++ TBB 和 Java 都可以通过并行循环提高计算密集型任务的效率。</p><h4 id="C-使用-TBB-并行执行循环"><a href="#C-使用-TBB-并行执行循环" class="headerlink" title="C++: 使用 TBB 并行执行循环"></a>C++: 使用 TBB 并行执行循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tbb/parallel_for.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>)</span></span>;<br><br>    tbb::<span class="hljs-built_in">parallel_for</span>(<span class="hljs-number">0</span>, (<span class="hljs-type">int</span>)data.<span class="hljs-built_in">size</span>(), [&amp;](<span class="hljs-type">int</span> i) &#123;<br>        data[i] += <span class="hljs-number">1</span>;  <span class="hljs-comment">// 并行处理</span><br>    &#125;);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Completed parallel loop with TBB&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Java-使用-Stream-parallel-执行并行循环"><a href="#Java-使用-Stream-parallel-执行并行循环" class="headerlink" title="Java: 使用 Stream.parallel() 执行并行循环"></a>Java: 使用 <code>Stream.parallel()</code> 执行并行循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelStreamExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            data.add(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        data.parallelStream().forEach(i -&gt; &#123;<br>            <span class="hljs-comment">// 并行处理</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>        &#125;);<br><br>        System.out.println(<span class="hljs-string">&quot;Completed parallel loop with Java Streams&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>功能比对：</strong></p><ul><li><strong>C++ TBB</strong> 提供更细粒度的并行控制，可以直接控制迭代范围和并行执行的任务调度。</li><li><strong>Java <code>Stream.parallel()</code></strong> 提供的是高级抽象，适合数据流的处理，易于使用，但在更复杂的任务调度上不如 TBB 灵活。</li></ul><h3 id="场景-2：任务分解与合并"><a href="#场景-2：任务分解与合并" class="headerlink" title="场景 2：任务分解与合并"></a>场景 2：任务分解与合并</h3><p>当任务可以递归分解时，TBB 和 Java <code>ForkJoinPool</code> 都可以用于任务的拆分和合并。</p><h4 id="C-使用-TBB-的任务分解"><a href="#C-使用-TBB-的任务分解" class="headerlink" title="C++: 使用 TBB 的任务分解"></a>C++: 使用 TBB 的任务分解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tbb/task_group.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recursiveTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br><br>    <span class="hljs-type">int</span> x, y;<br>    tbb::task_group tg;<br>    tg.<span class="hljs-built_in">run</span>([&amp;] &#123; x = <span class="hljs-built_in">recursiveTask</span>(n - <span class="hljs-number">1</span>); &#125;);  <span class="hljs-comment">// 并行子任务</span><br>    tg.<span class="hljs-built_in">run</span>([&amp;] &#123; y = <span class="hljs-built_in">recursiveTask</span>(n - <span class="hljs-number">2</span>); &#125;);  <span class="hljs-comment">// 并行子任务</span><br>    tg.<span class="hljs-built_in">wait</span>();<br><br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">recursiveTask</span>(<span class="hljs-number">10</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result from TBB: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Java-使用-ForkJoinPool-实现任务分解"><a href="#Java-使用-ForkJoinPool-实现任务分解" class="headerlink" title="Java: 使用 ForkJoinPool 实现任务分解"></a>Java: 使用 <code>ForkJoinPool</code> 实现任务分解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.RecursiveTask;<br><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTaskExample</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n;<br><br>        FibonacciTask(<span class="hljs-type">int</span> n) &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>            <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">1</span>);<br>            f1.fork(); <span class="hljs-comment">// 异步执行</span><br>            <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">return</span> f2.compute() + f1.join(); <span class="hljs-comment">// 合并结果</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">10</span>));<br>        System.out.println(<span class="hljs-string">&quot;Result from ForkJoinPool: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>功能比对：</strong></p><ul><li><strong>C++ TBB</strong> 中，<code>task_group</code> 可以更灵活地定义异步任务，并且能够控制每个任务的启动和合并。</li><li><strong>Java <code>ForkJoinPool</code></strong> 实现了类似的递归分解，<code>fork()</code> 和 <code>join()</code> 用于任务的分发和结果的合并。</li></ul><h3 id="场景-3：复杂任务依赖关系"><a href="#场景-3：复杂任务依赖关系" class="headerlink" title="场景 3：复杂任务依赖关系"></a>场景 3：复杂任务依赖关系</h3><p>当任务之间有依赖关系时，TBB 的任务调度和 Java 的 <code>CompletableFuture</code> 都能处理任务链的调度。</p><h4 id="C-使用-TBB-任务调度"><a href="#C-使用-TBB-任务调度" class="headerlink" title="C++: 使用 TBB 任务调度"></a>C++: 使用 TBB 任务调度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tbb/task_group.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">complexTask</span><span class="hljs-params">()</span> </span>&#123;<br>    tbb::task_group tg;<br>    tg.<span class="hljs-built_in">run</span>([]&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Task 1&quot;</span> &lt;&lt; std::endl; &#125;);  <span class="hljs-comment">// 并行任务1</span><br>    tg.<span class="hljs-built_in">run</span>([]&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Task 2&quot;</span> &lt;&lt; std::endl; &#125;);  <span class="hljs-comment">// 并行任务2</span><br>    tg.<span class="hljs-built_in">wait</span>();  <span class="hljs-comment">// 等待所有任务完成</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;All tasks completed&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">complexTask</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Java-使用-CompletableFuture-实现异步任务链"><a href="#Java-使用-CompletableFuture-实现异步任务链" class="headerlink" title="Java: 使用 CompletableFuture 实现异步任务链"></a>Java: 使用 <code>CompletableFuture</code> 实现异步任务链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CompletableFuture;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFutureExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Task 1&quot;</span>);<br>        &#125;);<br><br>        CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Task 2&quot;</span>);<br>        &#125;);<br><br>        CompletableFuture&lt;Void&gt; allTasks = CompletableFuture.allOf(task1, task2);<br>        allTasks.thenRun(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;All tasks completed&quot;</span>);<br>        &#125;).join();  <span class="hljs-comment">// 等待所有任务完成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>功能比对：</strong></p><ul><li><strong>C++ TBB</strong> 的任务调度更加底层，任务依赖的控制是通过显式调用实现的。</li><li><strong>Java <code>CompletableFuture</code></strong> 提供了更高抽象的异步任务链控制，可以轻松实现任务依赖、异常处理、任务合并等功能。</li></ul><h3 id="场景-4：并行数据聚合"><a href="#场景-4：并行数据聚合" class="headerlink" title="场景 4：并行数据聚合"></a>场景 4：并行数据聚合</h3><p>在需要对大量数据进行并行处理和聚合时，TBB 的 <code>parallel_reduce</code> 和 Java 的 <code>Collectors.toList()</code> 都能够高效处理。</p><h4 id="C-使用-TBB-parallel-reduce"><a href="#C-使用-TBB-parallel-reduce" class="headerlink" title="C++: 使用 TBB parallel_reduce"></a>C++: 使用 TBB <code>parallel_reduce</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tbb/parallel_reduce.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-type">int</span> sum = tbb::<span class="hljs-built_in">parallel_reduce</span>(<br>        tbb::<span class="hljs-built_in">blocked_range</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>()),<br>        <span class="hljs-number">0</span>,<br>        [&amp;](<span class="hljs-type">const</span> tbb::blocked_range&lt;<span class="hljs-type">size_t</span>&gt;&amp; r, <span class="hljs-type">int</span> init) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = r.<span class="hljs-built_in">begin</span>(); i != r.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>                init += data[i];  <span class="hljs-comment">// 局部和</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> init;<br>        &#125;,<br>        std::<span class="hljs-built_in">plus</span>&lt;<span class="hljs-type">int</span>&gt;()  <span class="hljs-comment">// 合并操作</span><br>    );<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum using TBB: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Java-使用-Stream-parallel-和-Collectors"><a href="#Java-使用-Stream-parallel-和-Collectors" class="headerlink" title="Java: 使用 Stream.parallel() 和 Collectors"></a>Java: 使用 <code>Stream.parallel()</code> 和 <code>Collectors</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelStreamSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Integer&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            data.add(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> data.parallelStream()<br>                      .reduce(<span class="hljs-number">0</span>, Integer::sum);  <span class="hljs-comment">// 并行聚合</span><br><br>        System.out.println(<span class="hljs-string">&quot;Sum using Java Streams: &quot;</span> + sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>功能比对：</strong></p><ul><li><strong>C++ TBB</strong> 提供了 <code>parallel_reduce</code>，允许在大数据集合上并行执行自定义的聚合逻辑。</li><li><strong>Java <code>Stream.parallel()</code></strong> 提供了流式处理，简化了并行计算和聚合，但在复杂聚合操作上不如 TBB 灵活。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>C++ TBB</strong> 提供了对并发任务的高度灵活控制，更适合复杂的并行任务和高性能场景。</li><li><strong>Java 并发库</strong> 提供了较高层的抽象，更易于使用，特别是对于常见的并行计算任务（如数据流、异步任务链等）。</li></ul><p>在选择并发工具时，可以根据任务复杂性、代码维护性以及性能要求来进行取舍。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD的一些随笔感想V</title>
    <link href="/2024/10/15/PartVOfDDD/"/>
    <url>/2024/10/15/PartVOfDDD/</url>
    
    <content type="html"><![CDATA[<p>紧接着上一篇，这篇主要结合事件驱动架构和 Saga 模式进一步探索。</p><p>事件驱动架构和Saga模式的结合能够充分利用两者的优点，提供了一种高效、松耦合且具有最终一致性的分布式事务处理方式。结合这些架构，可以在微服务系统中处理复杂的业务逻辑和跨服务事务，确保系统具有弹性、扩展性和可维护性。</p><h3 id="1-事件驱动架构与Saga模式的结合思路"><a href="#1-事件驱动架构与Saga模式的结合思路" class="headerlink" title="1. 事件驱动架构与Saga模式的结合思路"></a>1. <strong>事件驱动架构与Saga模式的结合思路</strong></h3><p>事件驱动架构通过发布和订阅事件来实现服务之间的异步通信，而Saga模式通过一系列独立的局部事务和补偿机制来保证分布式系统的最终一致性。将这两者结合起来时，Saga的每个局部事务执行完后可以通过发布事件通知下一个服务或进行补偿操作，达到分布式事务管理的目的。</p><h3 id="2-结合的优势"><a href="#2-结合的优势" class="headerlink" title="2. 结合的优势"></a>2. <strong>结合的优势</strong></h3><ul><li><strong>松耦合</strong>：通过事件驱动架构，Saga中的各个服务可以解耦，通过异步事件通知其他服务。服务只需监听感兴趣的事件，避免了服务之间的直接调用，减少了耦合。</li><li><strong>可扩展性</strong>：由于事件驱动架构天然支持扩展，结合Saga模式后，服务可以独立扩展，随着业务需求增长，不需要大规模修改现有系统。</li><li><strong>异步处理与弹性</strong>：事件驱动架构的异步特性可以让Saga中的事务不会因为单一服务的延迟而阻塞整个流程，增强系统的弹性和容错能力。</li><li><strong>最终一致性</strong>：Saga模式通过局部事务和补偿机制确保最终一致性，事件驱动架构则可以保证事务事件的可靠传递和处理，增强了事务的稳健性。</li></ul><h3 id="3-结合的工作流程"><a href="#3-结合的工作流程" class="headerlink" title="3. 结合的工作流程"></a>3. <strong>结合的工作流程</strong></h3><p>在结合事件驱动架构和Saga模式时，系统中每个微服务执行局部事务后都会发布事件。其他微服务通过监听这些事件来执行下一步的操作或补偿逻辑。如果某个局部事务失败，系统会通过补偿事件来撤销之前的操作。</p><h5 id="示例：订单处理流程（结合事件驱动和Saga模式）"><a href="#示例：订单处理流程（结合事件驱动和Saga模式）" class="headerlink" title="示例：订单处理流程（结合事件驱动和Saga模式）"></a><strong>示例：订单处理流程（结合事件驱动和Saga模式）</strong></h5><p>假设我们有一个电商系统，用户下单后涉及多个微服务：</p><ol><li>订单服务创建订单。</li><li>库存服务扣减库存。</li><li>支付服务扣减用户余额。</li></ol><p>如果任何一个步骤失败，系统需要回滚前面的操作，如恢复库存、退还余额。</p><p><strong>具体流程如下：</strong></p><ol><li><strong>订单服务</strong>：用户创建订单后，订单服务将订单存入数据库并发布“订单创建成功”的事件。</li><li><strong>库存服务</strong>：收到订单创建成功的事件后，库存服务扣减商品库存。如果库存扣减成功，库存服务发布“库存扣减成功”的事件；如果扣减失败，发布“订单创建失败”的补偿事件。</li><li><strong>支付服务</strong>：收到库存扣减成功的事件后，支付服务扣减用户账户余额。如果支付成功，发布“支付成功”的事件；如果支付失败，发布补偿事件。</li><li><strong>补偿逻辑</strong>：如果任何一个步骤失败，相关服务会通过补偿事件撤销之前的事务操作（如恢复库存、取消订单等）。</li></ol><h5 id="订单服务代码示例（发布事件）："><a href="#订单服务代码示例（发布事件）：" class="headerlink" title="订单服务代码示例（发布事件）："></a><strong>订单服务代码示例（发布事件）：</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, OrderCreatedEvent&gt; kafkaTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderRequest request)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(request.getUserId(), request.getProductId(), request.getQuantity());<br>        <span class="hljs-comment">// 保存订单</span><br>        orderRepository.save(order);<br><br>        <span class="hljs-comment">// 发布订单创建事件</span><br>        kafkaTemplate.send(<span class="hljs-string">&quot;OrderCreatedTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(order));<br>    &#125;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderCreationFailedTopic&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreationFailed</span><span class="hljs-params">(OrderCreationFailedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 取消订单</span><br>        orderRepository.deleteById(event.getOrderId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="库存服务代码示例（监听事件并发布补偿事件）："><a href="#库存服务代码示例（监听事件并发布补偿事件）：" class="headerlink" title="库存服务代码示例（监听事件并发布补偿事件）："></a><strong>库存服务代码示例（监听事件并发布补偿事件）：</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> InventoryRepository inventoryRepository;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderCreatedTopic&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreated</span><span class="hljs-params">(OrderCreatedEvent event)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 扣减库存</span><br>            inventoryRepository.deduct(event.getProductId(), event.getQuantity());<br><br>            <span class="hljs-comment">// 发布库存扣减成功事件</span><br>            kafkaTemplate.send(<span class="hljs-string">&quot;InventoryDeductedTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InventoryDeductedEvent</span>(event.getOrderId()));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 扣减库存失败，发布订单创建失败补偿事件</span><br>            kafkaTemplate.send(<span class="hljs-string">&quot;OrderCreationFailedTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreationFailedEvent</span>(event.getOrderId()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="支付服务代码示例（补偿逻辑）："><a href="#支付服务代码示例（补偿逻辑）：" class="headerlink" title="支付服务代码示例（补偿逻辑）："></a><strong>支付服务代码示例（补偿逻辑）：</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentRepository paymentRepository;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;InventoryDeductedTopic&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleInventoryDeducted</span><span class="hljs-params">(InventoryDeductedEvent event)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 扣减用户账户余额</span><br>            paymentRepository.deductBalance(event.getUserId(), event.getTotalAmount());<br><br>            <span class="hljs-comment">// 支付成功</span><br>            kafkaTemplate.send(<span class="hljs-string">&quot;PaymentSuccessTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaymentSuccessEvent</span>(event.getOrderId()));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 支付失败，发布补偿事件，通知恢复库存</span><br>            kafkaTemplate.send(<span class="hljs-string">&quot;OrderCreationFailedTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreationFailedEvent</span>(event.getOrderId()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderCreationFailedTopic&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreationFailed</span><span class="hljs-params">(OrderCreationFailedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 补偿逻辑，恢复用户余额</span><br>        paymentRepository.revertBalance(event.getUserId(), event.getTotalAmount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-结合架构中的补偿策略"><a href="#4-结合架构中的补偿策略" class="headerlink" title="4. 结合架构中的补偿策略"></a>4. <strong>结合架构中的补偿策略</strong></h3><p>补偿操作是Saga模式与事件驱动架构结合的核心，主要有以下几种常见的补偿策略：</p><h4 id="1-反向操作（Reversal）"><a href="#1-反向操作（Reversal）" class="headerlink" title="1. 反向操作（Reversal）"></a>1. <strong>反向操作（Reversal）</strong></h4><p>对于大多数事务，补偿逻辑可以简单地通过反向操作来撤销之前的成功操作。例如，库存扣减失败时恢复库存，用户支付失败时退还余额。</p><h4 id="2-幂等性（Idempotency）"><a href="#2-幂等性（Idempotency）" class="headerlink" title="2. 幂等性（Idempotency）"></a>2. <strong>幂等性（Idempotency）</strong></h4><p>在事件驱动架构中，事件可能会被重复发送或消费，因此补偿操作和事务操作都应该是幂等的，即同一事务或补偿操作多次执行的结果相同，不会产生额外影响。</p><h4 id="3-手动干预（Manual-Intervention）"><a href="#3-手动干预（Manual-Intervention）" class="headerlink" title="3. 手动干预（Manual Intervention）"></a>3. <strong>手动干预（Manual Intervention）</strong></h4><p>对于某些复杂的补偿场景，自动补偿可能不容易实现。这时可以设置监控和告警机制，让运维人员或业务人员手动处理补偿操作，确保事务一致性。</p><h3 id="5-最佳实践与落地建议"><a href="#5-最佳实践与落地建议" class="headerlink" title="5. 最佳实践与落地建议"></a>5. <strong>最佳实践与落地建议</strong></h3><p>在结合事件驱动架构和Saga模式的过程中，确保系统的可靠性和最终一致性是关键。以下是一些最佳实践和落地建议：</p><h4 id="1-消息可靠性"><a href="#1-消息可靠性" class="headerlink" title="1. 消息可靠性"></a>1. <strong>消息可靠性</strong></h4><p>确保事件驱动架构中消息的可靠传递，避免消息丢失或重复。可以使用消息中间件（如Kafka、RabbitMQ）提供的持久化机制和消息幂等性支持，保证事件不会被丢失或多次处理。</p><h4 id="2-事务一致性"><a href="#2-事务一致性" class="headerlink" title="2. 事务一致性"></a>2. <strong>事务一致性</strong></h4><p>通过Saga模式的局部事务和补偿机制保证系统的最终一致性。在每个服务中实现幂等性，确保重复的事件处理不会导致数据不一致。</p><h4 id="3-监控与可观察性"><a href="#3-监控与可观察性" class="headerlink" title="3. 监控与可观察性"></a>3. <strong>监控与可观察性</strong></h4><p>由于事件驱动架构和Saga模式中的事务是异步和分散的，监控和日志记录是至关重要的。需要跟踪每个事件的处理状态，监控事务的成功和失败，并设置告警机制及时发现和处理异常。</p><h4 id="4-超时管理"><a href="#4-超时管理" class="headerlink" title="4. 超时管理"></a>4. <strong>超时管理</strong></h4><p>在Saga模式中，某些局部事务可能会因为外部依赖导致延迟。通过设置超时机制和事件来处理这种场景，确保系统能够在事务超时时执行相应的补偿操作。</p><h4 id="5-流程模拟与测试"><a href="#5-流程模拟与测试" class="headerlink" title="5. 流程模拟与测试"></a>5. <strong>流程模拟与测试</strong></h4><p>由于结合事件驱动和Saga模式的系统涉及多个异步操作和补偿逻辑，进行模拟和集成测试非常重要。测试可以帮助发现流程中的潜在问题，确保系统在各种边界情况下的正确性。</p><h3 id="6-结合模式的应用场景"><a href="#6-结合模式的应用场景" class="headerlink" title="6. 结合模式的应用场景"></a>6. <strong>结合模式的应用场景</strong></h3><ul><li><strong>金融系统</strong>：处理资金转移时需要跨多个账户或银行的事务管理，Saga模式可以保证每个账户的操作是独立的，且失败时能够回滚资金。</li><li><strong>电子商务系统</strong>：如订单处理、库存管理、支付流程等，需要跨多个服务的操作可以通过事件驱动与Saga模式确保事务的一致性和恢复能力。</li><li><strong>物流系统</strong>：处理复杂的订单配送流程时，可以使用Saga模式跟踪每个配送步骤的状态，确保配送失败时可以退回原状态。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过将事件驱动架构与Saga模式结合，系统可以处理分布式环境下的复杂事务，同时保持高效、松耦合和弹性。事件驱动架构的异步通信特性和Saga模式的事务补偿机制使得系统能够在面对网络分区、延迟或服务故障时仍然保持一致性。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计 DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD的一些随笔感想IV</title>
    <link href="/2024/10/15/PartIVOfDDD/"/>
    <url>/2024/10/15/PartIVOfDDD/</url>
    
    <content type="html"><![CDATA[<p>紧接着上一篇，这篇主要讲解Saga模式。</p><p>Saga模式是一种用于处理分布式系统中长事务（Long-Running Transactions）的模式。它通过将一个大事务拆分成一系列小的局部事务（Local Transactions），每个局部事务都是独立提交的。如果某个局部事务失败，系统会通过补偿操作来回滚之前已成功的事务，确保系统达到最终一致性。</p><p>Saga模式主要用于解决分布式事务中的一致性问题，在微服务架构中尤为重要，因为微服务通常具有独立的数据存储，不适合使用传统的分布式事务机制。</p><h3 id="1-Saga模式的工作原理"><a href="#1-Saga模式的工作原理" class="headerlink" title="1. Saga模式的工作原理"></a>1. <strong>Saga模式的工作原理</strong></h3><p>Saga模式的核心思想是将一个大事务分解成多个局部事务。每个局部事务会对自己的数据进行修改，并在其完成时提交。每个局部事务之后，系统会检查整个流程是否可以继续进行。如果发生错误，系统执行补偿逻辑，撤销之前的局部事务。</p><p>Saga模式有两种主要实现方式：</p><ul><li><strong>编排式（Orchestration-based Saga）</strong></li><li><strong>协同式（Choreography-based Saga）</strong></li></ul><h3 id="2-Saga的两种实现方式"><a href="#2-Saga的两种实现方式" class="headerlink" title="2. Saga的两种实现方式"></a>2. <strong>Saga的两种实现方式</strong></h3><h4 id="1-编排式-Saga"><a href="#1-编排式-Saga" class="headerlink" title="1. 编排式 Saga"></a>1. <strong>编排式 Saga</strong></h4><p>编排式 Saga 中，有一个专门的服务（Saga Orchestrator）来负责管理整个 Saga 事务的执行流程。编排器负责调用各个局部事务，并根据事务的结果决定下一个步骤是继续还是执行补偿操作。</p><p><strong>优点：</strong></p><ul><li>事务的执行流程集中管理，清晰易懂。</li><li>控制逻辑可以集中到编排器中，便于维护和调试。</li></ul><p><strong>缺点：</strong></p><ul><li>编排器成为系统的中心，容易形成单点瓶颈。</li><li>编排器需要了解每个局部事务的执行细节，增加了耦合。</li></ul><h5 id="示例：电子商务系统中的订单处理"><a href="#示例：电子商务系统中的订单处理" class="headerlink" title="示例：电子商务系统中的订单处理"></a><strong>示例：电子商务系统中的订单处理</strong></h5><p>在一个电子商务系统中，当用户下单时，可能会涉及到以下几个操作：</p><ol><li>创建订单。</li><li>扣减库存。</li><li>扣除用户的账户余额。</li></ol><p>这些操作可以组成一个 Saga，任何一个步骤失败都需要撤销前面的操作。编排器负责按照顺序调用每个服务，并在必要时进行补偿。</p><p><strong>Saga 编排器的伪代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderSagaOrchestrator</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> InventoryService inventoryService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderRequest request)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Step 1: 创建订单</span><br>            <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderService.createOrder(request);<br><br>            <span class="hljs-comment">// Step 2: 扣减库存</span><br>            inventoryService.deductInventory(order.getProductId(), order.getQuantity());<br><br>            <span class="hljs-comment">// Step 3: 扣除用户账户余额</span><br>            paymentService.deductBalance(order.getUserId(), order.getTotalAmount());<br><br>            <span class="hljs-comment">// 如果所有步骤成功，订单处理完成</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 如果发生错误，执行补偿</span><br>            compensate(order);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compensate</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-comment">// 补偿逻辑，如恢复库存、退还余额等</span><br>        inventoryService.revertInventory(order.getProductId(), order.getQuantity());<br>        paymentService.revertBalance(order.getUserId(), order.getTotalAmount());<br>        orderService.cancelOrder(order.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-协同式-Saga"><a href="#2-协同式-Saga" class="headerlink" title="2. 协同式 Saga"></a>2. <strong>协同式 Saga</strong></h4><p>协同式 Saga 没有集中管理的编排器，所有服务通过监听事件来协作完成事务。每个服务执行自己的局部事务，并在成功后发布一个事件，通知下一个服务执行。如果某个服务失败，它也会发布一个补偿事件，撤销之前已完成的操作。</p><p><strong>优点：</strong></p><ul><li>服务之间更为松耦合，各自只关心自己应该处理的事务。</li><li>没有单点控制器，减少了瓶颈和耦合。</li></ul><p><strong>缺点：</strong></p><ul><li>事务执行流程分散，逻辑较为复杂，难以追踪。</li><li>难以调试，补偿逻辑分散在多个服务中，维护成本高。</li></ul><h5 id="示例：同样的订单处理-Saga（协同式实现）"><a href="#示例：同样的订单处理-Saga（协同式实现）" class="headerlink" title="示例：同样的订单处理 Saga（协同式实现）"></a><strong>示例：同样的订单处理 Saga（协同式实现）</strong></h5><p>在协同式实现中，每个服务在完成操作后发布事件，其他服务通过事件监听器进行相应处理。补偿操作同样由事件触发。</p><p><strong>服务发布事件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, OrderCreatedEvent&gt; kafkaTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(OrderRequest request)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(request.getUserId(), request.getProductId(), request.getQuantity());<br>        <span class="hljs-comment">// 保存订单</span><br>        orderRepository.save(order);<br><br>        <span class="hljs-comment">// 发布订单创建事件</span><br>        kafkaTemplate.send(<span class="hljs-string">&quot;OrderCreatedTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(order));<br>    &#125;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderCreationFailedTopic&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreationFailed</span><span class="hljs-params">(OrderCreationFailedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 取消订单</span><br>        orderRepository.deleteById(event.getOrderId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>库存服务监听事件并发布补偿事件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderCreatedTopic&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreated</span><span class="hljs-params">(OrderCreatedEvent event)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 扣减库存</span><br>            inventoryRepository.deduct(event.getProductId(), event.getQuantity());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 库存不足，发布补偿事件</span><br>            kafkaTemplate.send(<span class="hljs-string">&quot;OrderCreationFailedTopic&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreationFailedEvent</span>(event.getOrderId()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Saga模式的事务补偿"><a href="#3-Saga模式的事务补偿" class="headerlink" title="3. Saga模式的事务补偿"></a>3. <strong>Saga模式的事务补偿</strong></h3><p>Saga模式使用补偿事务来实现回滚。补偿事务的逻辑与正向事务的执行逻辑相反，它用于撤销之前已经提交的局部事务。例如，在订单处理过程中，如果库存扣减成功但支付失败，系统需要通过补偿事务将之前扣减的库存恢复。</p><p><strong>补偿事务的关键点：</strong></p><ul><li>补偿事务应该是幂等的，以确保多次执行不会产生副作用。</li><li>补偿事务的执行顺序应与正向事务的执行顺序相反。</li></ul><h3 id="4-Saga模式的优缺点"><a href="#4-Saga模式的优缺点" class="headerlink" title="4. Saga模式的优缺点"></a>4. <strong>Saga模式的优缺点</strong></h3><p><strong>优点：</strong></p><ul><li><strong>去中心化</strong>：尤其在协同式 Saga 中，各个服务之间松耦合，便于扩展和维护。</li><li><strong>最终一致性</strong>：通过异步事件和补偿机制，系统可以在不同服务之间达到最终一致性，适合分布式系统中的长事务。</li><li><strong>高可用性</strong>：Saga模式避免了长时间锁住资源的问题，服务可以在局部事务中独立处理，提升了系统的可用性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性高</strong>：补偿逻辑的设计和实现增加了系统的复杂性，尤其是协同式 Saga 中，服务之间的事件交互难以跟踪和调试。</li><li><strong>不适合强一致性场景</strong>：Saga模式适合最终一致性的场景，但对于需要强一致性的系统，如金融领域的结算系统，Saga可能不适用。</li></ul><h3 id="5-Saga模式的实际应用场景"><a href="#5-Saga模式的实际应用场景" class="headerlink" title="5. Saga模式的实际应用场景"></a>5. <strong>Saga模式的实际应用场景</strong></h3><p>Saga模式特别适合以下场景：</p><ul><li><strong>电商系统中的订单处理</strong>：订单创建、库存扣减、支付等流程可以使用 Saga 保证最终一致性。</li><li><strong>航班和酒店预订系统</strong>：预订多个资源时，可以将每个资源的预订作为局部事务，确保在某个资源预订失败时能进行补偿。</li><li><strong>银行转账系统</strong>：当资金转移涉及多个账户或银行时，Saga 模式可以确保转账操作的最终一致性。</li></ul><h3 id="6-项目中的-Saga-模式落地建议"><a href="#6-项目中的-Saga-模式落地建议" class="headerlink" title="6. 项目中的 Saga 模式落地建议"></a>6. <strong>项目中的 Saga 模式落地建议</strong></h3><p>在项目中落地 Saga 模式时，应考虑以下几点：</p><ul><li><strong>事务补偿机制的设计</strong>：每个局部事务都需要有对应的补偿事务，并确保补偿逻辑的幂等性。</li><li><strong>事件驱动与消息中间件的选择</strong>：选择合适的消息中间件（如 Kafka、RabbitMQ）来传递事务事件，确保事件的可靠传递与处理。</li><li><strong>监控与可观察性</strong>：在实际系统中，Saga 事务往往跨越多个服务，因此需要良好的监控机制来跟踪每个局部事务的状态，并及时发现和处理错误。</li><li><strong>错误处理与超时管理</strong>：在 Saga 模式下，某些局部事务可能会因为长时间未能完成而超时。因此，系统需要设计机制来检测并处理超时事务。</li></ul><p>总结来说，Saga模式提供了一种灵活的方式来处理分布式系统中的事务管理问题，通过补偿逻辑实现最终一致性。根据业务需求选择合适的实现方式（编排式或协同式），并设计健壮的补偿机制，能够有效提高系统的稳定性和可扩展性。</p><p>接下来，我会继续讨论如何结合事件驱动架构和 Saga 模式，进一步提高微服务系统的弹性与扩展性。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计 DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD的一些随笔感想III</title>
    <link href="/2024/10/15/PartIIIOfDDD/"/>
    <url>/2024/10/15/PartIIIOfDDD/</url>
    
    <content type="html"><![CDATA[<p>紧接着上一篇，这篇主要讲解事件驱动架构。</p><p>事件驱动架构（Event-Driven Architecture, EDA）是一种以事件为中心的系统架构模式，常用于构建松耦合、可扩展且响应迅速的系统。事件驱动架构尤其适合分布式系统和微服务架构，因为它能够在服务之间建立异步通信，避免服务之间的强耦合，同时保证系统的扩展性和可维护性。</p><h3 id="1-事件驱动架构的核心概念"><a href="#1-事件驱动架构的核心概念" class="headerlink" title="1. 事件驱动架构的核心概念"></a>1. <strong>事件驱动架构的核心概念</strong></h3><p>在事件驱动架构中，系统内的操作和状态变化都通过事件进行表达。以下是事件驱动架构的几个核心概念：</p><ul><li><strong>事件（Event）</strong>：系统中发生的某种行为或状态变化。事件可以是某个实体状态的变化（如订单创建、商品库存减少）或系统的外部输入。</li><li><strong>事件发布者（Event Publisher）</strong>：负责在系统中生成并发布事件的组件或服务。</li><li><strong>事件消费者（Event Consumer）</strong>：监听并响应事件的组件或服务。事件消费者可以是一个或多个。</li><li><strong>事件处理器（Event Handler）</strong>：在消费者接收到事件后执行相应业务逻辑的代码。</li><li><strong>消息队列或事件总线</strong>：负责传递事件，确保事件可以被消费者异步接收到。常用的消息中间件包括Kafka、RabbitMQ、ActiveMQ等。</li></ul><h3 id="2-事件驱动架构的优点"><a href="#2-事件驱动架构的优点" class="headerlink" title="2. 事件驱动架构的优点"></a>2. <strong>事件驱动架构的优点</strong></h3><ul><li><strong>松耦合</strong>：事件驱动的方式解耦了服务之间的依赖，服务只需发布或订阅感兴趣的事件，而不需要直接调用其他服务的接口。</li><li><strong>可扩展性</strong>：通过添加新的事件消费者，系统可以轻松扩展，无需修改现有的发布者。</li><li><strong>异步通信</strong>：事件驱动架构支持异步操作，避免了服务之间的同步调用导致的阻塞和性能瓶颈。</li><li><strong>弹性</strong>：系统的不同部分可以独立扩展和恢复，提升了整个系统的弹性。</li></ul><h3 id="3-事件驱动架构的实现模式"><a href="#3-事件驱动架构的实现模式" class="headerlink" title="3. 事件驱动架构的实现模式"></a>3. <strong>事件驱动架构的实现模式</strong></h3><p>事件驱动架构有两种主要的模式：<strong>事件通知（Event Notification）</strong>和<strong>事件溯源（Event Sourcing）</strong>。</p><h4 id="1-事件通知（Event-Notification）模式"><a href="#1-事件通知（Event-Notification）模式" class="headerlink" title="1. 事件通知（Event Notification）模式"></a>1. <strong>事件通知（Event Notification）模式</strong></h4><p>在事件通知模式中，系统的某个部分在发生状态变化时发布事件，其他服务通过订阅这些事件来获知变化。这个模式常用于微服务架构中，其中每个服务处理自身的数据并通过事件通知其他服务。</p><h5 id="示例：订单服务与库存服务"><a href="#示例：订单服务与库存服务" class="headerlink" title="示例：订单服务与库存服务"></a><strong>示例：订单服务与库存服务</strong></h5><p>在一个电商系统中，当订单服务创建订单后，它会发布一个“订单创建”（OrderCreated）事件，库存服务可以监听这个事件并减少相应商品的库存。</p><p><strong>代码示例：</strong></p><p><strong>订单服务发布事件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, OrderCreatedEvent&gt; kafkaTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-comment">// 保存订单到数据库</span><br>        orderRepository.save(order);<br><br>        <span class="hljs-comment">// 发布订单创建事件</span><br>        <span class="hljs-type">OrderCreatedEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(order.getId(), order.getProductId(), order.getQuantity());<br>        kafkaTemplate.send(<span class="hljs-string">&quot;OrderCreatedTopic&quot;</span>, event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>库存服务监听事件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> InventoryRepository inventoryRepository;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderCreatedTopic&quot;, groupId = &quot;inventory-group&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderCreated</span><span class="hljs-params">(OrderCreatedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 减少库存</span><br>        <span class="hljs-type">Inventory</span> <span class="hljs-variable">inventory</span> <span class="hljs-operator">=</span> inventoryRepository.findByProductId(event.getProductId());<br>        inventory.reduceStock(event.getQuantity());<br>        inventoryRepository.save(inventory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-事件溯源（Event-Sourcing）模式"><a href="#2-事件溯源（Event-Sourcing）模式" class="headerlink" title="2. 事件溯源（Event Sourcing）模式"></a>2. <strong>事件溯源（Event Sourcing）模式</strong></h4><p>事件溯源是更复杂的一种模式，它将系统中所有的状态变化都记录为一系列事件。系统的当前状态不是直接存储的，而是通过事件重放（replay）来重建的。事件溯源提供了系统完整的历史记录，可以追溯到任何时候的状态。</p><p><strong>事件溯源的优点：</strong></p><ul><li><strong>完全审计跟踪</strong>：系统的每次状态变化都有对应的事件记录，可以回放事件来重建历史状态。</li><li><strong>事件重放</strong>：如果系统的某个部分出现故障，可以通过重新播放事件来恢复数据。</li><li><strong>并行处理</strong>：因为事件是不可变的，可以并行处理多个事件。</li></ul><h5 id="示例：银行账户服务"><a href="#示例：银行账户服务" class="headerlink" title="示例：银行账户服务"></a><strong>示例：银行账户服务</strong></h5><p>假设我们有一个银行账户服务，所有的存款、取款操作都被记录为事件。当我们需要获取账户余额时，可以通过重放这些事件来计算余额。</p><p><strong>事件类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountEvent</span> &#123;<br>    <span class="hljs-keyword">private</span> Long accountId;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br>    <span class="hljs-keyword">private</span> EventType eventType;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountEvent</span><span class="hljs-params">(Long accountId, BigDecimal amount, EventType eventType)</span> &#123;<br>        <span class="hljs-built_in">this</span>.accountId = accountId;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>        <span class="hljs-built_in">this</span>.eventType = eventType;<br>    &#125;<br><br>    <span class="hljs-comment">// getter 和 setter 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>账户聚合根：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> BigDecimal balance;<br><br>    <span class="hljs-comment">// 重放事件来恢复账户状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(AccountEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (event.getEventType() == EventType.DEPOSIT) &#123;<br>            <span class="hljs-built_in">this</span>.balance = <span class="hljs-built_in">this</span>.balance.add(event.getAmount());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.getEventType() == EventType.WITHDRAW) &#123;<br>            <span class="hljs-built_in">this</span>.balance = <span class="hljs-built_in">this</span>.balance.subtract(event.getAmount());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件存储库：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventStore</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;AccountEvent&gt; events = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 保存事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveEvent</span><span class="hljs-params">(AccountEvent event)</span> &#123;<br>        events.add(event);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过事件重建账户状态</span><br>    <span class="hljs-keyword">public</span> Account <span class="hljs-title function_">rebuildAccount</span><span class="hljs-params">(Long accountId)</span> &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>        <span class="hljs-keyword">for</span> (AccountEvent event : events) &#123;<br>            <span class="hljs-keyword">if</span> (event.getAccountId().equals(accountId)) &#123;<br>                account.apply(event);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> account;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-事件驱动架构的最佳实践"><a href="#4-事件驱动架构的最佳实践" class="headerlink" title="4. 事件驱动架构的最佳实践"></a>4. <strong>事件驱动架构的最佳实践</strong></h3><ol><li><p><strong>幂等性处理</strong>：事件驱动架构中的事件可能会重复消费，因此事件处理器应设计为幂等的，即处理同一事件多次不会产生不同的结果。</p></li><li><p><strong>事件顺序</strong>：某些场景下，事件的顺序非常重要。为了保证顺序一致性，可以使用消息队列中提供的顺序保证机制，或在事件中加入版本号。</p></li><li><p><strong>事件版本管理</strong>：在长期的系统演化中，事件结构可能会发生变化。因此，事件应当具有版本号，以确保事件处理器能够兼容处理不同版本的事件。</p></li><li><p><strong>事件持久化</strong>：为了防止事件丢失，所有的事件应当持久化存储，通常使用消息队列（如Kafka）或事件存储系统。</p></li><li><p><strong>可观察性</strong>：引入事件驱动架构后，系统中的事件流和事件依赖变得更为复杂，因此必须有良好的监控和日志系统来跟踪事件的流转。</p></li></ol><h3 id="5-项目落地中的实践"><a href="#5-项目落地中的实践" class="headerlink" title="5. 项目落地中的实践"></a>5. <strong>项目落地中的实践</strong></h3><p>在项目中应用事件驱动架构时，需要根据具体业务需求选择合适的模式。通常，<strong>事件通知</strong>模式适合系统的解耦和扩展，<strong>事件溯源</strong>模式适合有强审计需求或复杂数据重建需求的系统。以下是落地时需要考虑的几点：</p><ul><li><p><strong>选择合适的消息中间件</strong>：常用的有Kafka、RabbitMQ等，它们能够支持高吞吐量、持久化存储和高可用性。</p></li><li><p><strong>事务一致性</strong>：处理跨多个聚合或微服务的事务时，事件驱动架构通常不使用传统的分布式事务，而是通过事件溯源、Saga模式等确保最终一致性。</p></li><li><p><strong>高可用性与容错</strong>：系统中每个事件消费者应能够处理消息丢失、重复消费、网络分区等情况，确保事件不会丢失且不会被错误处理。</p></li><li><p><strong>业务与技术的结合</strong>：事件驱动架构要求开发团队和业务团队密切配合，识别关键的业务事件，并确保事件模型与业务逻辑紧密贴合。</p></li></ul><p>在之后的讨论中，我会进一步介绍Saga模式、事件流中的错误处理以及如何在复杂系统中有效地实施事件驱动架构。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计 DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD的一些随笔感想II</title>
    <link href="/2024/10/15/PartIIOfDDD/"/>
    <url>/2024/10/15/PartIIOfDDD/</url>
    
    <content type="html"><![CDATA[<p>紧接着上一篇，这篇主要讲解聚合。</p><p>聚合（Aggregate）是领域驱动设计（DDD）中的核心概念之一，它用于组织和管理业务模型中的复杂性。聚合在DDD中起着重要作用，帮助我们以分层的方式处理业务逻辑，同时保证数据的一致性和完整性。聚合的设计和管理对于保证微服务架构中的稳定性至关重要。</p><h3 id="1-聚合的定义"><a href="#1-聚合的定义" class="headerlink" title="1. 聚合的定义"></a>1. <strong>聚合的定义</strong></h3><p>聚合是领域中的一组相关对象，它们一起处理某个业务场景中的操作。聚合具有以下特征：</p><ul><li><strong>聚合根（Aggregate Root）</strong>：聚合中的一个主对象，它是外界访问聚合的唯一入口，其他对象通过聚合根进行管理。</li><li><strong>边界</strong>：聚合将多个实体和值对象组合成一个逻辑单元，它的边界定义了哪些对象属于这个聚合。</li><li><strong>事务一致性</strong>：在聚合内，所有的操作应当保证数据的一致性。聚合内的修改通常在同一个事务中进行，确保数据的原子性。</li></ul><h4 id="聚合的设计原则"><a href="#聚合的设计原则" class="headerlink" title="聚合的设计原则"></a><strong>聚合的设计原则</strong></h4><ul><li><strong>封装一致性</strong>：聚合应该封装业务逻辑，并负责维护内部状态的一致性。外部不能直接修改聚合中的对象，而必须通过聚合根进行操作。</li><li><strong>小聚合原则</strong>：尽可能保持聚合小而简单。一个聚合包含过多的对象会导致系统复杂度和事务管理的难度增加。</li><li><strong>跨聚合的协作通过事件</strong>：如果多个聚合需要协作完成某个任务，通常通过领域事件进行沟通，而不是直接调用。</li></ul><h3 id="2-聚合的示例"><a href="#2-聚合的示例" class="headerlink" title="2. 聚合的示例"></a>2. <strong>聚合的示例</strong></h3><p>假设我们在一个电子商务系统中有一个订单（Order）聚合。一个订单可能包含多个订单项（OrderItem），同时订单会受到库存的约束和客户支付信息的影响。</p><h4 id="1-聚合内的对象："><a href="#1-聚合内的对象：" class="headerlink" title="1. 聚合内的对象："></a><strong>1. 聚合内的对象：</strong></h4><ul><li><strong>订单（Order）</strong>：聚合根，代表整个订单的主要业务逻辑。</li><li><strong>订单项（OrderItem）</strong>：订单的组成部分，是订单内的子实体。</li><li><strong>值对象（Value Object）</strong>：如价格、商品数量等，不单独存在，没有独立的生命周期。</li></ul><h4 id="2-订单聚合示例代码："><a href="#2-订单聚合示例代码：" class="headerlink" title="2. 订单聚合示例代码："></a><strong>2. 订单聚合示例代码：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> Long customerId;<br>    <span class="hljs-keyword">private</span> OrderStatus status;<br><br>    <span class="hljs-meta">@OneToMany(cascade = CascadeType.ALL)</span><br>    <span class="hljs-keyword">private</span> List&lt;OrderItem&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(Long customerId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.customerId = customerId;<br>        <span class="hljs-built_in">this</span>.status = OrderStatus.CREATED;<br>    &#125;<br><br>    <span class="hljs-comment">// 聚合根负责所有操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addItem</span><span class="hljs-params">(Long productId, <span class="hljs-type">int</span> quantity, Money price)</span> &#123;<br>        <span class="hljs-type">OrderItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderItem</span>(productId, quantity, price);<br>        <span class="hljs-built_in">this</span>.items.add(item);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">placeOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (items.isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;订单项不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.status = OrderStatus.PLACED;<br>        <span class="hljs-comment">// 发布领域事件，通知其他聚合</span><br>        DomainEventPublisher.publish(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPlacedEvent</span>(<span class="hljs-built_in">this</span>.id));<br>    &#125;<br><br>    <span class="hljs-comment">// getter 和 setter 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="订单项（OrderItem）："><a href="#订单项（OrderItem）：" class="headerlink" title="订单项（OrderItem）："></a><strong>订单项（OrderItem）：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderItem</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> Long productId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> quantity;<br>    <span class="hljs-keyword">private</span> Money price;<br><br>    <span class="hljs-comment">// 值对象封装业务逻辑，如价格计算</span><br>    <span class="hljs-keyword">public</span> Money <span class="hljs-title function_">calculateTotalPrice</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> price.multiply(quantity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderItem</span><span class="hljs-params">(Long productId, <span class="hljs-type">int</span> quantity, Money price)</span> &#123;<br>        <span class="hljs-built_in">this</span>.productId = productId;<br>        <span class="hljs-built_in">this</span>.quantity = quantity;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-comment">// getter 和 setter 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="值对象（Money）："><a href="#值对象（Money）：" class="headerlink" title="值对象（Money）："></a><strong>值对象（Money）：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Embeddable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Money</span> &#123;<br>    <span class="hljs-keyword">private</span> BigDecimal amount;<br>    <span class="hljs-keyword">private</span> String currency;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Money</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Money</span><span class="hljs-params">(BigDecimal amount, String currency)</span> &#123;<br>        <span class="hljs-built_in">this</span>.amount = amount;<br>        <span class="hljs-built_in">this</span>.currency = currency;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Money <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> multiplier)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(<span class="hljs-built_in">this</span>.amount.multiply(BigDecimal.valueOf(multiplier)), <span class="hljs-built_in">this</span>.currency);<br>    &#125;<br><br>    <span class="hljs-comment">// getter 和 setter 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-聚合的操作"><a href="#3-聚合的操作" class="headerlink" title="3. 聚合的操作"></a>3. <strong>聚合的操作</strong></h3><p>聚合内的所有操作应该通过聚合根来进行。订单中的子实体（OrderItem）不能独立存在，必须通过订单聚合根来管理。这样可以保证订单的整体一致性。</p><h4 id="添加订单项的操作流程："><a href="#添加订单项的操作流程：" class="headerlink" title="添加订单项的操作流程："></a><strong>添加订单项的操作流程：</strong></h4><ol><li>外部系统通过订单聚合根调用<code>addItem()</code>方法来添加新的订单项。</li><li>聚合根负责验证订单项的有效性，并将其添加到订单中。</li><li>其他任何修改（如取消订单、修改订单项等）也必须通过订单聚合根来进行。</li></ol><h3 id="4-跨聚合的通信"><a href="#4-跨聚合的通信" class="headerlink" title="4. 跨聚合的通信"></a>4. <strong>跨聚合的通信</strong></h3><p>在实际系统中，往往会有多个聚合相互协作。通常我们采用事件驱动的方式进行聚合间的通信。比如，当订单被创建后，库存聚合可能需要更新库存数量，这个操作通常通过领域事件来实现。</p><h4 id="事件通信的代码示例："><a href="#事件通信的代码示例：" class="headerlink" title="事件通信的代码示例："></a><strong>事件通信的代码示例：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPlacedEvent</span> &#123;<br>    <span class="hljs-keyword">private</span> Long orderId;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderPlacedEvent</span><span class="hljs-params">(Long orderId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderId = orderId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getOrderId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> orderId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>库存服务可以监听<code>OrderPlacedEvent</code>事件并作出相应的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderPlacedEvent&quot;, groupId = &quot;inventory-group&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderPlaced</span><span class="hljs-params">(OrderPlacedEvent event)</span> &#123;<br>        <span class="hljs-comment">// 处理库存逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;Received OrderPlacedEvent for Order ID: &quot;</span> + event.getOrderId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-聚合设计的落地建议"><a href="#5-聚合设计的落地建议" class="headerlink" title="5. 聚合设计的落地建议"></a>5. <strong>聚合设计的落地建议</strong></h3><p>在实际项目中，聚合设计需要特别注意以下几点：</p><ul><li><p><strong>聚合大小控制</strong>：尽量保持聚合的简洁，避免一个聚合根管理过多子实体。如果聚合太大，可能会导致事务长时间持锁，影响性能。</p></li><li><p><strong>读写分离</strong>：对于需要高性能读操作的场景，可以考虑使用CQRS（命令查询责任分离）模式，读写操作分开进行，聚合负责写操作，查询则通过专门的查询模型完成。</p></li><li><p><strong>事务管理</strong>：在聚合内部，尽量使用单一事务来处理操作，保证数据的一致性。对于跨聚合的事务，可以考虑使用Saga模式或者事件驱动架构来确保最终一致性。</p></li><li><p><strong>事件驱动架构</strong>：当聚合之间需要协作时，使用事件来进行通信，这样可以解耦聚合间的依赖，同时增强系统的扩展性。</p></li></ul><p>通过以上方式，聚合能够很好地帮助我们管理复杂业务逻辑，并在微服务架构中有效落地DDD的设计思想。在接下来的篇章中，我可以进一步介绍事件驱动架构、Saga模式等内容，以及如何将这些概念结合起来落地到实际项目中。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计 DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD的一些随笔感想I</title>
    <link href="/2024/10/15/PartIOfDDD/"/>
    <url>/2024/10/15/PartIOfDDD/</url>
    
    <content type="html"><![CDATA[<p>最近经常遇到开发谈起DDD的架构设计思想，我翻阅了一些资料后，自己总结了一下。</p><p>领域驱动设计（DDD, Domain-Driven Design）是一种设计复杂软件系统的方法，通过将业务领域的知识和技术紧密结合，来指导微服务架构的设计。DDD尤其适合处理复杂、多变的业务系统，在微服务架构中应用也非常广泛。以下是DDD的核心思想、如何在微服务设计中应用，以及代码示例和实际落地的考虑。</p><h3 id="1-DDD的核心思想"><a href="#1-DDD的核心思想" class="headerlink" title="1. DDD的核心思想"></a>1. <strong>DDD的核心思想</strong></h3><p>DDD强调对业务领域的深入理解，目的是通过模型化业务概念，帮助技术团队与业务团队达成共识。DDD的核心思想包括以下几个方面：</p><ul><li><strong>核心领域和限界上下文（Bounded Context）</strong>：识别出系统中的多个业务领域，并为每个领域划定边界，确保领域之间相互隔离，避免混淆。</li><li><strong>领域模型（Domain Model）</strong>：是对业务逻辑和规则的抽象表示，领域模型包含了实体（Entity）、值对象（Value Object）、聚合（Aggregate）、领域服务（Domain Service）等概念。</li><li><strong>领域事件（Domain Event）</strong>：系统中发生的重要业务事件，这些事件可以触发其他模块或服务的反应。</li><li><strong>聚合根（Aggregate Root）</strong>：聚合中的一个实体，它负责维护聚合的完整性，对外暴露统一的接口。</li><li><strong>仓储（Repository）</strong>：负责管理聚合根的持久化。</li></ul><h3 id="2-微服务设计中的DDD"><a href="#2-微服务设计中的DDD" class="headerlink" title="2. 微服务设计中的DDD"></a>2. <strong>微服务设计中的DDD</strong></h3><p>在微服务架构中，DDD的核心思想可以帮助将系统拆分为多个独立的服务，每个服务专注于一个限界上下文。每个服务只处理自己领域内的业务逻辑，服务之间通过API或事件进行交互。具体的微服务设计步骤包括：</p><ul><li><p><strong>识别领域和限界上下文</strong>：通过与业务方的讨论，识别出系统中不同的领域。例如，电商系统可能包含“用户管理”、“订单处理”、“库存管理”等限界上下文。</p></li><li><p><strong>划分微服务边界</strong>：根据限界上下文划分微服务，每个微服务负责处理一个限界上下文内的业务逻辑。边界清晰的服务可以减少服务之间的耦合。</p></li><li><p><strong>领域模型设计</strong>：为每个微服务设计其领域模型，包括实体、值对象、聚合根和领域服务。确保业务逻辑封装在聚合内部，保持聚合的一致性。</p></li><li><p><strong>领域事件与服务通信</strong>：微服务之间通过领域事件进行通信，而非直接调用彼此的内部逻辑。事件驱动架构（Event-Driven Architecture）有助于保持服务的解耦。</p></li></ul><h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. <strong>代码示例</strong></h3><p>假设我们有一个订单服务（Order Service）和库存服务（Inventory Service），两者通过领域事件进行交互。我们可以使用SpringBoot、Spring Data JPA和Kafka来实现。</p><h4 id="订单服务："><a href="#订单服务：" class="headerlink" title="订单服务："></a><strong>订单服务：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> Long productId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> quantity;<br>    <span class="hljs-keyword">private</span> OrderStatus status;<br><br>    <span class="hljs-comment">// 构造方法、getter和setter省略</span><br><br>    <span class="hljs-comment">// 领域逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">placeOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> availableStock)</span> &#123;<br>        <span class="hljs-keyword">if</span> (availableStock &lt; <span class="hljs-built_in">this</span>.quantity) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.status = OrderStatus.PLACED;<br>        <span class="hljs-comment">// 生成领域事件</span><br>        DomainEventPublisher.publish(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPlacedEvent</span>(<span class="hljs-built_in">this</span>.id, <span class="hljs-built_in">this</span>.productId, <span class="hljs-built_in">this</span>.quantity));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="库存服务（监听领域事件）："><a href="#库存服务（监听领域事件）：" class="headerlink" title="库存服务（监听领域事件）："></a><strong>库存服务（监听领域事件）：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> InventoryRepository inventoryRepository;<br><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;OrderPlacedEvent&quot;, groupId = &quot;inventory-group&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrderPlaced</span><span class="hljs-params">(OrderPlacedEvent event)</span> &#123;<br>        <span class="hljs-type">Inventory</span> <span class="hljs-variable">inventory</span> <span class="hljs-operator">=</span> inventoryRepository.findByProductId(event.getProductId());<br>        inventory.reduceStock(event.getQuantity());<br>        inventoryRepository.save(inventory);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inventory</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-keyword">private</span> Long productId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> availableStock;<br><br>    <span class="hljs-comment">// 构造方法、getter和setter省略</span><br><br>    <span class="hljs-comment">// 领域逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduceStock</span><span class="hljs-params">(<span class="hljs-type">int</span> quantity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.availableStock &lt; quantity) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.availableStock -= quantity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件发布器："><a href="#事件发布器：" class="headerlink" title="事件发布器："></a><strong>事件发布器：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DomainEventPublisher</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationEventPublisher publisher;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DomainEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher publisher)</span> &#123;<br>        DomainEventPublisher.publisher = publisher;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publish</span><span class="hljs-params">(Object event)</span> &#123;<br>        publisher.publishEvent(event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="领域事件类："><a href="#领域事件类：" class="headerlink" title="领域事件类："></a><strong>领域事件类：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderPlacedEvent</span> &#123;<br>    <span class="hljs-keyword">private</span> Long orderId;<br>    <span class="hljs-keyword">private</span> Long productId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> quantity;<br><br>    <span class="hljs-comment">// 构造方法、getter和setter省略</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-项目落地的实际考虑"><a href="#4-项目落地的实际考虑" class="headerlink" title="4. 项目落地的实际考虑"></a>4. <strong>项目落地的实际考虑</strong></h3><p>在实际项目中应用DDD和微服务时，需要考虑以下几点：</p><ul><li><p><strong>团队协作</strong>：DDD的关键是与业务团队保持密切沟通。每个微服务的领域模型应与业务需求紧密贴合，避免偏离业务现实。</p></li><li><p><strong>技术选型</strong>：选择合适的技术栈来实现微服务架构。通常，SpringBoot、Spring Cloud、Kafka、Docker、Kubernetes等都是微服务常用的技术栈。</p></li><li><p><strong>性能和可扩展性</strong>：微服务架构中，服务间的通信（如事件传递）可能带来延迟，因此需要考虑消息队列、缓存和负载均衡等技术。</p></li><li><p><strong>数据一致性</strong>：在微服务架构中，数据一致性是一个挑战。通常，我们可以使用事件溯源（Event Sourcing）、Saga模式等来解决分布式事务问题。</p></li><li><p><strong>监控与故障恢复</strong>：在生产环境中，微服务需要有完善的监控、日志和报警机制，以快速发现和处理故障。</p></li></ul><p>在之后的几篇中，我会更深入地讲解每个部分，包括聚合、事件驱动架构、Saga模式等高级主题，帮助你逐步落地到实际项目中。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计 DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雪花算法及其问题</title>
    <link href="/2024/10/15/Snowflake/"/>
    <url>/2024/10/15/Snowflake/</url>
    
    <content type="html"><![CDATA[<p>最近看书的发现一些有意思的问题，记录几篇博客。</p><h4 id="时钟回拨问题"><a href="#时钟回拨问题" class="headerlink" title="时钟回拨问题"></a>时钟回拨问题</h4><p>雪花算法（Snowflake Algorithm）是一种分布式ID生成算法，通常使用时间戳作为ID的一部分来保证唯一性。然而，时钟回拨问题会导致时间戳出现错误，进而产生重复的ID或ID顺序错乱。这通常发生在系统时间被手动修改、网络时钟同步失败等情况下。为了避免时钟回拨导致的问题，有几种常见的解决方案：</p><ol><li><strong>抛出异常或阻塞等待</strong></li></ol><p>当检测到时钟回拨时，停止生成ID，等待系统时钟恢复到正确的时间。这是一种简单而直接的解决方法。</p><p><strong>实现方法：</strong></p><ul><li>检测到当前系统时间小于上一次生成ID时的时间戳（即发生时钟回拨）时，抛出异常或让线程进入阻塞状态，直到系统时间超过上次时间戳。</li></ul><p><strong>优点：</strong></p><ul><li>简单直接，能保证ID唯一性。</li></ul><p><strong>缺点：</strong></p><ul><li>如果时钟回拨时间较长，ID生成会被阻塞，系统可能无法正常提供服务。</li></ul><p><strong>适用场景：</strong></p><ul><li>时钟回拨的情况较为罕见且时钟修正时间短时。</li></ul><hr><ol start="2"><li><strong>启用自旋等待</strong></li></ol><p>自旋等待的方式是当检测到时钟回拨时，系统会快速检查当前时间，直到时钟恢复到正确的时间后再生成ID。</p><p><strong>实现方法：</strong></p><ul><li>当检测到时钟回拨时，进入自旋等待，不生成ID，直到系统时钟恢复正常（即当前时间大于上次生成ID的时间戳）。</li></ul><p><strong>优点：</strong></p><ul><li>能快速响应回拨的恢复，保证ID顺序正确。</li></ul><p><strong>缺点：</strong></p><ul><li>自旋可能消耗CPU资源，适用于时钟回拨时间非常短的情况。</li></ul><p><strong>适用场景：</strong></p><ul><li>实时性要求高，且希望避免服务阻塞的情况。</li></ul><hr><ol start="3"><li><strong>引入逻辑时钟（Logical Clock）</strong></li></ol><p>在实际的系统时间之外，维护一个逻辑时钟。当检测到时钟回拨时，使用逻辑时钟代替物理时钟来生成ID。</p><p><strong>实现方法：</strong></p><ul><li>每次生成ID时，记录上次生成的时间戳。如果下次生成ID时发现系统时间发生了回拨，逻辑时钟比物理时间慢，那么使用逻辑时钟+1作为当前时间生成ID，直到物理时钟追上逻辑时钟。</li></ul><p><strong>优点：</strong></p><ul><li>避免了系统因为时钟回拨而出现的阻塞或重复ID问题。</li><li>不需要等待物理时钟恢复。</li></ul><p><strong>缺点：</strong></p><ul><li>逻辑时钟仅能短时间内有效，长时间依赖逻辑时钟可能导致顺序性问题。</li></ul><p><strong>适用场景：</strong></p><ul><li>时钟回拨频繁发生的场景，且生成ID的实时性要求高。</li></ul><hr><ol start="4"><li><strong>重置工作机器ID（Machine ID）或序列号</strong></li></ol><p>如果时钟回拨时间较短，可以通过调整机器ID或序列号来区分在同一物理时间下生成的不同ID。</p><p><strong>实现方法：</strong></p><ul><li>检测到时钟回拨时，临时调整机器ID或序列号，生成ID时不直接依赖于时间戳，从而避免因回拨产生冲突的ID。</li></ul><p><strong>优点：</strong></p><ul><li>不依赖于等待系统时间恢复，能立即生成ID。</li></ul><p><strong>缺点：</strong></p><ul><li>增加了实现复杂度，且可能需要保证机器ID足够多来支持这种做法。</li></ul><p><strong>适用场景：</strong></p><ul><li>时钟回拨较频繁的环境，且系统有足够的资源来分配不同的机器ID。</li></ul><hr><ol start="5"><li><strong>检测并修正系统时间</strong></li></ol><p>利用外部的时间同步机制来确保系统时钟不会大幅度回拨。例如，使用NTP（Network Time Protocol）或 PTP（Precision Time Protocol）来校正系统时钟，尽量避免时钟回拨。</p><p><strong>优点：</strong></p><ul><li>从源头上避免时钟回拨的问题，保证ID生成的唯一性和顺序性。</li></ul><p><strong>缺点：</strong></p><ul><li>系统时间同步可能会增加复杂度，特别是在分布式环境中。</li></ul><p><strong>适用场景：</strong></p><ul><li>分布式系统中需要高度可靠和精确的时间同步。</li></ul><hr><ol start="6"><li><strong>使用较新的ID生成算法</strong></li></ol><p>可以考虑使用支持时钟回拨的ID生成算法，例如 <a href="https://github.com/sony/sonyflake">Sonyflake</a> 或 <a href="https://tools.ietf.org/html/rfc4122">UUID</a>。这些算法设计时考虑了时间回拨等问题。</p><p><strong>优点：</strong></p><ul><li>避免了手动处理时钟回拨问题，提供更健壮的ID生成机制。</li></ul><p><strong>缺点：</strong></p><ul><li>可能需要引入新的库或改变现有系统的ID生成逻辑。</li></ul><p><strong>适用场景：</strong></p><ul><li>新项目或愿意在现有系统中引入新技术的场景。</li></ul><hr><p><strong>总结</strong></p><p>应对雪花算法中时钟回拨问题的解决方案需要结合实际系统的性能要求和容错能力。对于时钟回拨较为罕见的场景，可以采用抛出异常或自旋等待的简单方案；而在高并发、时钟回拨较频繁的环境下，推荐引入逻辑时钟或重置机器ID等更复杂的机制。</p><h4 id="SonyflakeID生成算法的原理"><a href="#SonyflakeID生成算法的原理" class="headerlink" title="SonyflakeID生成算法的原理"></a>SonyflakeID生成算法的原理</h4><p>Sonyflake 是一种分布式唯一 ID 生成算法，类似于 Twitter 的 Snowflake 算法，但有一些改进和优化。特别是，它对时钟回拨问题有更好的处理机制。Sonyflake 的设计目的是在分布式系统中生成 64 位的全局唯一 ID，并提供高性能和较好的容错能力。接下来我会介绍 Sonyflake 的工作原理，尤其是它如何支持时钟回拨。</p><p><strong>Sonyflake 的 ID 组成</strong></p><p>Sonyflake 生成的 64 位 ID 由以下几部分组成：</p><ul><li><strong>39 位时间戳</strong>：相对于自定义时间纪元（epoch）的增量时间戳。</li><li><strong>16 位序列号</strong>：同一毫秒内生成的序列号，用来解决高并发的场景。</li><li><strong>8 位机器ID</strong>：标识生成 ID 的实例（机器），确保分布式环境下不同机器生成的 ID 是唯一的。</li></ul><p><strong>Sonyflake 的 ID 结构：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------------------------------------------------------+</span><br><span class="hljs-section">| 39位时间戳 | 8位机器ID | 16位序列号 |</span><br><span class="hljs-section">+---------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p><strong>时钟回拨的处理机制</strong></p><p>在传统的 Snowflake 算法中，如果检测到时钟回拨（当前时间小于上次生成 ID 时的时间戳），通常会导致以下几种问题：</p><ul><li>ID 重复：时间戳回退后可能生成相同的时间戳，导致生成相同的 ID。</li><li>阻塞：Snowflake 可能会等待时间回到正确位置再继续生成 ID，导致服务中断。</li></ul><p>Sonyflake 针对这些问题做了以下优化：</p><ol><li><strong>容忍一定范围的时钟回拨</strong></li></ol><p>Sonyflake 在设计上允许一定的时钟回拨。具体来说，Sonyflake 在生成每个 ID 时都会记录当前的时间戳，并在生成下一次 ID 时检查当前时间是否回拨。如果发现时钟回拨的幅度在一个可接受的范围内（如 1 秒以内），Sonyflake 并不会抛出异常或者停止服务，而是继续使用当前时间戳生成 ID。</p><p>这种容忍机制的核心是通过<strong>序列号</strong>来保证 ID 的唯一性。即使时间戳回拨，Sonyflake 仍然可以通过增加序列号来生成不重复的 ID。也就是说，当时钟回拨发生时，Sonyflake 不会依赖时间戳的顺序性，而是依赖序列号来保证 ID 的唯一性。</p><ol start="2"><li><strong>回拨保护机制</strong></li></ol><p>Sonyflake 在记录上一次生成 ID 的时间戳时，还会引入一个“回拨保护”的逻辑。如果检测到系统时钟回拨幅度较大（超过容忍范围），Sonyflake 会继续使用上一次的时间戳，并通过调整序列号来生成新 ID。这种做法确保不会因为时间回拨而生成重复的 ID。</p><p>这种机制与逻辑时钟的思想有些类似，即当物理时钟出现问题时，Sonyflake 依然可以依赖系统中的逻辑顺序生成唯一的 ID。</p><ol start="3"><li><strong>灵活的时间源设计</strong></li></ol><p>Sonyflake 的时间戳精度为毫秒级，但它支持通过自定义时间源来增加灵活性。例如，用户可以指定一个初始时间（纪元）作为 ID 生成的起点。这样，当系统时钟发生大规模回拨时，只要保持该自定义时间不变，ID 生成过程就不会受到较大影响。</p><p><strong>Sonyflake 的优点</strong></p><ol><li><strong>时钟回拨容忍</strong>：Sonyflake 能够容忍一定范围的时钟回拨，避免因为回拨导致 ID 重复或服务中断。</li><li><strong>更长的时间可用性</strong>：39 位的时间戳相对于 Snowflake 的 41 位时间戳减少了一些，但仍然能够支持数十年的时间跨度（大约 174 年）。在合理设置初始纪元的情况下，可以确保较长时间的 ID 唯一性。</li><li><strong>高效且分布式</strong>：Sonyflake 提供了 8 位的机器 ID 和 16 位的序列号，能在分布式环境下处理高并发请求。</li></ol><p><strong>Sonyflake vs Snowflake</strong></p><ul><li><strong>时钟回拨的处理</strong>：Snowflake 对时钟回拨非常敏感，一旦检测到回拨，通常会导致生成 ID 失败，或者需要引入逻辑时钟等复杂处理。而 Sonyflake 则允许一定范围的回拨，通过序列号避免回拨问题。</li><li><strong>时间精度</strong>：Snowflake 使用 41 位时间戳，而 Sonyflake 使用 39 位时间戳，时间跨度有所减少，但对大多数场景来说已经足够。</li><li><strong>生成效率</strong>：两者的效率都非常高，能够处理每秒数百万个请求。在高并发和分布式系统中表现良好。</li></ul><p><strong>总结</strong></p><p>Sonyflake 在设计上通过容忍一定的时钟回拨范围，并通过使用序列号和逻辑时钟的机制，避免了时钟回拨引发的 ID 重复问题。这种改进使其在分布式系统中更加健壮，尤其是在时钟不可靠或同步不稳定的情况下表现良好。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>雪花算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建和文件删除备份</title>
    <link href="/2024/10/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E5%A4%87%E4%BB%BD/"/>
    <url>/2024/10/14/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo博客搭建和文件删除备份"><a href="#hexo博客搭建和文件删除备份" class="headerlink" title="hexo博客搭建和文件删除备份"></a>hexo博客搭建和文件删除备份</h1><h3 id="痛苦的事件"><a href="#痛苦的事件" class="headerlink" title="痛苦的事件"></a>痛苦的事件</h3><p>​    最近有些时间，更新一下荒废的博客，没想到hexo本地的博客源文件之前被误删除了。查了网上很多资料，还写了脚本爬网页转md，都没有办法解决，最后还是乖乖的复制html然后转到md，耗时两三天，终于解决了问题。不过，还是丢失了几篇文章，还有一些文章的格式短时间内，也没办法恢复了。</p><p>​    最新的博客，更新了主题，没有继续使用next，使用了fluid主题，更加好看，没有那么呆板；另外，还添加了utterances评论功能，目前看比之前的discuz好用一些，就是加载慢。</p><p>​这里hexo搭建很简单，网上已经说了很多了，简单安装npm和hexo后，初始化就好了。评论插件的话，utterances的配置有些特殊，我的主题是fluid，在utterances<a href="https://utteranc.es/">官网</a>，点击配置好自己的博客仓库后，将生成的配置，一一复制到fluid的config文件里面，配置文件有个comment部分，格式都写好了（当然评论要打开即配置true），把复制的配置写进去，重新hexo deploy就好，打开网页后，稍等几秒钟，目前utterances的加载还是挺慢的。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>​为了防止再次出现博客文件丢失的惨痛局面，有个备份的小技巧，如下（参考了<a href="https://wangjintian.com/2020/12/08/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/">文章</a>）。</p><ol><li><p>安装备份插件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ npm install hexo-git-backup@0.0.91 <span class="hljs-params">--save</span>  <span class="hljs-string">//Hexo</span> <span class="hljs-keyword">version</span> = 2.x.x<br>$ npm install hexo-git-backup <span class="hljs-params">--save</span>  <span class="hljs-string">//Hexo</span> <span class="hljs-keyword">version</span> &gt; 3.x.x<br></code></pre></td></tr></table></figure></li><li><p>到 Hexo 博客根目录的 <code>_config.yml</code> 配置文件里添加以下配置：(我使用了fluid主题，所以需要在<code>_config.fluid.yml</code>中同步配置)。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">backup:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  theme:</span> fluid<br><span class="hljs-symbol">  message:</span> Back up my blog<br><span class="hljs-symbol">  repository:</span><br><span class="hljs-symbol">    github:</span> git@github.com:coneycode/hexo-git-backup.git,hexo<br></code></pre></td></tr></table></figure><p>参数解释：</p><p>theme：你要备份的主题名称</p><p>message：自定义提交信息</p><p>repository：仓库名，注意仓库地址后面要添加一个分支名，比如我创建了一个 hexo 分支</p></li><li><p>在github仓库新建分支，分支名与上述配置对应</p></li><li><p>此时github仓库中应存在 master(或main)和hexo ，在提交的时候只需在 master 中使用以下命令备份你的博客即可：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo backup<br></code></pre></td></tr></table></figure><p>或者使用以下简写命令也可以：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo b<br></code></pre></td></tr></table></figure></li></ol><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>​后面会继续阅读utterances的官网，看看有没有好用的功能，把自己的博客丰富起来。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>[1] <a href="https://wangjintian.com/2020/12/08/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/">hexo博客备份</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RangeSumQueryMutable</title>
    <link href="/2024/10/14/RangeSumQueryMutable/"/>
    <url>/2024/10/14/RangeSumQueryMutable/</url>
    
    <content type="html"><![CDATA[<h2 id="RangeSumQueryMutable"><a href="#RangeSumQueryMutable" class="headerlink" title="RangeSumQueryMutable"></a>RangeSumQueryMutable</h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/description/">307. 区域和检索 - 数组可修改</a></p><p>给你一个数组 <code>nums</code> ，请你完成两类查询。</p><ol><li>其中一类查询要求 <strong>更新</strong> 数组 <code>nums</code> 下标对应的值</li><li>另一类查询要求返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的nums元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 用整数数组 <code>nums</code> 初始化对象</li><li><code>void update(int index, int val)</code> 将 <code>nums[index]</code> 的值 <strong>更新</strong> 为 <code>val</code></li><li><code>int sumRange(int left, int right)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的nums元素的 <strong>和</strong> （即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;NumArray&quot;</span>, <span class="hljs-string">&quot;sumRange&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;sumRange&quot;</span>]<br>[[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]<br>输出：<br>[null, <span class="hljs-number">9</span>, null, <span class="hljs-number">8</span>]<br><br>解释：<br><span class="hljs-symbol">NumArray</span> numArray = new <span class="hljs-symbol">NumArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]);<br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); // 返回 <span class="hljs-number">1</span> + <span class="hljs-number">3</span> + <span class="hljs-number">5</span> = <span class="hljs-number">9</span><br>numArray.update(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   // nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); // 返回 <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">5</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>0 &lt;= index &lt; nums.length</code></li><li><code>-100 &lt;= val &lt;= 100</code></li><li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li><li>调用 <code>update</code> 和 <code>sumRange</code> 方法次数不大于 <code>3 * 104</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NumArray &#123;<br><br>    private <span class="hljs-type">int</span>[] nums;<br>    private <span class="hljs-type">int</span>[] sum;<br>    private <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-built_in">public</span> NumArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        this.nums = nums;<br>        size = (<span class="hljs-type">int</span>) Math.sqrt(nums.length);<br>        sum = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[(nums.length + size - <span class="hljs-number">1</span>) / size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            sum[i/size] += nums[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-keyword">update</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-type">int</span> val) &#123;<br>        sum[<span class="hljs-keyword">index</span>/size] += val - nums[<span class="hljs-keyword">index</span>];<br>        nums[<span class="hljs-keyword">index</span>] = val;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> sumRange(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br>        <span class="hljs-type">int</span> b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;<br>        <span class="hljs-keyword">if</span> (b1 == b2) &#123;<br>            <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = i1; i &lt;= i2; i++) &#123;<br>                result += nums[b1 * size + i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-type">int</span> result1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = i1; i &lt; size; i++) &#123;<br>            result1 += nums[b1 * size + i];<br>        &#125;<br>        <span class="hljs-type">int</span> result2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= i2; i++) &#123;<br>            result2 += nums[b2 * size + i];<br>        &#125;<br>        <span class="hljs-type">int</span> result3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b1 + <span class="hljs-number">1</span>; i &lt; b2; i++) &#123;<br>            result2 += sum[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result1 + result2 + result3;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>官方给出了三种解决思路：分区间，线状数组，线段树。这道题在ACM应该是入门题，所以感觉leetcode更像应付互联网面试，多练习ACM对于算法和编码的提升还是有的，有空还是多去ACM OJ刷一刷。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AdditiveNumber</title>
    <link href="/2024/10/12/AdditiveNumber/"/>
    <url>/2024/10/12/AdditiveNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="AdditiveNumber"><a href="#AdditiveNumber" class="headerlink" title="AdditiveNumber"></a>AdditiveNumber</h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode.cn/problems/additive-number/description/">306. 累加数</a></p><p><strong>累加数</strong> 是一个字符串，组成它的数字可以形成累加序列。</p><p>一个有效的 <strong>累加序列</strong> 必须 <strong>至少</strong> 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。</p><p>给你一个只包含数字 <code>&#39;0&#39;-&#39;9&#39;</code> 的字符串，编写一个算法来判断给定输入是否是 <strong>累加数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>说明：</strong>累加序列里的数，除数字 0 之外，<strong>不会</strong> 以 0 开头，所以不会出现 <code>1, 2, 03</code> 或者 <code>1, 02, 3</code> 的情况。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：&quot;112358&quot;<br>输出：true <br>解释：累加序列为: 1, 1, 2, 3, 5,<span class="hljs-number"> 8 </span>。1 +<span class="hljs-number"> 1 </span>= 2,<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 3,<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>= 5,<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>= 8<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：&quot;199100199&quot;<br>输出：true <br>解释：累加序列为: 1, 99, 100, 199。1 +<span class="hljs-number"> 99 </span>= 100,<span class="hljs-number"> 99 </span>+<span class="hljs-number"> 100 </span>= 199<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num.length &lt;= 35</code></li><li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li></ul><p><strong>进阶：</strong>你计划如何处理由过大的整数输入导致的溢出?</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> AdditiveNumber &#123;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> isAdditiveNumber(String num) &#123;<br><br>        <span class="hljs-type">int</span> length = num.length();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> secondStart = <span class="hljs-number">1</span>; secondStart &lt; length - <span class="hljs-number">1</span>; secondStart++) &#123;<br>            <span class="hljs-keyword">if</span> (num.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; secondStart != <span class="hljs-number">1</span>) &#123;<br>                break;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> secondEnd = secondStart; secondEnd &lt; length - <span class="hljs-number">1</span>; secondEnd++) &#123;<br>                <span class="hljs-keyword">if</span> (num.charAt(secondStart) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; secondStart != secondEnd) &#123;<br>                    break;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">valid</span>(num, secondStart, secondEnd)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> <span class="hljs-keyword">valid</span>(String num, <span class="hljs-type">int</span> secondStart, <span class="hljs-type">int</span> secondEnd) &#123;<br>        <span class="hljs-type">int</span> firstStart = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (secondEnd &lt;= num.length() - <span class="hljs-number">1</span>) &#123;<br>            String thirdNum = stringAdd(num, firstStart, secondStart, secondEnd);<br>            <span class="hljs-type">int</span> thirdStart = secondEnd + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> thirdEnd = secondEnd + thirdNum.length();<br>            <span class="hljs-keyword">if</span> (thirdEnd &gt;= num.length() || !num.substring(thirdStart, thirdEnd + <span class="hljs-number">1</span>).equals(thirdNum)) &#123;<br>                break;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (thirdEnd == num.length() - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            firstStart = secondStart;<br>            secondStart = secondEnd + <span class="hljs-number">1</span>;<br>            secondEnd = secondEnd + thirdNum.length();<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    private String stringAdd(String num, <span class="hljs-type">int</span> firstStart, <span class="hljs-type">int</span> secondStart, <span class="hljs-type">int</span> secondEnd) &#123;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> firstEnd = secondStart - <span class="hljs-number">1</span>;<br>        StringBuilder sb = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (firstStart &lt;= firstEnd || secondStart &lt;= secondEnd || carry != <span class="hljs-number">0</span>) &#123;<br>            cur = carry;<br>            <span class="hljs-keyword">if</span> (firstEnd &gt;= firstStart) &#123;<br>                cur += num.charAt(firstEnd) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (secondEnd &gt;= secondStart) &#123;<br>                cur += num.charAt(secondEnd) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            carry = cur / <span class="hljs-number">10</span>;<br>            cur = cur % <span class="hljs-number">10</span>;<br>            sb.append((<span class="hljs-type">char</span>)(cur + <span class="hljs-string">&#x27;0&#x27;</span>));<br>            firstEnd<span class="hljs-comment">--;</span><br>            secondEnd<span class="hljs-comment">--;</span><br>        &#125;<br>        sb.reverse();<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其实就是暴力解决，利用中间第二个数字的起始位置，作为最重要的分界点。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>局域网互访虚机</title>
    <link href="/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/"/>
    <url>/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="局域网互访虚机"><a href="#局域网互访虚机" class="headerlink" title="局域网互访虚机"></a>局域网互访虚机</h1><ul><li><a href="https://yangtzeshore.github.io/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE">宿主机配置</a></li><li><a href="https://yangtzeshore.github.io/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/#%E8%99%9A%E6%9C%BA%E9%85%8D%E7%BD%AE">虚机配置</a></li><li><a href="https://yangtzeshore.github.io/2022/01/08/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%AE%BF%E8%99%9A%E6%9C%BA/#kvm%E9%85%8D%E7%BD%AE">kvm配置</a></li></ul><h2 id="宿主机配置"><a href="#宿主机配置" class="headerlink" title="宿主机配置"></a>宿主机配置</h2><p>找到&#x2F;etc&#x2F;network&#x2F;interfaces，在后面添加</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">auto</span> br0     //添加的桥接网卡，新的名字<br><span class="hljs-attribute">iface</span> br0 inet static<br><span class="hljs-attribute">address</span> <span class="hljs-number">10.0.1.60</span>    //宿主机IP<br><span class="hljs-attribute">netmask</span> <span class="hljs-number">255.255.254.0</span><br><span class="hljs-attribute">broadcast</span> <span class="hljs-number">10.0.1.255</span><br><span class="hljs-attribute">gateway</span> <span class="hljs-number">10.0.0.1</span><br><span class="hljs-attribute">dns</span>-nameservers <span class="hljs-number">114.114.114.114</span>  <br><span class="hljs-attribute">bridge_ports</span> enp0s31f6   //宿主机网卡名<br><span class="hljs-attribute">bridge_fd</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>然后在宿主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ifup br0<br></code></pre></td></tr></table></figure><h2 id="虚机配置"><a href="#虚机配置" class="headerlink" title="虚机配置"></a>虚机配置</h2><p>在 <strong>每台</strong> 虚机下配置</p><p>&#x2F;etc&#x2F;hostname<br>sysctl kernel.hostname&#x3D;yourhostname</p><p>打开&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0，依照以下修改，注意：ONBOOT&#x3D;yes和static。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">HWADDR</span>=<span class="hljs-number">52</span>:<span class="hljs-number">54</span>:<span class="hljs-number">00</span>:<span class="hljs-number">2</span>a:b9:f3<br><span class="hljs-attr">TYPE</span>=Ethernet  <br><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">NAME</span>=ens3   //虚机网卡名字<br><span class="hljs-attr">UUID</span>=f9c0608a-<span class="hljs-number">3290</span>-<span class="hljs-number">4</span>a44-b209-<span class="hljs-number">7</span>c25aaa7fec8<br><span class="hljs-attr">DEVICE</span>=ens3  //虚机网卡名字<br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>  //一定<span class="hljs-literal">yes</span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span>  //连外网必备<br><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.152</span>   //你要配的虚机网卡IP，<span class="hljs-number">0</span>网段<br><span class="hljs-attr">PREFIX</span>=<span class="hljs-number">23</span>  //。。<br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span>  //。。<br><span class="hljs-attr">IPV6_PEERDNS</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_PEERROUTES</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h2 id="kvm配置"><a href="#kvm配置" class="headerlink" title="kvm配置"></a>kvm配置</h2><p>打开每台虚机的kvm设置，点击感叹号，点击NIC，找到网络源，选择桥接br0，点击应用确定。然后强制关机再开机（你也可以等待重启）。然后就可以在局域网访问你的虚机了。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span><br></code></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="ubuntu环境设置DNS"><a href="#ubuntu环境设置DNS" class="headerlink" title="ubuntu环境设置DNS"></a>ubuntu环境设置DNS</h3><p>在Ubuntu环境下，打开网页非常缓慢，很可能是DNS设置异常的问题。</p><ul><li><p>方法1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vi /etc/network/interfaces<br>dns-nameservers 114.114.114.114<br></code></pre></td></tr></table></figure></li><li><p>方法2：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>resolvconf<span class="hljs-regexp">/resolv.conf/</span>base  <br>或者<span class="hljs-regexp">/etc/</span>resolvconf<span class="hljs-regexp">/resolv.conf.d/</span>base<br>修改为：<br>nameserver <span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span><br>nameserver <span class="hljs-number">8.8</span>.<span class="hljs-number">4.4</span><br>然后执行resolvconf -u  <br></code></pre></td></tr></table></figure><p>就能在&#x2F;etc&#x2F;resolv.conf文件中多出2行。<br>还有一种方式是修改&#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf&#x2F;head，不过这个文件系统不建议修改。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SingleNumberII</title>
    <link href="/2022/01/08/SingleNumberII/"/>
    <url>/2022/01/08/SingleNumberII/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字-II"><a href="#只出现一次的数字-II" class="headerlink" title="只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">只出现一次的数字 II</a></h1><ul><li><a href="https://yangtzeshore.github.io/2022/01/04/SingleNumberII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/04/SingleNumberII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="只出现一次的数字-II-1"><a href="#只出现一次的数字-II-1" class="headerlink" title="只出现一次的数字 II"></a>只出现一次的数字 II</h4><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">2,2,3,2</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,1,0,1,99]</span><br>输出：<span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li></ul><p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int</span> ones = <span class="hljs-number">0</span>, twos = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums)&#123;<br>    ones = ones ^ <span class="hljs-built_in">num</span> &amp; ~twos;<br>    twos = twos ^ <span class="hljs-built_in">num</span> &amp; ~ones;<br>&#125;<br><span class="hljs-keyword">return</span> ones;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 其实就是一个数学分析题，需要利用取余的方式来计算，中间由两个位的状态机来模拟此数据移动，然后找出规律。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CopyListWithRandomPointer</title>
    <link href="/2022/01/05/CopyListWithRandomPointer/"/>
    <url>/2022/01/05/CopyListWithRandomPointer/</url>
    
    <content type="html"><![CDATA[<h1 id="CopyListWithRandomPointer"><a href="#CopyListWithRandomPointer" class="headerlink" title="CopyListWithRandomPointer"></a>CopyListWithRandomPointer</h1><h1 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">复制带随机指针的链表</a></h1><ul><li><a href="https://yangtzeshore.github.io/2022/01/05/CopyListWithRandomPointer/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/05/CopyListWithRandomPointer/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="复制带随机指针的链表-1"><a href="#复制带随机指针的链表-1" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h4><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/e1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/e2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/e3.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li></ul><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs q">Map&lt;Node, Node&gt; map2 = new HashMap&lt;&gt;();<br>    public Node copyRandomList(Node head) &#123;<br><br>        if (head == <span class="hljs-built_in">null</span>) &#123;<br>            return <span class="hljs-built_in">null</span>;<br>        &#125;<br>        map2.clear();<br>        Node dumb = new Node(<span class="hljs-number">0</span>);<br>        Node cur = head;<br>        Node <span class="hljs-built_in">prev</span> = dumb;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;<br>            Node newNode = new Node(cur.val);<br>            map2.put(cur, newNode);<br>            <span class="hljs-built_in">count</span>++;<br>            <span class="hljs-built_in">prev</span>.<span class="hljs-built_in">next</span> = newNode;<br>            <span class="hljs-built_in">prev</span> = newNode;<br>            cur = cur.<span class="hljs-built_in">next</span>;<br>        &#125;<br><br>        cur = head;<br>        <span class="hljs-built_in">prev</span> = dumb;<br>        <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;<br>            if (cur.random != <span class="hljs-built_in">null</span>) &#123;<br>                <span class="hljs-built_in">prev</span>.<span class="hljs-built_in">next</span>.random = map2.<span class="hljs-built_in">get</span>(cur.random);<br>            &#125;<br>            <span class="hljs-built_in">count</span>++;<br>            <span class="hljs-built_in">prev</span> = <span class="hljs-built_in">prev</span>.<span class="hljs-built_in">next</span>;<br>            cur = cur.<span class="hljs-built_in">next</span>;<br>        &#125;<br>        return dumb.<span class="hljs-built_in">next</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，不难，就是需要记录random的映射关系。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SingleNumber</title>
    <link href="/2022/01/02/SingleNumber/"/>
    <url>/2022/01/02/SingleNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></h2><ul><li><a href="https://yangtzeshore.github.io/2022/01/02/SingleNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/02/SingleNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="只出现一次的数字-1"><a href="#只出现一次的数字-1" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h4><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleNumber</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            nums[<span class="hljs-number">0</span>] = nums[i] ^ nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        SingleNumber singleNumber = <span class="hljs-keyword">new</span> SingleNumber();<br>        <span class="hljs-built_in">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(singleNumber.singleNumber(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(singleNumber.singleNumber(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 就是很简单的数学题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Candy</title>
    <link href="/2022/01/01/Candy/"/>
    <url>/2022/01/01/Candy/</url>
    
    <content type="html"><![CDATA[<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></h2><ul><li><a href="https://yangtzeshore.github.io/2022/01/01/Candy/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2022/01/01/Candy/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="分发糖果-1"><a href="#分发糖果-1" class="headerlink" title="分发糖果"></a>分发糖果</h4><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1:</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,0,2]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,2,2]</span><br><span class="hljs-string">输出：4</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="hljs-string">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li>1&lt;&#x3D;n&lt;&#x3D;2∗104</li><li>0&lt;&#x3D;ratings[i]&lt;&#x3D;2∗104</li></ul><h4 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Candy &#123;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> candy(<span class="hljs-type">int</span>[] ratings) &#123;<br>        <span class="hljs-type">int</span> n = ratings.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>]) &#123;<br>                left[i] = left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">if</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                right++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = <span class="hljs-number">1</span>;<br>            &#125;<br>            ret += Math.max(left[i], right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        Candy candy = <span class="hljs-built_in">new</span> Candy();<br>        <span class="hljs-type">int</span>[] rating = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(candy.candy(rating));<br><br>        rating = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(candy.candy(rating));<br><br>        rating = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(candy.candy(rating));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>4<br>7<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 其实蛮简单的，就是将规则拆开，左遍历和右遍历取max。看起来很诡异，其实只要明白不小于1的规则，以及升降的含义就好了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GasStation</title>
    <link href="/2021/12/26/GasStation/"/>
    <url>/2021/12/26/GasStation/</url>
    
    <content type="html"><![CDATA[<h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">加油站</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/12/26/GasStation/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/12/26/GasStation/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="加油站-1"><a href="#加油站-1" class="headerlink" title="加油站"></a>加油站</h4><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong></p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br><br>输出: 3<br><br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [2,3,4]<br>cost = [3,4,3]<br><br>输出: -1<br><br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> canCompleteCircuit(<span class="hljs-built_in">int</span>[] gas, <span class="hljs-built_in">int</span>[] cost) &#123;<br>        <span class="hljs-built_in">int</span> n = gas.length;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; <br><br>        <span class="hljs-comment">// 从头到尾遍历每个加油站，并且检查以该加油站为起点，能否行驶一周</span><br>        <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>            <span class="hljs-built_in">int</span> sumOfGas  = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总共加的油</span><br>            <span class="hljs-built_in">int</span> SumOfCost = <span class="hljs-number">0</span>; <span class="hljs-comment">// 总共消费的油</span><br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 记录能走过几个站点</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">count</span> &lt; n)&#123;  <span class="hljs-comment">// 退出循环的条件是走过所有的站点</span><br>                <span class="hljs-built_in">int</span> j = (i + <span class="hljs-keyword">count</span>) % n; <span class="hljs-comment">// 加油站是环形的</span><br>                sumOfGas += gas[j];<br>                SumOfCost += cost[j];<br>                <span class="hljs-keyword">if</span>(SumOfCost &gt; sumOfGas)&#123; <span class="hljs-comment">// 如果这个站点发现油不够了</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">count</span>++; <span class="hljs-comment">// 这个站点满足情况</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> == n)&#123;  <span class="hljs-comment">// 如果能环绕一圈</span><br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 不行的话 从下一个站点开始 检查</span><br>                i = i + <span class="hljs-keyword">count</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 所有加油站作为起点都不满足</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">3<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 自己写了一版，效率不高。主要还是有一个主思路：如果x到不了y+1（但能到y），那么从x到y的任一点出发都不可能到达y+1。 因为从其中任一点出发的话，相当于从0开始加油，而如果从x出发到该点则不一定是从0开始加油，&#x2F;&#x2F; 可能还有剩余的油。既然不从0开始都到不了y+1，那么从0开始就更不可能到达y+1了。另外，编码上，用count来计算遍历过的加油站数量，很微妙，然后再用这个计算终点，确实很优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CloneGraph</title>
    <link href="/2021/12/25/CloneGraph/"/>
    <url>/2021/12/25/CloneGraph/</url>
    
    <content type="html"><![CDATA[<h4 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/">克隆图</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/12/25/CloneGraph/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/12/25/CloneGraph/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="克隆图-1"><a href="#克隆图-1" class="headerlink" title="克隆图"></a>克隆图</h4><p>给你无向 <strong><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    public <span class="hljs-keyword">int</span> val;<br>    public List&lt;Node&gt; neighbors;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试用例格式：</strong></p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p><p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/133_clone_graph_question.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]<br>输出：[[2,4],[1,3],[2,4],[1,3]]<br>解释：<br>图中有<span class="hljs-number"> 4 </span>个节点。<br>节点<span class="hljs-number"> 1 </span>的值是 1，它有两个邻居：节点<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>节点<span class="hljs-number"> 2 </span>的值是 2，它有两个邻居：节点<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>。<br>节点<span class="hljs-number"> 3 </span>的值是 3，它有两个邻居：节点<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>节点<span class="hljs-number"> 4 </span>的值是 4，它有两个邻居：节点<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/graph.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：adjList = <span class="hljs-string">[[]]</span><br>输出：<span class="hljs-string">[[]]</span><br>解释：输入包含一个空列表。该图仅仅只有一个值为 <span class="hljs-number">1</span> 的节点，它没有任何邻居。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：adjList = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：这个图是空的，它不含任何节点。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/graph-1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：adjList = <span class="hljs-string">[[2],[1]]</span><br>输出：<span class="hljs-string">[[2],[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>节点数不超过 100 。</li><li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li><li>无向图是一个<a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>图是连通图，你可以从给定节点访问到所有节点。</li></ol><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br>import java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CloneGraph</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">cloneGraph</span>(<span class="hljs-params">Node node</span>)</span> &#123;<br>        Set&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        Node dfsNode = dfs(node, <span class="hljs-keyword">set</span>);<br>        node.neighbors = dfsNode.neighbors;<br>        <span class="hljs-keyword">return</span> dfsNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">dfs</span>(<span class="hljs-params">Node node, Set&lt;Integer&gt; <span class="hljs-keyword">set</span></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        List&lt;Node&gt; neighbors = node.neighbors;<br>        Node nodeNew = <span class="hljs-keyword">new</span> Node(node.val);<br>        <span class="hljs-keyword">for</span> (Node neighbor : neighbors) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">set</span>.contains(neighbor.val)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(neighbor.val);<br>            Node nextNode = dfs(neighbor, <span class="hljs-keyword">set</span>);<br>            <span class="hljs-keyword">if</span> (nodeNew.neighbors == <span class="hljs-literal">null</span>) &#123;<br>                List&lt;Node&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.<span class="hljs-keyword">add</span>(nextNode);<br>                nodeNew.neighbors = list;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nodeNew.neighbors.<span class="hljs-keyword">add</span>(nodeNew);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nodeNew;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        CloneGraph s = <span class="hljs-keyword">new</span> CloneGraph();<br>        Node node = <span class="hljs-literal">null</span>;<br>        Node result = s.cloneGraph(node);<br>        System.<span class="hljs-keyword">out</span>.println(result);<br><br>        node = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);<br>        result = s.cloneGraph(node);<br>        System.<span class="hljs-keyword">out</span>.println(result);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params">Node node</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(node.val);<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br>        <span class="hljs-keyword">public</span> List&lt;Node&gt; neighbors;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>()</span> &#123;<br>            val = <span class="hljs-number">0</span>;<br>            neighbors = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> _val</span>)</span> &#123;<br>            val = _val;<br>            neighbors = <span class="hljs-keyword">new</span> ArrayList&lt;Node&gt;();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> _val, ArrayList&lt;Node&gt; _neighbors</span>)</span> &#123;<br>            val = _val;<br>            neighbors = _neighbors;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 其实并不难，需要注意遍历然后记录遍历，还有就是返回遍历的克隆节点。如果是1-2这种，1的邻居当然是2，2的邻居当然也是1，需要注意将已经遍历收集到的邻居直接返回，不需要再次遍历邻居。好久没有做算法题，终于不忙了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PalindromePartitioning</title>
    <link href="/2021/09/21/PalindromePartitioning/"/>
    <url>/2021/09/21/PalindromePartitioning/</url>
    
    <content type="html"><![CDATA[<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/21/PalindromePartitioning/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/21/PalindromePartitioning/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="分割回文串-1"><a href="#分割回文串-1" class="headerlink" title="分割回文串"></a>分割回文串</h4><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-keyword">partition</span>(String s) &#123;<br>        <span class="hljs-type">int</span> len = s.length();<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        // Stack 这个类 Java 的文档里推荐写成 Deque&lt;<span class="hljs-type">Integer</span>&gt; stack = <span class="hljs-built_in">new</span> ArrayDeque&lt;<span class="hljs-type">Integer</span>&gt;();<br>        // 注意：只使用 stack 相关的接口<br>        Deque&lt;String&gt; stack = <span class="hljs-built_in">new</span> ArrayDeque&lt;&gt;();<br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        dfs(charArray, <span class="hljs-number">0</span>, len, stack, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param charArray</span><br><span class="hljs-comment">     * @param index     起始字符的索引</span><br><span class="hljs-comment">     * @param len       字符串 s 的长度，可以设置为全局变量</span><br><span class="hljs-comment">     * @param path      记录从根结点到叶子结点的路径</span><br><span class="hljs-comment">     * @param res       记录所有的结果</span><br><span class="hljs-comment">     */</span><br>    private <span class="hljs-type">void</span> dfs(<span class="hljs-type">char</span>[] charArray, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>, <span class="hljs-type">int</span> len, Deque&lt;String&gt; <span class="hljs-type">path</span>, List&lt;List&lt;String&gt;&gt; res) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == len) &#123;<br>            res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">index</span>; i &lt; len; i++) &#123;<br>            // 因为截取字符串是消耗性能的，因此，采用传子串下标的方式判断一个子串是否是回文子串<br>            <span class="hljs-keyword">if</span> (!checkPalindrome(charArray, <span class="hljs-keyword">index</span>, i)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">path</span>.addLast(<span class="hljs-built_in">new</span> String(charArray, <span class="hljs-keyword">index</span>, i + <span class="hljs-number">1</span> - <span class="hljs-keyword">index</span>));<br>            dfs(charArray, i + <span class="hljs-number">1</span>, len, <span class="hljs-type">path</span>, res);<br>            <span class="hljs-type">path</span>.removeLast();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这一步的时间复杂度是 O(N)，优化的解法是，先采用动态规划，把回文子串的结果记录在一个表格里</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param charArray</span><br><span class="hljs-comment">     * @param left      子串的左边界，可以取到</span><br><span class="hljs-comment">     * @param right     子串的右边界，可以取到</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    private <span class="hljs-type">boolean</span> checkPalindrome(<span class="hljs-type">char</span>[] charArray, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (charArray[left] != charArray[right]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            left++;<br>            right<span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 递归加深度遍历，主要是题目意思没有明白，其实还是很简单的，难度中等没毛病。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SurroundedRegions</title>
    <link href="/2021/09/16/SurroundedRegions/"/>
    <url>/2021/09/16/SurroundedRegions/</url>
    
    <content type="html"><![CDATA[<h4 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/16/SurroundedRegions/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/16/SurroundedRegions/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="被围绕的区域-1"><a href="#被围绕的区域-1" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h4><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/xogrid.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]<br>输出：[[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]<br>解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 都不会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。 任何不在边界上，或不与边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 相连的 <span class="hljs-string">&#x27;O&#x27;</span> 最终都会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 <br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：board = <span class="hljs-string">[[&quot;X&quot;]]</span><br>输出：<span class="hljs-string">[[&quot;X&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"> <span class="hljs-keyword">int</span> m;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br><br>        m = board.length; <span class="hljs-comment">// 行</span><br>        n = board[<span class="hljs-number">0</span>].length; <span class="hljs-comment">// 列</span><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dfs(board, <span class="hljs-number">0</span>, i);<br>            dfs(board, m - <span class="hljs-number">1</span>, i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            dfs(board, i, <span class="hljs-number">0</span>);<br>            dfs(board, i, n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)</span> </span>&#123;<br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt; m - <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">0</span> || y &gt; n - <span class="hljs-number">1</span> || board[x][y] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        board[x][y] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>        dfs(board, x + <span class="hljs-number">1</span>, y);<br>        dfs(board, x - <span class="hljs-number">1</span>, y);<br>        dfs(board, x, y + <span class="hljs-number">1</span>);<br>        dfs(board, x, y - <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上， 注意dfs的结束条件是不等于O，因为边界可能被来回dfs，O会被标记为A，不会来回标记。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SumRootToLeafNumbers</title>
    <link href="/2021/09/13/SumRootToLeafNumbers/"/>
    <url>/2021/09/13/SumRootToLeafNumbers/</url>
    
    <content type="html"><![CDATA[<h4 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">求根节点到叶节点数字之和</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/13/SumRootToLeafNumbers/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/13/SumRootToLeafNumbers/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="求根节点到叶节点数字之和-1"><a href="#求根节点到叶节点数字之和-1" class="headerlink" title="求根节点到叶节点数字之和"></a>求根节点到叶节点数字之和</h4><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/num1tree.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">25</span><br>解释：<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span> 代表数字 <span class="hljs-number">12</span><br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span> 代表数字 <span class="hljs-number">13</span><br>因此，数字总和 = <span class="hljs-number">12</span> + <span class="hljs-number">13</span> = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/num2tree.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：root = [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1026</span><br>解释：<br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">5</span> 代表数字 <span class="hljs-number">495</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">1</span> 代表数字 <span class="hljs-number">491</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> 代表数字 <span class="hljs-number">40</span><br>因此，数字总和 = <span class="hljs-number">495</span> + <span class="hljs-number">491</span> + <span class="hljs-number">40</span> = <span class="hljs-number">1026</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>树的深度不超过 <code>10</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>    result = <span class="hljs-number">0</span>;<br>    dfs(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br><br>   <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;<br>        result += cur * <span class="hljs-number">10</span> + root.val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>)&#123;<br>        dfs(root.left, cur * <span class="hljs-number">10</span> + root.val);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>        dfs(root.right, cur * <span class="hljs-number">10</span> + root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是简单的dfs。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestConsecutiveSequence</title>
    <link href="/2021/09/13/LongestConsecutiveSequence/"/>
    <url>/2021/09/13/LongestConsecutiveSequence/</url>
    
    <content type="html"><![CDATA[<h4 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/13/LongestConsecutiveSequence/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/13/LongestConsecutiveSequence/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="长连续序列"><a href="#长连续序列" class="headerlink" title="长连续序列"></a>长连续序列</h4><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0&lt;&#x3D;nums.length&lt;&#x3D;105</li><li>−109&lt;&#x3D;nums[i]&lt;&#x3D;109</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-built_in">int</span> longestConsecutive(<span class="hljs-built_in">int</span>[] nums) &#123;<br><br>    <span class="hljs-built_in">Set</span>&lt;Integer&gt; num_set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;<br>        num_set.add(<span class="hljs-built_in">num</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> longestStreak = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : num_set) &#123;<br>        <span class="hljs-keyword">if</span> (!num_set.contains(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-built_in">int</span> currentNum = <span class="hljs-built_in">num</span>;<br>            <span class="hljs-built_in">int</span> currentStreak = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (num_set.contains(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                currentNum += <span class="hljs-number">1</span>;<br>                currentStreak += <span class="hljs-number">1</span>;<br>            &#125;<br><br>            longestStreak = Math.max(longestStreak, currentStreak);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> longestStreak;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，主要还是if的判断，形象的理解就是，如果自己没有下限，就要往上累加；如果自己有下限，那就是已经被算计过了，这样避免了重复计算，达不到O(n)要求。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WordLadder</title>
    <link href="/2021/09/12/WordLadder/"/>
    <url>/2021/09/12/WordLadder/</url>
    
    <content type="html"><![CDATA[<h4 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/12/WordLadder/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/12/WordLadder/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="单词接龙-1"><a href="#单词接龙-1" class="headerlink" title="单词接龙"></a>单词接龙</h4><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列：</p><ul><li>序列中第一个单词是 <code>beginWord</code> 。</li><li>序列中最后一个单词是 <code>endWord</code> 。</li><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典 <code>wordList</code> 中的单词。</li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong> 。如果不存在这样的转换序列，返回 0。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br>输出：<span class="hljs-number">5</span><br>解释：一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>, 返回它的长度 <span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li><li><code>beginWord != endWord</code></li><li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Map&lt;String, <span class="hljs-type">Integer</span>&gt; wordId = <span class="hljs-built_in">new</span> HashMap&lt;String, <span class="hljs-type">Integer</span>&gt;();<br>    List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; edge = <span class="hljs-built_in">new</span> ArrayList&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;();<br>    <span class="hljs-type">int</span> nodeNum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;<br>        <span class="hljs-keyword">for</span> (String word : wordList) &#123;<br>            addEdge(word);<br>        &#125;<br>        addEdge(beginWord);<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] disBegin = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nodeNum];<br>        Arrays.fill(disBegin, <span class="hljs-type">Integer</span>.MAX_VALUE);<br>        <span class="hljs-type">int</span> beginId = wordId.<span class="hljs-keyword">get</span>(beginWord);<br>        disBegin[beginId] = <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">Integer</span>&gt; queBegin = <span class="hljs-built_in">new</span> LinkedList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        queBegin.offer(beginId);<br>        <br>        <span class="hljs-type">int</span>[] disEnd = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nodeNum];<br>        Arrays.fill(disEnd, <span class="hljs-type">Integer</span>.MAX_VALUE);<br>        <span class="hljs-type">int</span> endId = wordId.<span class="hljs-keyword">get</span>(endWord);<br>        disEnd[endId] = <span class="hljs-number">0</span>;<br>        Queue&lt;<span class="hljs-type">Integer</span>&gt; queEnd = <span class="hljs-built_in">new</span> LinkedList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        queEnd.offer(endId);<br><br>        <span class="hljs-keyword">while</span> (!queBegin.isEmpty() &amp;&amp; !queEnd.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> queBeginSize = queBegin.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queBeginSize; ++i) &#123;<br>                <span class="hljs-type">int</span> nodeBegin = queBegin.poll();<br>                <span class="hljs-keyword">if</span> (disEnd[nodeBegin] != <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">return</span> (disBegin[nodeBegin] + disEnd[nodeBegin]) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.<span class="hljs-keyword">get</span>(nodeBegin)) &#123;<br>                    <span class="hljs-keyword">if</span> (disBegin[it] == <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                        disBegin[it] = disBegin[nodeBegin] + <span class="hljs-number">1</span>;<br>                        queBegin.offer(it);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> queEndSize = queEnd.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queEndSize; ++i) &#123;<br>                <span class="hljs-type">int</span> nodeEnd = queEnd.poll();<br>                <span class="hljs-keyword">if</span> (disBegin[nodeEnd] != <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                    <span class="hljs-keyword">return</span> (disBegin[nodeEnd] + disEnd[nodeEnd]) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : edge.<span class="hljs-keyword">get</span>(nodeEnd)) &#123;<br>                    <span class="hljs-keyword">if</span> (disEnd[it] == <span class="hljs-type">Integer</span>.MAX_VALUE) &#123;<br>                        disEnd[it] = disEnd[nodeEnd] + <span class="hljs-number">1</span>;<br>                        queEnd.offer(it);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addEdge(String word) &#123;<br>        addWord(word);<br>        <span class="hljs-type">int</span> id1 = wordId.<span class="hljs-keyword">get</span>(word);<br>        <span class="hljs-type">char</span>[] <span class="hljs-keyword">array</span> = word.toCharArray();<br>        <span class="hljs-type">int</span> length = <span class="hljs-keyword">array</span>.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">char</span> tmp = <span class="hljs-keyword">array</span>[i];<br>            <span class="hljs-keyword">array</span>[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            String newWord = <span class="hljs-built_in">new</span> String(<span class="hljs-keyword">array</span>);<br>            addWord(newWord);<br>            <span class="hljs-type">int</span> id2 = wordId.<span class="hljs-keyword">get</span>(newWord);<br>            edge.<span class="hljs-keyword">get</span>(id1).<span class="hljs-keyword">add</span>(id2);<br>            edge.<span class="hljs-keyword">get</span>(id2).<span class="hljs-keyword">add</span>(id1);<br>            <span class="hljs-keyword">array</span>[i] = tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addWord(String word) &#123;<br>        <span class="hljs-keyword">if</span> (!wordId.containsKey(word)) &#123;<br>            wordId.put(word, nodeNum++);<br>            edge.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，反而我觉得这道题应该排在上面一道题前面，也是图的算法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WordLadderII</title>
    <link href="/2021/09/11/WordLadderII/"/>
    <url>/2021/09/11/WordLadderII/</url>
    
    <content type="html"><![CDATA[<h4 id="单词接龙-II"><a href="#单词接龙-II" class="headerlink" title="单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/">单词接龙 II</a></h4><ul><li><a href="https://yangtzeshore.github.io/2021/09/11/WordLadderII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/11/WordLadderII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="单词接龙-II-1"><a href="#单词接龙-II-1" class="headerlink" title="单词接龙 II"></a>单词接龙 II</h4><p>按字典 <code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>这样的单词序列，并满足：</p><ul><li>每对相邻的单词之间仅有单个字母不同。</li><li>转换过程中的每个单词 <code>si</code>（<code>1 &lt;= i &lt;= k</code>）必须是字典 <code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</li><li><code>sk == endWord</code></li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表<code>[beginWord, s1, s2, ..., sk]</code> 的形式返回。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br>输出：[[<span class="hljs-string">&quot;hit&quot;</span>,<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>],[<span class="hljs-string">&quot;hit&quot;</span>,<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]]<br>解释：存在 <span class="hljs-number">2</span> 种最短的转换序列：<br><span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span><br><span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;lot&quot;</span> -&gt; <span class="hljs-string">&quot;log&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br>输出：[]<br>解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典 wordList 中，所以不存在符合要求的转换序列。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 7</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li><li><code>beginWord != endWord</code></li><li><code>wordList</code> 中的所有单词 <strong>互不相同</strong></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-type">String</span>&gt;&gt; <span class="hljs-built_in">findLadders</span>(<span class="hljs-type">String</span> beginWord, <span class="hljs-type">String</span> endWord, List&lt;<span class="hljs-type">String</span>&gt; wordList) &#123;<br>        List&lt;List&lt;<span class="hljs-type">String</span>&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span><br>        Set&lt;<span class="hljs-type">String</span>&gt; dict = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordList);<br>        <span class="hljs-comment">// 特殊用例判断</span><br>        <span class="hljs-keyword">if</span> (!dict.<span class="hljs-built_in">contains</span>(endWord)) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        dict.<span class="hljs-built_in">remove</span>(beginWord);<br><br>        <span class="hljs-comment">// 第 1 步：广度优先遍历建图</span><br>        <span class="hljs-comment">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层</span><br>        Map&lt;<span class="hljs-type">String</span>, Integer&gt; steps = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        steps.<span class="hljs-built_in">put</span>(beginWord, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span><br>        Map&lt;<span class="hljs-type">String</span>, List&lt;<span class="hljs-type">String</span>&gt;&gt; from = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> found = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> wordLen = beginWord.<span class="hljs-built_in">length</span>();<br>        Queue&lt;<span class="hljs-type">String</span>&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.<span class="hljs-built_in">offer</span>(beginWord);<br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = queue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">String</span> currWord = queue.<span class="hljs-built_in">poll</span>();<br>                <span class="hljs-type">char</span>[] charArray = currWord.<span class="hljs-built_in">toCharArray</span>();<br>                <span class="hljs-comment">// 将每一位替换成 26 个小写英文字母</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; wordLen; j++) &#123;<br>                    <span class="hljs-type">char</span> origin = charArray[j];<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++) &#123;<br>                        charArray[j] = c;<br>                        <span class="hljs-type">String</span> nextWord = <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(charArray);<br>                        <span class="hljs-keyword">if</span> (steps.<span class="hljs-built_in">containsKey</span>(nextWord) &amp;&amp; step == steps.<span class="hljs-built_in">get</span>(nextWord)) &#123;<br>                            from.<span class="hljs-built_in">get</span>(nextWord).<span class="hljs-built_in">add</span>(currWord);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (!dict.<span class="hljs-built_in">contains</span>(nextWord)) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span><br>                        dict.<span class="hljs-built_in">remove</span>(nextWord);<br>                        <span class="hljs-comment">// 这一层扩展出的单词进入队列</span><br>                        queue.<span class="hljs-built_in">offer</span>(nextWord);<br><br>                        <span class="hljs-comment">// 记录 nextWord 从 currWord 而来</span><br>                        from.<span class="hljs-built_in">putIfAbsent</span>(nextWord, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>                        from.<span class="hljs-built_in">get</span>(nextWord).<span class="hljs-built_in">add</span>(currWord);<br>                        <span class="hljs-comment">// 记录 nextWord 的 step</span><br>                        steps.<span class="hljs-built_in">put</span>(nextWord, step);<br>                        <span class="hljs-keyword">if</span> (nextWord.<span class="hljs-built_in">equals</span>(endWord)) &#123;<br>                            found = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                    charArray[j] = origin;<br>                &#125;<br>            &#125;<br>            step++;<br>            <span class="hljs-keyword">if</span> (found) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span><br>        <span class="hljs-keyword">if</span> (found) &#123;<br>            Deque&lt;<span class="hljs-type">String</span>&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>            path.<span class="hljs-built_in">add</span>(endWord);<br>            <span class="hljs-built_in">dfs</span>(from, path, beginWord, endWord, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Map&lt;<span class="hljs-type">String</span>, List&lt;<span class="hljs-type">String</span>&gt;&gt; from, Deque&lt;<span class="hljs-type">String</span>&gt; path, <span class="hljs-type">String</span> beginWord, <span class="hljs-type">String</span> cur, List&lt;List&lt;<span class="hljs-type">String</span>&gt;&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">equals</span>(beginWord)) &#123;<br>            res.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> precursor : from.<span class="hljs-built_in">get</span>(cur)) &#123;<br>            path.<span class="hljs-built_in">addFirst</span>(precursor);<br>            <span class="hljs-built_in">dfs</span>(from, path, beginWord, precursor, res);<br>            path.<span class="hljs-built_in">removeFirst</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，这是典型的图算法，算是入门。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidPalindrome</title>
    <link href="/2021/09/04/ValidPalindrome/"/>
    <url>/2021/09/04/ValidPalindrome/</url>
    
    <content type="html"><![CDATA[<h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h3><ul><li><a href="https://yangtzeshore.github.io/2021/09/04/ValidPalindrome/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/09/04/ValidPalindrome/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="验证回文串-1"><a href="#验证回文串-1" class="headerlink" title="验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">验证回文串</a></h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><br>输出: <span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;amanaplanacanalpanama&quot;</span> 是回文串<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;race a car&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;raceacar&quot;</span> 不是回文串<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;s.length&lt;&#x3D;2∗105</li><li>字符串 <code>s</code> 由 ASCII 字符组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nsis">public boolean isPalindrome(String s) &#123;<br>       s = s.toLowerCase()<span class="hljs-comment">;</span><br>       int <span class="hljs-literal">left</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>       int <span class="hljs-literal">right</span> = s.length() - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>       while (<span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span>) &#123;<br>           while (<span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span> &amp;&amp; !isValidChar(s.charAt(<span class="hljs-literal">left</span>))) &#123;<br>               <span class="hljs-literal">left</span> ++<span class="hljs-comment">;</span><br>           &#125;<br>           while (<span class="hljs-literal">left</span> &lt; <span class="hljs-literal">right</span> &amp;&amp; !isValidChar(s.charAt(<span class="hljs-literal">right</span>))) &#123;<br>               <span class="hljs-literal">right</span> --<span class="hljs-comment">;</span><br>           &#125;<br>           if (s.charAt(<span class="hljs-literal">left</span>) != s.charAt(<span class="hljs-literal">right</span>)) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">;</span><br>           &#125;<br>           <span class="hljs-literal">left</span>++<span class="hljs-comment">;</span><br>           <span class="hljs-literal">right</span>--<span class="hljs-comment">;</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br>   &#125;<br><br>   private boolean isValidChar(char x) &#123;<br>       <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || (x &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; x &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || (x &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<span class="hljs-comment">;</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实简单的题目实现起来才是最难的。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeMaximumPathSum</title>
    <link href="/2021/08/31/BinaryTreeMaximumPathSum/"/>
    <url>/2021/08/31/BinaryTreeMaximumPathSum/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/31/BinaryTreeMaximumPathSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/31/BinaryTreeMaximumPathSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树中的最大路径和-1"><a href="#二叉树中的最大路径和-1" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h4><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/exx1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/exx2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 [1,3∗104]</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xquery">int<span class="hljs-built_in"> max</span> = Integer.MIN_VALUE;<br>   public int maxPathSum(TreeNode<span class="hljs-built_in"> root</span>) &#123;<br>       maxGain<span class="hljs-built_in">(root</span>);<br>       <span class="hljs-keyword">return</span><span class="hljs-built_in"> max</span>;<br>   &#125;<br><br>   private int maxGain (TreeNode<span class="hljs-built_in"> root</span>) &#123;<br>       int gain;<br>       int maxPath;<br>       <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span> == null) &#123;<br>           <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.left == null &amp;&amp;<span class="hljs-built_in"> root</span>.right == null) &#123;<br>           gain = maxPath =<span class="hljs-built_in"> root</span>.val;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           int left = Math<span class="hljs-built_in">.max</span>(<span class="hljs-number">0</span>, maxGain<span class="hljs-built_in">(root</span>.left));<br>           int right = Math<span class="hljs-built_in">.max</span>(<span class="hljs-number">0</span>, maxGain<span class="hljs-built_in">(root</span>.right));<br>           maxPath =<span class="hljs-built_in"> root</span>.val + left +right;<br>           gain =<span class="hljs-built_in"> root</span>.val + Math<span class="hljs-built_in">.max</span>(left, right);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (maxPath &gt;<span class="hljs-built_in"> max</span>) &#123;<br>          <span class="hljs-built_in"> max</span> = maxPath;<br>       &#125;<br>       <span class="hljs-keyword">return</span> gain;<br>   &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，需要想通父节点的作用，一个是给上面节点贡献值，一个是自己也有可能是某条路径最大值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BestTimeToBuyAndSellStockII</title>
    <link href="/2021/08/23/BestTimeToBuyAndSellStockII/"/>
    <url>/2021/08/23/BestTimeToBuyAndSellStockII/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/23/BestTimeToBuyAndSellStockII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/23/BestTimeToBuyAndSellStockII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="买卖股票的最佳时机-II-1"><a href="#买卖股票的最佳时机-II-1" class="headerlink" title="买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h4><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>1&lt;&#x3D;prices.length&lt;&#x3D;3∗104</li><li>0&lt;&#x3D;prices[i]&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl">public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">length</span> = prices.<span class="hljs-built_in">length</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">length</span>; i++) &#123;<br>            ans += Math.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，非常简单。只是大晚上写代码好困。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BestTimeToBuyAndSellStock</title>
    <link href="/2021/08/22/BestTimeToBuyAndSellStock/"/>
    <url>/2021/08/22/BestTimeToBuyAndSellStock/</url>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/19/BestTimeToBuyAndSellStock/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/19/BestTimeToBuyAndSellStock/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="买卖股票的最佳时机-1"><a href="#买卖股票的最佳时机-1" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>1&lt;&#x3D;prices.length&lt;&#x3D;105</li><li>0&lt;&#x3D;prices[i]&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl">public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">length</span> = prices.<span class="hljs-built_in">length</span>;<br>        <span class="hljs-type">int</span> minPrice = Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> maxProfit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) &#123;<br>                minPrice = prices[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                maxProfit = Math.<span class="hljs-built_in">max</span>(maxProfit, prices[i] - minPrice);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxProfit;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，非常简单。最近入职新公司了，没时间写算法了，以后996只能抽空写了，好累。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Triangle</title>
    <link href="/2021/08/17/Triangle/"/>
    <url>/2021/08/17/Triangle/</url>
    
    <content type="html"><![CDATA[<h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/17/Triangle/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/17/Triangle/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="三角形最小路径和-1"><a href="#三角形最小路径和-1" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/">三角形最小路径和</a></h4><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong>与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标<code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span><br>输出：<span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li>−104&lt;&#x3D;triangle[i][j]&lt;&#x3D;104</li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> minimumTotal(List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; triangle) &#123;<br><span class="hljs-type">int</span> n = triangle.size();<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        f[<span class="hljs-number">0</span>] = triangle.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + triangle.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">get</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; <span class="hljs-comment">--j) &#123;</span><br>                f[j] = Math.min(f[j - <span class="hljs-number">1</span>], f[j]) + triangle.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">get</span>(j);<br>            &#125;<br>            f[<span class="hljs-number">0</span>] += triangle.<span class="hljs-keyword">get</span>(i).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> minTotal = f[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            minTotal = Math.min(minTotal, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minTotal;<br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，非常简单的一道动态规划。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PascalsTriangleII</title>
    <link href="/2021/08/14/PascalsTriangleII/"/>
    <url>/2021/08/14/PascalsTriangleII/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a>杨辉三角 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/14/PascalsTriangleII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/14/PascalsTriangleII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="杨辉三角-II-1"><a href="#杨辉三角-II-1" class="headerlink" title="杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">杨辉三角 II</a></h4><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: rowIndex = 3</span><br><span class="hljs-section">输出: [1,3,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: rowIndex = 0</span><br><span class="hljs-section">输出: [1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: rowIndex = 1</span><br><span class="hljs-section">输出: [1,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 33</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PascalsTriangleII &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;<span class="hljs-type">Integer</span>&gt; getRow(<span class="hljs-type">int</span> rowIndex) &#123;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; prev = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        prev.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>        List&lt;<span class="hljs-type">Integer</span>&gt; cur = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= rowIndex) &#123;<br>            cur = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (j &lt;= i) &#123;<br>                <span class="hljs-keyword">if</span> (j &lt;= <span class="hljs-number">0</span> || j == i) &#123;<br>                    cur.<span class="hljs-keyword">add</span>(prev.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cur.<span class="hljs-keyword">add</span>(prev.<span class="hljs-keyword">get</span>(j) + prev.<span class="hljs-keyword">get</span>(j - <span class="hljs-number">1</span>));<br>                &#125;<br>                j++;<br>            &#125;<br>            i++;<br>            prev = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getRow(<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。一定要懂杨辉三角的原理。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PascalsTriangle</title>
    <link href="/2021/08/11/PascalsTriangle/"/>
    <url>/2021/08/11/PascalsTriangle/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/11/PascalsTriangle/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/11/PascalsTriangle/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="杨辉三角-1"><a href="#杨辉三角-1" class="headerlink" title="杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/">杨辉三角</a></h4><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: numRows = 5<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: numRows = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PascalsTriangle &#123;<br><br>    // 边界条件很好算，就是<span class="hljs-number">1</span>，其余的不要看三角形，直接顶格对齐，就会发现规律是自己的位置和减一<br>    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; generate(<span class="hljs-type">int</span> numRows) &#123;<br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; rowTemp = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || j == i) &#123;<br>                    rowTemp.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; lastRow = ans.<span class="hljs-keyword">get</span>(i - <span class="hljs-number">1</span>);<br>                    rowTemp.<span class="hljs-keyword">add</span>(lastRow.<span class="hljs-keyword">get</span>(j) + lastRow.<span class="hljs-keyword">get</span>(j - <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            ans.<span class="hljs-keyword">add</span>(rowTemp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。一定要懂杨辉三角的原理。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PopulatingNextRightPointersInEachNodeII</title>
    <link href="/2021/08/07/PopulatingNextRightPointersInEachNodeII/"/>
    <url>/2021/08/07/PopulatingNextRightPointersInEachNodeII/</url>
    
    <content type="html"><![CDATA[<h3 id="填充每个节点的下一个右侧节点指针-II"><a href="#填充每个节点的下一个右侧节点指针-II" class="headerlink" title="填充每个节点的下一个右侧节点指针 II"></a>填充每个节点的下一个右侧节点指针 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/07/PopulatingNextRightPointersInEachNodeII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/07/PopulatingNextRightPointersInEachNodeII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="填充每个节点的下一个右侧节点指针-II-1"><a href="#填充每个节点的下一个右侧节点指针-II-1" class="headerlink" title="填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针 II</a></h4><p>给定一个二叉树</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例 ：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/117_sample.png" alt="img"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-meta">#,2,3,#,4,5,7,#]</span><br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="hljs-keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 <span class="hljs-keyword">next</span> 指针连接），<span class="hljs-string">&#x27;#&#x27;</span> 表示每层的末尾。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">package algorithm;<br><br>public class PopulatingNextRightPointersInEachNodeII &#123;<br><br>    <span class="hljs-keyword">Node</span> <span class="hljs-title">last</span> = null, nextStart = null;<br><br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">connect</span>(<span class="hljs-keyword">Node</span> <span class="hljs-title">root</span>) &#123;<br>        if (root == null) &#123;<br>            return null;<br>        &#125;<br>        <span class="hljs-keyword">Node</span> <span class="hljs-title">start</span> = root;<br>        while (<span class="hljs-literal">start</span> != null) &#123;<br>            last = null;<br>            nextStart = null;<br>            for (<span class="hljs-keyword">Node</span> <span class="hljs-title">p</span> = <span class="hljs-literal">start</span>; p != null; p = p.next) &#123;<br>                if (p.left != null) &#123;<br>                    handle(p.left);<br>                &#125;<br>                if (p.right != null) &#123;<br>                    handle(p.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-literal">start</span> = nextStart;<br>        &#125;<br>        return root;<br>    &#125;<br><br>    public void handle(<span class="hljs-keyword">Node</span> <span class="hljs-title">p</span>) &#123;<br>        if (last != null) &#123;<br>            last.next = p;<br>        &#125;<br>        if (nextStart == null) &#123;<br>            nextStart = p;<br>        &#125;<br>        last = p;<br>    &#125;<br><br>    class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">        public</span> int val;<br>        public <span class="hljs-keyword">Node</span> <span class="hljs-title">left</span>;<br>        public <span class="hljs-keyword">Node</span> <span class="hljs-title">right</span>;<br>        public <span class="hljs-keyword">Node</span> <span class="hljs-title">next</span>;<br><br>        public <span class="hljs-keyword">Node</span><span class="hljs-title">() &#123;&#125;</span><br><span class="hljs-title"></span><br><span class="hljs-title">        public</span> <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> _val) &#123;<br>            val = _val;<br>        &#125;<br><br>        public <span class="hljs-keyword">Node</span><span class="hljs-title">(int</span> _val, <span class="hljs-keyword">Node</span> <span class="hljs-title">_left</span>, <span class="hljs-keyword">Node</span> <span class="hljs-title">_right</span>, <span class="hljs-keyword">Node</span> <span class="hljs-title">_next</span>) &#123;<br>            val = _val;<br>            left = _left;<br>            right = _right;<br>            next = _next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实是利用两个节点承载前后关系。受上题影响，居然没写出来，哎。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PopulatingNextRightPointersInEachNode</title>
    <link href="/2021/08/04/PopulatingNextRightPointersInEachNode/"/>
    <url>/2021/08/04/PopulatingNextRightPointersInEachNode/</url>
    
    <content type="html"><![CDATA[<h3 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/04/PopulatingNextRightPointersInEachNode/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/04/PopulatingNextRightPointersInEachNode/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="填充每个节点的下一个右侧节点指针-1"><a href="#填充每个节点的下一个右侧节点指针-1" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></h4><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例 ：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/116_sample.png" alt="img"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-meta">#,2,3,#,4,5,6,7,#]</span><br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="hljs-keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 <span class="hljs-keyword">next</span> 指针连接，<span class="hljs-string">&#x27;#&#x27;</span> 标志着每一层的结束。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量少于 <code>4096</code></li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PopulatingNextRightPointersInEachNode</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Node connect(Node root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-comment">// 从根节点开</span><br>        Node leftmost = root;<br><br>        <span class="hljs-keyword">while</span> (leftmost.left != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span><br>            Node head = leftmost;<br><br>            <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br><br>                <span class="hljs-comment">// CONNECTION 1</span><br>                head.left.<span class="hljs-keyword">next</span> = head.right;<br><br>                <span class="hljs-comment">// CONNECTION 2</span><br>                <span class="hljs-keyword">if</span> (head.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>                    head.right.<span class="hljs-keyword">next</span> = head.<span class="hljs-keyword">next</span>.left;<br>                &#125;<br><br>                <span class="hljs-comment">// 指针向后移动</span><br>                head = head.<span class="hljs-keyword">next</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 去下一层的最左的节点</span><br>            leftmost = leftmost.left;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br>        <span class="hljs-keyword">public</span> Node left;<br>        <span class="hljs-keyword">public</span> Node right;<br>        <span class="hljs-keyword">public</span> Node <span class="hljs-keyword">next</span>;<br><br>        <span class="hljs-keyword">public</span> Node() &#123;&#125;<br><br>        <span class="hljs-keyword">public</span> Node(<span class="hljs-built_in">int</span> _val) &#123;<br>            val = _val;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Node(<span class="hljs-built_in">int</span> _val, Node _left, Node _right, Node _next) &#123;<br>            val = _val;<br>            left = _left;<br>            right = _right;<br>            <span class="hljs-keyword">next</span> = _next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，利用完美二叉树特点和上层已经链接的线索，这道题这么简单，看了答案，看来编程需要努力。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DistinctSubsequences</title>
    <link href="/2021/08/01/DistinctSubsequences/"/>
    <url>/2021/08/01/DistinctSubsequences/</url>
    
    <content type="html"><![CDATA[<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><ul><li><a href="https://yangtzeshore.github.io/2021/08/01/DistinctSubsequences/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/08/01/DistinctSubsequences/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同的子序列-1"><a href="#不同的子序列-1" class="headerlink" title="不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h4><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;rabbbit&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;rabbit&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">3</span> 种可以从 s 中得到 <span class="hljs-string">&quot;rabbit&quot;</span> 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：s = <span class="hljs-string">&quot;babgbag&quot;</span>, t = <span class="hljs-string">&quot;bag&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br>如下图所示, 有 <span class="hljs-number">5</span> 种可以从 s 中得到 <span class="hljs-string">&quot;bag&quot;</span> 的方案。 <br><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">babgbag</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DistinctSubsequences &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> numDistinct(String s, String t) &#123;<br>        <span class="hljs-type">int</span> m = t.length();<br>        <span class="hljs-type">int</span> n = s.length();<br>        <span class="hljs-type">int</span>[][] <span class="hljs-keyword">array</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        Arrays.fill(<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(j - <span class="hljs-number">1</span>) == t.charAt(i - <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">array</span>[i][j] = <span class="hljs-keyword">array</span>[i][j - <span class="hljs-number">1</span>] + <span class="hljs-keyword">array</span>[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">array</span>[i][j] = <span class="hljs-keyword">array</span>[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>[m][n];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        numDistinct(&quot;rabbbit&quot;, &quot;rabbit&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单。动态规划。不过我的效率一般，需要优化。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FlattenBinaryTreeToLinkedList</title>
    <link href="/2021/07/31/FlattenBinaryTreeToLinkedList/"/>
    <url>/2021/07/31/FlattenBinaryTreeToLinkedList/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/31/FlattenBinaryTreeToLinkedList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/31/FlattenBinaryTreeToLinkedList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树展开为链表-1"><a href="#二叉树展开为链表-1" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/flaten.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlattenBinaryTreeToLinkedList</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        queue.clear();<br>        dfs(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">lamb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">while</span> (queue.size() &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            node.left = <span class="hljs-literal">null</span>;<br>            node.right = <span class="hljs-literal">null</span>;<br>            lamb.right = node;<br>            lamb = lamb.right;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        queue.offer(root);<br>        dfs(root.left);<br>        dfs(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 1,2,3,3,4,4,5</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n2.left = n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>        n2.right = n5;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>);<br>        n3.right = n6;<br><br>        flatten(n1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单。效率当然也是一般。后续有时间可以优化一下思路。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PathSum</title>
    <link href="/2021/07/26/PathSum/"/>
    <url>/2021/07/26/PathSum/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/26/PathSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/26/PathSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="路径总和-1"><a href="#路径总和-1" class="headerlink" title="路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></h4><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], targetSum = <span class="hljs-number">5</span><br>输出<span class="hljs-built_in">：false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], targetSum = <span class="hljs-number">0</span><br>输出<span class="hljs-built_in">：false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PathSum</span> &#123;<br><br>    <span class="hljs-keyword">private</span> boolean flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> boolean hasPathSum(TreeNode root, int targetSum) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        dfs(root, targetSum, root.<span class="hljs-keyword">val</span>);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void dfs(TreeNode root, int targetSum, int sumTemp) &#123;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sumTemp == targetSum) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            dfs(root.left, targetSum, sumTemp + root.left.<span class="hljs-keyword">val</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            dfs(root.right, targetSum, sumTemp + root.right.<span class="hljs-keyword">val</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，递归调用分解问题。对于递归的理解需要加强。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumDepthOfBinaryTree</title>
    <link href="/2021/07/25/MinimumDepthOfBinaryTree/"/>
    <url>/2021/07/25/MinimumDepthOfBinaryTree/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/25/MinimumDepthOfBinaryTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/25/MinimumDepthOfBinaryTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/balance_1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数的范围在 [0,105] 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinimumDepthOfBinaryTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> int minDepth(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        int min_depth = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            min_depth = Math.min(minDepth(root.left), min_depth);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            min_depth = Math.min(minDepth(root.right), min_depth);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min_depth + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，递归调用分解问题。对于递归的理解需要加强。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BalancedBinaryTree</title>
    <link href="/2021/07/19/BalancedBinaryTree/"/>
    <url>/2021/07/19/BalancedBinaryTree/</url>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/19/BalancedBinaryTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/19/BalancedBinaryTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/balance_1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/balance_2.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = []<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li>−104&lt;&#x3D;Node.val&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BalancedBinaryTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> boolean isBalanced(TreeNode root) &#123;<br>        <span class="hljs-keyword">return</span> dfs(root);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> boolean dfs(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        int left = deep(root.left);<br>        int right = deep(root.right);<br>        <span class="hljs-keyword">if</span> (Math.abs(left - right) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dfs(root.left)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dfs(root.right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> int deep(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        int left = deep(root.left) + <span class="hljs-number">1</span>;<br>        int right = deep(root.right) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> Math.max(left, right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，两次递归。先遍历，然后找出相应节点的深度。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConvertSortedListToBinarySearchTree</title>
    <link href="/2021/07/18/ConvertSortedListToBinarySearchTree/"/>
    <url>/2021/07/18/ConvertSortedListToBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h3 id="有序链表转换二叉搜索树"><a href="#有序链表转换二叉搜索树" class="headerlink" title="有序链表转换二叉搜索树"></a>有序链表转换二叉搜索树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/18/ConvertSortedListToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/18/ConvertSortedListToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="有序链表转换二叉搜索树-1"><a href="#有序链表转换二叉搜索树-1" class="headerlink" title="有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定的有序链表： [<span class="hljs-string">-10</span>, <span class="hljs-string">-3</span>, 0, 5, 9],<br><br>一个可能的答案是：[0, <span class="hljs-string">-3</span>, 9, <span class="hljs-string">-10</span>, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br><br>      0<br>     / \<br>   <span class="hljs-string">-3</span>   9<br>   /   /<br> <span class="hljs-string">-10</span>  5<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConvertSortedListToBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-keyword">return</span> dfs(dummy, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(ListNode left, ListNode right)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-keyword">while</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next != right) &#123;<br>            cur = cur.next;<br><br>            next = next.next;<br>            <span class="hljs-keyword">if</span> (next == right || next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next = next.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(cur.val);<br>        <span class="hljs-keyword">if</span> (left.next != cur) &#123;<br>            root.left = dfs(left, cur);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.next != right) &#123;<br>            root.right = dfs(cur, right);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">3</span>);<br>        n1.next = n2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> n1.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        n2.next = n3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n3.next = n4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">9</span>);<br>        n4.next = n5;<br>        sortedListToBST(n1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实借鉴了之前的算法题。也很简单，如果是用递归的话。就是链表调试麻烦。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConvertSortedArrayToBinarySearchTree</title>
    <link href="/2021/07/17/ConvertSortedArrayToBinarySearchTree/"/>
    <url>/2021/07/17/ConvertSortedArrayToBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/17/ConvertSortedArrayToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/17/ConvertSortedArrayToBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="将有序数组转换为二叉搜索树-1"><a href="#将有序数组转换为二叉搜索树-1" class="headerlink" title="将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/btree1.jpg" alt="img"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9]<br>输出：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br>解释：[0,<span class="hljs-string">-10</span>,5,null,<span class="hljs-string">-3</span>,null,9] 也将被视为正确答案：<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/btree2.jpg" alt="img"></p><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/btree.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3]</span><br>输出：<span class="hljs-comment">[3,1]</span><br>解释：<span class="hljs-comment">[1,3]</span> 和 <span class="hljs-comment">[3,1]</span> 都是高度平衡二叉搜索树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;104</li><li>−104&lt;&#x3D;nums[i]&lt;&#x3D;104</li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConvertSortedArrayToBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> dfs(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left +right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> nums[mid];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root);<br>        node.left = dfs(nums, left, mid - <span class="hljs-number">1</span>);<br>        node.right = dfs(nums, mid +<span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实借鉴了之前的算法题。也很简单，如果是用递归的话。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeLevelOrderTraversalII</title>
    <link href="/2021/07/16/BinaryTreeLevelOrderTraversalII/"/>
    <url>/2021/07/16/BinaryTreeLevelOrderTraversalII/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的层序遍历-II"><a href="#二叉树的层序遍历-II" class="headerlink" title="二叉树的层序遍历 II"></a>二叉树的层序遍历 II</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/16/BinaryTreeLevelOrderTraversalII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/16/BinaryTreeLevelOrderTraversalII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的层序遍历-II-1"><a href="#二叉树的层序遍历-II-1" class="headerlink" title="二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历 II</a></h4><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其自底向上的层序遍历为：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeLevelOrderTraversalII</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                temp.add(node.val);<br><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(node.right);<br>                &#125;<br>            &#125;<br>            ans.add(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(temp));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">9</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">20</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">15</span>);<br>        n2.left = <span class="hljs-literal">null</span>;<br>        n2.right = <span class="hljs-literal">null</span>;<br>        n3.left = n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">7</span>);<br>        n3.right = n5;<br><br>        levelOrderBottom(n1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实和z字形很类似。只不过借助于java的api实现头插入。以后可以试试Go或者C的写法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConstructBinaryTreeFromInorderAndPostorderTraversal</title>
    <link href="/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/"/>
    <url>/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/15/ConstructBinaryTreeFromInorderAndPostorderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="从中序与后序遍历序列构造二叉树-1"><a href="#从中序与后序遍历序列构造二叉树-1" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>后序遍历 postorder = <span class="hljs-string">[9,15,7,20,3]</span><br></code></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructBinaryTreeFromInorderAndPostorderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; map;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(inorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder, <span class="hljs-type">int</span> inorderLeft, <span class="hljs-type">int</span> inorderRight,</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> postOrderLeft, <span class="hljs-type">int</span> postOrderRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (inorderLeft &gt; inorderRight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> postorder[postOrderRight];<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> map.get(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftSubTreeSize</span> <span class="hljs-operator">=</span> index - inorderLeft;<br><br>        rootNode.left = dfs(inorder, postorder, inorderLeft, index - <span class="hljs-number">1</span>,<br>                postOrderLeft, postOrderLeft + leftSubTreeSize - <span class="hljs-number">1</span>);<br>        rootNode.right = dfs(inorder, postorder, inorderLeft + leftSubTreeSize + <span class="hljs-number">1</span>, inorderRight,<br>                postOrderLeft + leftSubTreeSize, postOrderRight - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> rootNode;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，寻找根的节点位置，利用节点值唯一的特性。然后，递归构造树结构。其实也是抄上一道题的思路。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ConstructBinaryTreeFromPreorderAndInorderTraversal</title>
    <link href="/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/"/>
    <url>/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/14/ConstructBinaryTreeFromPreorderAndInorderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="从前序与中序遍历序列构造二叉树-1"><a href="#从前序与中序遍历序列构造二叉树-1" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a></h4><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/tree.jpg" alt="img"></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">Input</span>: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br><span class="hljs-keyword">Output</span>: [3,9,20,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,15,7]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span><br>Output: <span class="hljs-comment">[-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> 保证为二叉树的前序遍历序列</li><li><code>inorder</code> 保证为二叉树的中序遍历序列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConstructBinaryTreeFromPreorderAndInorderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span> preorderLeft, <span class="hljs-type">int</span> preorderRight,</span><br><span class="hljs-params">                                <span class="hljs-type">int</span> inorderLeft, <span class="hljs-type">int</span> inorderRight)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preorderLeft &gt; preorderRight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">preorderRoot</span> <span class="hljs-operator">=</span> preorderLeft;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">inorderRoot</span> <span class="hljs-operator">=</span> indexMap.get(preorder[preorderRoot]);<br><br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preorderRoot]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sizeLeftSubtree</span> <span class="hljs-operator">=</span> inorderRoot - inorderLeft;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder, inorder,preorderLeft + <span class="hljs-number">1</span>,<br>                preorderLeft + sizeLeftSubtree, inorderLeft, inorderRoot - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder, inorder, preorderLeft + sizeLeftSubtree + <span class="hljs-number">1</span>,<br>                            preorderRight, inorderRoot + <span class="hljs-number">1</span>, inorderRight);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span><br>        indexMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap.put(inorder[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，寻找根的节点位置，利用节点值唯一的特性。然后，递归构造树结构。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeZigzagLevelOrderTraversal</title>
    <link href="/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/"/>
    <url>/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/11/BinaryTreeZigzagLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的锯齿形层序遍历-1"><a href="#二叉树的锯齿形层序遍历-1" class="headerlink" title="二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[20,9]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeZigzagLevelOrderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; nodeQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        nodeQueue.offer(root);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isOrderLeft</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">while</span> (!nodeQueue.isEmpty()) &#123;<br>            Deque&lt;Integer&gt; levelList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nodeQueue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>                <span class="hljs-comment">// 从头取</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curNode</span> <span class="hljs-operator">=</span> nodeQueue.poll();<br>                <span class="hljs-keyword">if</span> (isOrderLeft) &#123;<br>                    levelList.offerLast(curNode.val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    levelList.offerFirst(curNode.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (curNode.left != <span class="hljs-literal">null</span>) &#123;<br>                    nodeQueue.offer(curNode.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (curNode.right != <span class="hljs-literal">null</span>) &#123;<br>                    nodeQueue.offer(curNode.right);<br>                &#125;<br>            &#125;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(levelList));<br>            isOrderLeft = !isOrderLeft;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>        n2.left = n4;<br>        n2.right = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>        n3.right = n5;<br>        n3.left = <span class="hljs-literal">null</span>;<br><br>        List&lt;List&lt;Integer&gt;&gt; lists = zigzagLevelOrder(n1);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : lists) &#123;<br>            <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>                System.out.print(integer + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，利用了java的linkedqueue的队列特性，而且是两个队列。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeLevelOrderTraversal</title>
    <link href="/2021/07/10/BinaryTreeLevelOrderTraversal/"/>
    <url>/2021/07/10/BinaryTreeLevelOrderTraversal/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/10/BinaryTreeLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/10/BinaryTreeLevelOrderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的层序遍历-1"><a href="#二叉树的层序遍历-1" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong></p><p>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层序遍历结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeLevelOrderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>        union(root, <span class="hljs-number">0</span>);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;<br>            List&lt;Integer&gt; value = entry.getValue();<br>            ans.add(value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.get(count) == <span class="hljs-literal">null</span>) &#123;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            list.add(root.val);<br>            map.put(count, list);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;Integer&gt; list = map.get(count);<br>            list.add(root.val);<br>        &#125;<br>        union(root.left, count + <span class="hljs-number">1</span>);<br>        union(root.right, count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">9</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">20</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">15</span>);<br>        n3.left =n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">7</span>);<br>        n3.right = n5;<br><br>        List&lt;List&lt;Integer&gt;&gt; lists = levelOrder(n1);<br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; list : lists) &#123;<br>            <span class="hljs-keyword">for</span> (Integer integer : list) &#123;<br>                System.out.print(integer + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">9 </span><span class="hljs-number">20</span> <br><span class="hljs-symbol">15 </span><span class="hljs-number">7</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单了，就是增加深度这个维度，最后统计出来。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SymmetricTree</title>
    <link href="/2021/07/09/SymmetricTree/"/>
    <url>/2021/07/09/SymmetricTree/</url>
    
    <content type="html"><![CDATA[<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/09/SymmetricTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/09/SymmetricTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="对称二叉树-1"><a href="#对称二叉树-1" class="headerlink" title="对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">1</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymmetricTree</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root.left, root.right)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> &amp;&amp; q == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(p != <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (dfs(p.left, q.right) &amp;&amp; p.val == q.val) &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">dfs</span><span class="hljs-params">(p.right, q.left)</span></span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">check</span><span class="hljs-params">(root, root)</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode u, TreeNode v)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        q.offer(u);<br>        q.offer(v);<br>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>            u = q.poll();<br>            v = q.poll();<br>            <span class="hljs-keyword">if</span> (u == <span class="hljs-keyword">null</span> &amp;&amp; v == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((u == <span class="hljs-keyword">null</span> || v == <span class="hljs-keyword">null</span>) || (u.val != v.val)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            q.offer(u.left);<br>            q.offer(v.right);<br><br>            q.offer(u.right);<br>            q.offer(v.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-keyword">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-keyword">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，很简单了，就是递归比对。如果是迭代，需要栈来承载比对的数据。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SameTree</title>
    <link href="/2021/07/08/SameTree/"/>
    <url>/2021/07/08/SameTree/</url>
    
    <content type="html"><![CDATA[<h4 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/08/SameTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/08/SameTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="相同的树-1"><a href="#相同的树-1" class="headerlink" title="相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></h4><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ex1.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,3]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,2,3]</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,null,2]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ex3.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">p</span> = <span class="hljs-selector-attr">[1,2,1]</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-selector-attr">[1,1,2]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li>−104&lt;&#x3D;Node.val&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SameTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static boolean isSameTree(TreeNode p, TreeNode q) &#123;<br>        <span class="hljs-keyword">return</span> dfs(p, q);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static boolean dfs(TreeNode p, TreeNode q) &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span> &amp;&amp; p.<span class="hljs-keyword">val</span> == q.<span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dfs(p.left, q.left)) &#123;<br>                <span class="hljs-keyword">return</span> dfs(p.right, q.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，中序遍历，然后挨个判断，非常简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RecoverBinarySearchTree</title>
    <link href="/2021/07/06/RecoverBinarySearchTree/"/>
    <url>/2021/07/06/RecoverBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h3 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h3><ul><li><a href="https://yangtzeshore.github.io/2021/07/06/RecoverBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/06/RecoverBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="恢复二叉搜索树-1"><a href="#恢复二叉搜索树-1" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">恢复二叉搜索树</a></h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p><strong>进阶：</strong>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/recover1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是<span class="hljs-number"> 1 </span>左孩子，因为<span class="hljs-number"> 3 </span>&gt;<span class="hljs-number"> 1 </span>。交换<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>使二叉搜索树有效。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/recover2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [3,1,4,null,null,2]<br>输出：[2,1,4,null,null,3]<br>解释：2 不能在<span class="hljs-number"> 3 </span>的右子树中，因为<span class="hljs-number"> 2 </span>&lt;<span class="hljs-number"> 3 </span>。交换<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>使二叉搜索树有效。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecoverBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> void recoverTree(TreeNode root) &#123;<br><br>        TreeNode x = <span class="hljs-literal">null</span>, y = <span class="hljs-literal">null</span>, pred = <span class="hljs-literal">null</span>, predecessor;<br><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span><br>                predecessor = root.left;<br>                <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-literal">null</span> &amp;&amp; predecessor.right != root) &#123;<br>                    predecessor = predecessor.right;<br>                &#125;<br><br>                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span><br>                <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-literal">null</span>) &#123;<br>                    predecessor.right = root;<br>                    root = root.left;<br>                &#125;<br>                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span><br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-keyword">val</span> &lt; pred.<span class="hljs-keyword">val</span>) &#123;<br>                        y = root;<br>                        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                            x = pred;<br>                        &#125;<br>                    &#125;<br>                    pred = root;<br><br>                    predecessor.right = <span class="hljs-literal">null</span>;<br>                    root = root.right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-keyword">val</span> &lt; pred.<span class="hljs-keyword">val</span>) &#123;<br>                    y = root;<br>                    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                        x = pred;<br>                    &#125;<br>                &#125;<br>                pred = root;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        swap(x, y);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> void swap(TreeNode x, TreeNode y) &#123;<br>        int tmp = x.<span class="hljs-keyword">val</span>;<br>        x.<span class="hljs-keyword">val</span> = y.<span class="hljs-keyword">val</span>;<br>        y.<span class="hljs-keyword">val</span> = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>        &#125;<br><br>        TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，可定都会想到中序遍历了，无论是递归还是非递归都是不会常数空间复杂度的。morris遍历，是进阶题解的方法。目前对于Morris算法不是和熟悉，需要多联系。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidateBinarySearchTree</title>
    <link href="/2021/07/06/ValidateBinarySearchTree/"/>
    <url>/2021/07/06/ValidateBinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/04/ValidateBinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/04/ValidateBinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="验证二叉搜索树-1"><a href="#验证二叉搜索树-1" class="headerlink" title="验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br>解释: 输入为: [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]。<br>     根节点的值为 <span class="hljs-number">5</span> ，但是其右子节点值为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidateBinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> upper)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.val &lt;= lower || node.val &gt;= upper) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        n1.left = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n1.right = n3;<br><br>        System.out.println(isValidBST(n1));<br><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        n1.left = n2;<br>        n3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>        n1.right = n3;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n3.left = n4;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">6</span>);<br>        n3.right = n5;<br>        System.out.println(isValidBST(n1));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，递归判断range。中序遍历是第一个想到的，可能比较抽象了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InterleavingString</title>
    <link href="/2021/07/03/InterleavingString/"/>
    <url>/2021/07/03/InterleavingString/</url>
    
    <content type="html"><![CDATA[<h4 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/03/InterleavingString/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/03/InterleavingString/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="交错字符串-1"><a href="#交错字符串-1" class="headerlink" title="交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串</a></h4><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p><p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p><ul><li><code>s = s1 + s2 + ... + sn</code></li><li><code>t = t1 + t2 + ... + tm</code></li><li><code>|n - m| &lt;= 1</code></li><li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li></ul><p><strong>提示：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/interleave.jpg" alt="img"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbcbcac&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbbaccc&quot;</span><br>输出：falsexxxxxxxxxx 输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbbaccc&quot;</span>输出：false输入：n = <span class="hljs-number">1</span>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li><li><code>0 &lt;= s3.length &lt;= 200</code></li><li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterleavingString</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(<span class="hljs-type">String</span> s1, <span class="hljs-type">String</span> s2, <span class="hljs-type">String</span> s3)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> n = s<span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> m = s<span class="hljs-number">2.l</span>ength();<br>        <span class="hljs-type">int</span> t = s<span class="hljs-number">3.l</span>ength();<br><br>        <span class="hljs-keyword">if</span> (n + m != t) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 注意索引从0开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-type">int</span> p = i + j - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 主要是i和j可能都大于1，这是需要或</span><br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = f[i][j] || (f[i - <span class="hljs-number">1</span>][j] &amp;&amp; s<span class="hljs-number">1.</span><span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == s<span class="hljs-number">3.</span><span class="hljs-built_in">charAt</span>(p));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                    f[i][j] = f[i][j] || (f[i][j - <span class="hljs-number">1</span>] &amp;&amp; s<span class="hljs-number">2.</span><span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>) == s<span class="hljs-number">3.</span><span class="hljs-built_in">charAt</span>(p));<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span> s1 = <span class="hljs-string">&quot;aabcc&quot;</span>;<br>        <span class="hljs-type">String</span> s2 = <span class="hljs-string">&quot;dbbca&quot;</span>;<br>        <span class="hljs-type">String</span> s3 = <span class="hljs-string">&quot;aadbbcbcac&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isInterleave</span>(s1, s2, s3));<br><br>        s3 = <span class="hljs-string">&quot;aadbbbaccc&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isInterleave</span>(s1, s2, s3));<br><br>        s1 = <span class="hljs-string">&quot;&quot;</span>;<br>        s2 = <span class="hljs-string">&quot;&quot;</span>;<br>        s3 = <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isInterleave</span>(s1, s2, s3));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，动态规划。主要是要注意边界为0的情况。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniqueBinarySearchTrees</title>
    <link href="/2021/07/01/UniqueBinarySearchTrees/"/>
    <url>/2021/07/01/UniqueBinarySearchTrees/</url>
    
    <content type="html"><![CDATA[<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><ul><li><a href="https://yangtzeshore.github.io/2021/07/01/UniqueBinarySearchTrees/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/07/01/UniqueBinarySearchTrees/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同的二叉搜索树-1"><a href="#不同的二叉搜索树-1" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h4><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/uniquebstn3.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UniqueBinarySearchTrees</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">numTrees</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br><br>        <span class="hljs-built_in">int</span>[] G = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];<br>        G[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                G[i] += G[j - <span class="hljs-number">1</span>] * G[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> G[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        System.<span class="hljs-keyword">out</span>.println(numTrees(<span class="hljs-number">3</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numTrees(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，动态规划了。数学确实是工具，官方题解二的卡特兰数确实也厉害。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniqueBinarySearchTreesII</title>
    <link href="/2021/06/29/UniqueBinarySearchTreesII/"/>
    <url>/2021/06/29/UniqueBinarySearchTreesII/</url>
    
    <content type="html"><![CDATA[<h4 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/29/UniqueBinarySearchTreesII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/29/UniqueBinarySearchTreesII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同的二叉搜索树-II-1"><a href="#不同的二叉搜索树-II-1" class="headerlink" title="不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h4><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/uniquebstn3.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniqueBinarySearchTreesII</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateTrees</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        List&lt;TreeNode&gt; allTrees = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>            allTrees.<span class="hljs-built_in">add</span>(null);<br>            <span class="hljs-keyword">return</span> allTrees;<br>        &#125;<br><br>        <span class="hljs-comment">// 枚举可行根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// 获得所有可行的左子树集合</span><br>            List&lt;TreeNode&gt; leftTrees = <span class="hljs-built_in">generateTrees</span>(start, i - <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 获得所有可行的右子树集合</span><br>            List&lt;TreeNode&gt; rightTrees = <span class="hljs-built_in">generateTrees</span>(i + <span class="hljs-number">1</span>, end);<br><br>            <span class="hljs-comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span><br>            <span class="hljs-keyword">for</span> (TreeNode left : leftTrees) &#123;<br>                <span class="hljs-keyword">for</span> (TreeNode right : rightTrees) &#123;<br>                    TreeNode currTree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>                    currTree.left = left;<br>                    currTree.right = right;<br>                    allTrees.<span class="hljs-built_in">add</span>(currTree);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> allTrees;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-built_in">generateTrees</span>(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">generateTrees</span>(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        <span class="hljs-built_in">TreeNode</span>() &#123;<br>        &#125;<br><br>        <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.left = left;<br>            <span class="hljs-keyword">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，面向答案编程。其实分左右递归答案我是想出来了，但是怎么合并和返回没想好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BinaryTreeInorderTraversal</title>
    <link href="/2021/06/27/BinaryTreeInorderTraversal/"/>
    <url>/2021/06/27/BinaryTreeInorderTraversal/</url>
    
    <content type="html"><![CDATA[<h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/27/BinaryTreeInorderTraversal/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/27/BinaryTreeInorderTraversal/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉树的中序遍历-1"><a href="#二叉树的中序遍历-1" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></h4><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/inorder_1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/inorder_4.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/inorder_5.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTreeInorderTraversal</span> &#123;<br><br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        ans.add(root.val);<br>        dfs(root.right);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n1.left = <span class="hljs-literal">null</span>;<br>        n1.right = n2;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>        n2.left = n3;<br>        System.out.println(Arrays.toString(inorderTraversal(n1).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        System.out.println(Arrays.toString(inorderTraversal(n4).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        System.out.println(Arrays.toString(inorderTraversal(n5).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>((<span class="hljs-number">2</span>));<br>        n6.left = n7;<br>        System.out.println(Arrays.toString(inorderTraversal(n6).toArray()));<br>        ans.clear();<br><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">n9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>        n8.right = n9;<br>        System.out.println(Arrays.toString(inorderTraversal(n8).toArray()));<br>        ans.clear();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode() &#123;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1, 3, 2]</span><br><span class="hljs-string">[]</span><br><span class="hljs-string">[1]</span><br><span class="hljs-string">[2, 1]</span><br><span class="hljs-string">[1, 2]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，太简单了。我决定下次面试的时候，让候选者写一个。确实不难，而且也能判断这个人是否写过代码。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RestoreIpAddresses</title>
    <link href="/2021/06/27/RestoreIpAddresses/"/>
    <url>/2021/06/27/RestoreIpAddresses/</url>
    
    <content type="html"><![CDATA[<h4 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/26/RestoreIpAddresses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/26/RestoreIpAddresses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="复原-IP-地址-1"><a href="#复原-IP-地址-1" class="headerlink" title="复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原 IP 地址</a></h4><p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 <code>s</code> 获得的 <strong>有效 IP 地址</strong> 。你可以按任何顺序返回答案。</p><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 <strong>有效</strong> IP 地址，但是”0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#64;&#x31;&#x2e;&#x31;">&#x31;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#64;&#x31;&#x2e;&#x31;</a>” 是 <strong>无效</strong> IP 地址。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span><br>输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0000&quot;</span><br>输出：[<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span><br>输出：[<span class="hljs-string">&quot;1.1.1.1&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;010010&quot;</span><br>输出：[<span class="hljs-string">&quot;0.10.0.10&quot;</span>,<span class="hljs-string">&quot;0.100.1.0&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;101023&quot;</span><br>输出：[<span class="hljs-string">&quot;1.0.10.23&quot;</span>,<span class="hljs-string">&quot;1.0.102.3&quot;</span>,<span class="hljs-string">&quot;10.1.0.23&quot;</span>,<span class="hljs-string">&quot;10.10.2.3&quot;</span>,<span class="hljs-string">&quot;101.0.2.3&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 3000</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestoreIpAddresses</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEG_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SEG_COUNT];<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>        segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[SEG_COUNT];<br>        dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> segId, <span class="hljs-type">int</span> segStart)</span> &#123;<br>        <span class="hljs-comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span><br>        <span class="hljs-keyword">if</span> (segId == SEG_COUNT) &#123;<br>            <span class="hljs-keyword">if</span> (segStart == s.length()) &#123;<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ipAddr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SEG_COUNT; ++i) &#123;<br>                    ipAddr.append(segments[i]);<br>                    <span class="hljs-keyword">if</span> (i != SEG_COUNT - <span class="hljs-number">1</span>) &#123;<br>                        ipAddr.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                    &#125;<br>                &#125;<br>                ans.add(ipAddr.toString());<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span><br>        <span class="hljs-keyword">if</span> (segStart == s.length()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span><br>        <span class="hljs-keyword">if</span> (s.charAt(segStart) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            segments[segId] = <span class="hljs-number">0</span>;<br>            dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 一般情况，枚举每一种可能性并递归</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">segEnd</span> <span class="hljs-operator">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;<br>            addr = addr * <span class="hljs-number">10</span> + (s.charAt(segEnd) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span>) &#123;<br>                segments[segId] = addr;<br>                dfs(s, segId + <span class="hljs-number">1</span>, segEnd + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">255.255.11.135</span>, <span class="hljs-number">255.255.111.35</span>]<br>[<span class="hljs-number">0.0.0.0</span>]<br>[<span class="hljs-number">1.1.1.1</span>]<br>[<span class="hljs-number">0.10.0.10</span>, <span class="hljs-number">0.100.1.0</span>]<br>[<span class="hljs-number">1.0.10.23</span>, <span class="hljs-number">1.0.102.3</span>, <span class="hljs-number">10.1.0.23</span>, <span class="hljs-number">10.10.2.3</span>, <span class="hljs-number">101.0.2.3</span>]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，面向答案编程。虽然想到了大致的思路，但是dfs一致是弱项，最近算法写的都很烂，看来这一段时间的题目，都只能积累了，单凭简单的训练还是不够的。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ReverseLinkedListII</title>
    <link href="/2021/06/24/ReverseLinkedListII/"/>
    <url>/2021/06/24/ReverseLinkedListII/</url>
    
    <content type="html"><![CDATA[<h4 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/24/ReverseLinkedListII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/24/ReverseLinkedListII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="反转链表-II-1"><a href="#反转链表-II-1" class="headerlink" title="反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></h4><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/rev2ex2.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3,4,5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[1,4,3,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[5]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span><br>输出：<span class="hljs-selector-attr">[5]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目为 <code>n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-500 &lt;= Node.val &lt;= 500</code></li><li><code>1 &lt;= left &lt;= right &lt;= n</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseLinkedListII</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode reverseBetween(ListNode head, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right) &#123;<br><br>        <span class="hljs-comment">// 设置 dummyNode 是这一类问题的一般做法</span><br>        ListNode dummyNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>        dummyNode.<span class="hljs-keyword">next</span> = head;<br>        ListNode pre = dummyNode;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        ListNode cur = pre.<span class="hljs-keyword">next</span>;<br>        ListNode <span class="hljs-keyword">next</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>            <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>            cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;<br>            pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.<span class="hljs-keyword">next</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        ListNode n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode n2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        n1.<span class="hljs-keyword">next</span> = n2;<br>        ListNode n3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        n2.<span class="hljs-keyword">next</span> = n3;<br>        ListNode n4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        n3.<span class="hljs-keyword">next</span> = n4;<br>        ListNode n5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        n4.<span class="hljs-keyword">next</span> = n5;<br><br>        <span class="hljs-keyword">print</span>(reverseBetween(n1, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br><br>        n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">print</span>(reverseBetween(n1, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>-&gt;<br><span class="hljs-number">5</span>-&gt;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，虽然想的差不多，但是做出来，还是差的很远。尤其是，如果不切断链条，可能是出现环或者不好拼接。官方给出的解法二，三个指针，不断的将后续的节点往前抛，确实很厉害。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DecodeWays</title>
    <link href="/2021/06/22/DecodeWays/"/>
    <url>/2021/06/22/DecodeWays/</url>
    
    <content type="html"><![CDATA[<h4 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/22/DecodeWays/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/22/DecodeWays/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="解码方法-1"><a href="#解码方法-1" class="headerlink" title="解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;226&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：没有字符映射到以 <span class="hljs-number">0</span> 开头的数字。<br>含有 <span class="hljs-number">0</span> 的有效映射是 <span class="hljs-string">&#x27;J&#x27;</span> -&gt; <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&#x27;T&#x27;</span>-&gt; <span class="hljs-string">&quot;20&quot;</span> 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;06&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">&quot;06&quot;</span> 不能映射到 <span class="hljs-string">&quot;F&quot;</span> ，因为字符串含有前导 <span class="hljs-number">0</span>（<span class="hljs-string">&quot;6&quot;</span> 和 <span class="hljs-string">&quot;06&quot;</span> 在映射中并不等价）。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DecodeWays</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">numDecodings</span>(<span class="hljs-params">String s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n = s.length();<br>        <span class="hljs-comment">// a = f[i-2], b = f[i-1], c=f[i]</span><br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                c += b;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(i - <span class="hljs-number">2</span>) != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ((s.charAt(i - <span class="hljs-number">2</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s.charAt(i - <span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>)) &#123;<br>                c += a;<br>            &#125;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;12&quot;</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;226&quot;</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;0&quot;</span>));<br><br>        System.<span class="hljs-keyword">out</span>.println(numDecodings(<span class="hljs-string">&quot;06&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br>0<br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，dp了。没有想出来，最近跳槽结束很忙，状态不是很好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SubsetsII</title>
    <link href="/2021/06/19/SubsetsII/"/>
    <url>/2021/06/19/SubsetsII/</url>
    
    <content type="html"><![CDATA[<h4 id="子集-II"><a href="#子集-II" class="headerlink" title="子集 II"></a>子集 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/19/SubsetsII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/19/SubsetsII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="子集-II-1"><a href="#子集-II-1" class="headerlink" title="子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsetsII</span> &#123;<br><br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        dfs(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">boolean</span> choosePre, <span class="hljs-type">int</span> cur, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(t));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(<span class="hljs-literal">false</span>, cur + <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-keyword">if</span> (!choosePre &amp;&amp; cur &gt; <span class="hljs-number">0</span> &amp;&amp; nums[cur - <span class="hljs-number">1</span>] == nums[cur]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t.add(nums[cur]);<br>        dfs(<span class="hljs-literal">true</span>, cur + <span class="hljs-number">1</span>, nums);<br>        t.remove(t.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>        System.out.println(subsetsWithDup(nums));<br><br>        t.clear();<br>        ans.clear();<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        System.out.println(subsetsWithDup(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[2, 2]</span>, <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[1, 2]</span>, <span class="hljs-comment">[1, 2, 2]</span>]</span><br><span class="hljs-comment">[<span class="hljs-comment">[]</span>, <span class="hljs-comment">[0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，直接copy了官方的深度递归了。位移的解法实在难以理解。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GrayCode</title>
    <link href="/2021/06/17/GrayCode/"/>
    <url>/2021/06/17/GrayCode/</url>
    
    <content type="html"><![CDATA[<h4 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/17/GrayCode/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/17/GrayCode/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="格雷编码-1"><a href="#格雷编码-1" class="headerlink" title="格雷编码"></a><a href="https://leetcode-cn.com/problems/gray-code/">格雷编码</a></h4><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p><p>给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p><p>格雷编码序列必须以 0 开头。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><br><span class="hljs-section">输出: [0,1,3,2]</span><br><span class="hljs-section">解释:</span><br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2<br><br>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。<br><br>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> <span class="hljs-number">0</span><br>输出<span class="hljs-symbol">:</span> [<span class="hljs-number">0</span>]<br>解释<span class="hljs-symbol">:</span> 我们定义格雷编码序列必须以 <span class="hljs-number">0</span> 开头。<br>     给定编码总位数为 <span class="hljs-built_in">n</span> 的格雷编码序列，其长度为 <span class="hljs-number">2</span><span class="hljs-built_in">n</span>。当 <span class="hljs-built_in">n</span> = <span class="hljs-number">0</span> 时，长度为 <span class="hljs-number">20</span> = <span class="hljs-number">1</span>。<br>     因此，当 <span class="hljs-built_in">n</span> = <span class="hljs-number">0</span> 时，其格雷编码序列为 [<span class="hljs-number">0</span>]。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GrayCode</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">grayCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Collections.singletonList(<span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, n);<br>        <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][n];<br>        arr[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                        System.arraycopy(arr[i - <span class="hljs-number">1</span>],<span class="hljs-number">0</span>, arr[i],<span class="hljs-number">0</span>, n);<br>                        arr[i][j - <span class="hljs-number">1</span>] = arr[i][j - <span class="hljs-number">1</span>] ^ <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.arraycopy(arr[i - <span class="hljs-number">1</span>],<span class="hljs-number">0</span>, arr[i],<span class="hljs-number">0</span>, n);<br>                arr[i][n - <span class="hljs-number">1</span>] = arr[i][n - <span class="hljs-number">1</span>] ^ <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : arr) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ints.length; i++) &#123;<br>                result += ints[i] * Math.pow(<span class="hljs-number">2</span>, ints.length - i - <span class="hljs-number">1</span>);<br>            &#125;<br>            ans.add(result);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 镜像法</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">grayCode1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;() &#123;&#123; add(<span class="hljs-number">0</span>); &#125;&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 多少轮镜像，这个要看维基了解下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 每次都要遍历一遍已有集合，用镜像法算出本轮的值：开头1+已有值，</span><br>            <span class="hljs-comment">// 值得注意，每轮都会留下上一轮的数据</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> res.size() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                res.add(head + res.get(j));<br>            &#125;<br>            <span class="hljs-comment">// head = head &lt;&lt; 1; 相当于每次加了一个1开头的大数，完成镜像</span><br>            head &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(grayCode(<span class="hljs-number">2</span>));<br><br>        System.out.println(grayCode(<span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[0, 1, 3, 2]</span><br><span class="hljs-string">[0]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，我用了暴力破解。当然，dp我也想到了，但是没有好的办法实现。格雷码还是需要看下维基，了解下，才好写解法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeSortedArray</title>
    <link href="/2021/06/15/MergeSortedArray/"/>
    <url>/2021/06/15/MergeSortedArray/</url>
    
    <content type="html"><![CDATA[<h4 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a>扰乱字符串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/15/MergeSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/15/MergeSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组</a></h4><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中<em>，</em>使 <code>nums1</code> 成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code>的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MergeSortedArray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> merge(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">System</span>.arraycopy(nums2, <span class="hljs-number">0</span>, nums1, m, n);<br>        Arrays.sort(nums1);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] nums1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span>[] nums2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        merge(nums1, <span class="hljs-number">3</span>, nums2, <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(nums1));<br><br>        nums1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        nums2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>        merge(nums1, <span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(nums1));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[1, 2, 2, 3, 5, 6]</span><br><span class="hljs-string">[1]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，我偷懒了。逆双指针不是没想到，只是懒了，警戒下。需要好好对待每道题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ScrambleString</title>
    <link href="/2021/06/15/ScrambleString/"/>
    <url>/2021/06/15/ScrambleString/</url>
    
    <content type="html"><![CDATA[<h4 id="扰乱字符串"><a href="#扰乱字符串" class="headerlink" title="扰乱字符串"></a>扰乱字符串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/12/ScrambleString/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/12/ScrambleString/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="扰乱字符串-1"><a href="#扰乱字符串-1" class="headerlink" title="扰乱字符串"></a><a href="https://leetcode-cn.com/problems/scramble-string/">扰乱字符串</a></h4><p>使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：</p><ol><li>如果字符串的长度为 1 ，算法停止</li><li>如果字符串的长度 &gt; 1 ，执行下述步骤：<ul><li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li><li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li><li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li></ul></li></ol><p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;great&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;rgeat&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s1</span> 上可能发生的一种情形是：<br><span class="hljs-string">&quot;great&quot;</span> --&gt; <span class="hljs-string">&quot;gr/eat&quot;</span> <span class="hljs-comment">// 在一个随机下标处分割得到两个子字符串</span><br><span class="hljs-string">&quot;gr/eat&quot;</span> --&gt; <span class="hljs-string">&quot;gr/eat&quot;</span> <span class="hljs-comment">// 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="hljs-string">&quot;gr/eat&quot;</span> --&gt; <span class="hljs-string">&quot;g/r / e/at&quot;</span> <span class="hljs-comment">// 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span><br><span class="hljs-string">&quot;g/r / e/at&quot;</span> --&gt; <span class="hljs-string">&quot;r/g / e/at&quot;</span> <span class="hljs-comment">// 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span><br><span class="hljs-string">&quot;r/g / e/at&quot;</span> --&gt; <span class="hljs-string">&quot;r/g / e/ a/t&quot;</span> <span class="hljs-comment">// 继续递归执行此算法，将 &quot;at&quot; 分割得到 &quot;a/t&quot;</span><br><span class="hljs-string">&quot;r/g / e/ a/t&quot;</span> --&gt; <span class="hljs-string">&quot;r/g / e/ a/t&quot;</span> <span class="hljs-comment">// 随机决定：「保持这两个子字符串的顺序不变」</span><br>算法终止，结果字符串和 <span class="hljs-built_in">s2</span> 相同，都是 <span class="hljs-string">&quot;rgeat&quot;</span><br>这是一种能够扰乱 <span class="hljs-built_in">s1</span> 得到 <span class="hljs-built_in">s2</span> 的情形，可以认为 <span class="hljs-built_in">s2</span> 是 <span class="hljs-built_in">s1</span> 的扰乱字符串，返回 true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;caebd&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s1.length == s2.length</code></li><li><code>1 &lt;= s1.length &lt;= 30</code></li><li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrambleString</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        <span class="hljs-comment">// 记忆化搜索存储状态的数组</span><br>        <span class="hljs-comment">// -1 表示 false，1 表示 true，0 表示未计算</span><br>        <span class="hljs-type">int</span>[][][] memo;<br>        String s1, s2;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isScramble</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s1.length();<br>            <span class="hljs-built_in">this</span>.memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][length][length + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">this</span>.s1 = s1;<br>            <span class="hljs-built_in">this</span>.s2 = s2;<br>            <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, length);<br>        &#125;<br><br>        <span class="hljs-comment">// 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> length)</span> &#123;<br>            <span class="hljs-keyword">if</span> (memo[i1][i2][length] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 判断已经判断过的是否和谐</span><br>                <span class="hljs-keyword">return</span> memo[i1][i2][length] == <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断两个子串是否相等</span><br>            <span class="hljs-keyword">if</span> (s1.substring(i1, i1 + length).equals(s2.substring(i2, i2 + length))) &#123;<br>                memo[i1][i2][length] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 判断是否存在字符 c 在两个子串中出现的次数不同</span><br>            <span class="hljs-keyword">if</span> (!checkIfSimilar(i1, i2, length)) &#123;<br>                memo[i1][i2][length] = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 枚举分割位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>                <span class="hljs-comment">// 不交换的情况</span><br>                <span class="hljs-keyword">if</span> (dfs(i1, i2, i) &amp;&amp; dfs(i1 + i, i2 + i, length - i)) &#123;<br>                    memo[i1][i2][length] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 交换的情况</span><br>                <span class="hljs-keyword">if</span> (dfs(i1, i2 + length - i, i) &amp;&amp; dfs(i1 + i, i2, length - i)) &#123;<br>                    memo[i1][i2][length] = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br><br>            memo[i1][i2][length] = -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断两个字符串的字符数量一致</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkIfSimilar</span><span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> length)</span> &#123;<br>            Map&lt;Character, Integer&gt; freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i1; i &lt; i1 + length; ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s1.charAt(i);<br>                freq.put(c, freq.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i2; i &lt; i2 + length; ++i) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s2.charAt(i);<br>                freq.put(c, freq.getOrDefault(c, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>                <span class="hljs-keyword">if</span> (value != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        System.out.println(solution.isScramble(<span class="hljs-string">&quot;great&quot;</span>, <span class="hljs-string">&quot;rgeat&quot;</span>));<br><br>        System.out.println(solution.isScramble(<span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-string">&quot;caebd&quot;</span>));<br><br>        System.out.println(solution.isScramble(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，官方的答案很多词并不新鲜，但是解法确实抽丝剥茧，没做出来，确实有难度。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PartitionList</title>
    <link href="/2021/06/10/PartitionList/"/>
    <url>/2021/06/10/PartitionList/</url>
    
    <content type="html"><![CDATA[<h4 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/10/PartitionList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/10/PartitionList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="分隔链表-1"><a href="#分隔链表-1" class="headerlink" title="分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/">分隔链表</a></h4><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/partition.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,4,3,2,5,2]</span>, <span class="hljs-attribute">x</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-selector-attr">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[2,1]</span>, <span class="hljs-attribute">x</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-selector-attr">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>-200 &lt;= x &lt;= 200</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PartitionList</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">smallHead</span> <span class="hljs-operator">=</span> small;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">large</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">largeHead</span> <span class="hljs-operator">=</span> large;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (head.val &lt; x) &#123;<br>                small.next = head;<br>                small = small.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                large.next = head;<br>                large = large.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        large.next = <span class="hljs-literal">null</span>;<br>        small.next = largeHead.next;<br>        <span class="hljs-keyword">return</span> smallHead.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        node1.next = node2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        node2.next = node3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        node3.next = node4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        node4.next = node5;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        node5.next = node6;<br>        node6.next = <span class="hljs-literal">null</span>;<br>        print(partition(node1, <span class="hljs-number">3</span>));<br><br>        node1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        node2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        node1.next = node2;<br>        node2.next = <span class="hljs-literal">null</span>;<br>        print(partition(node1, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(head.val + <span class="hljs-string">&quot; &quot;</span>);<br>            head = head.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，双链表实在太巧妙了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MaximalRectangle</title>
    <link href="/2021/06/08/MaximalRectangle/"/>
    <url>/2021/06/08/MaximalRectangle/</url>
    
    <content type="html"><![CDATA[<h4 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/08/MaximalRectangle/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/08/MaximalRectangle/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最大矩形-1"><a href="#最大矩形-1" class="headerlink" title="最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/">最大矩形</a></h4><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/maximal.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：matrix <span class="hljs-operator">=</span> []<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;1&quot;]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[&quot;0&quot;,&quot;0&quot;]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>0 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaximalRectangle</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">// 左边连续1的数量</span><br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 注意是括号+1</span><br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> left[i][j];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> width;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    width = Math.min(width, left[k][j]);<br>                    area = Math.max(area, (i - k + <span class="hljs-number">1</span>) * width);<br>                &#125;<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 单调函数版，主要是基于列，将图翻转90°就是上一题了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximalRectangle1</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-comment">// 需要算出最长宽度，与上个算法一致</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 对于每一列，使用基于柱状图的方法，可以理解为列从0-n使用上题的解法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 上边界</span><br>            <span class="hljs-type">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>            <span class="hljs-comment">// 下边界</span><br>            <span class="hljs-type">int</span>[] down = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br><br>            Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                up[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                stack.push(i);<br>            &#125;<br>            stack.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                down[i] = stack.isEmpty() ? m : stack.peek();<br>                stack.push(i);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> down[i] - up[i] - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> height * left[i][j];<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;1&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;&#125;;<br>        System.out.println(maximalRectangle(matrix));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>0<br>0<br>1<br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，第一种解法固然简单了。后续基于单调函数的解法很是巧妙。这类题目也是一种类型，熟悉了才能理解的深吧。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LargestRectangleInHistogram</title>
    <link href="/2021/06/05/LargestRectangleInHistogram/"/>
    <url>/2021/06/05/LargestRectangleInHistogram/</url>
    
    <content type="html"><![CDATA[<h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/05/LargestRectangleInHistogram/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/05/LargestRectangleInHistogram/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="柱状图中最大的矩形-1"><a href="#柱状图中最大的矩形-1" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,1,5,6,2,3]</span><br><span class="hljs-section">输出: 10</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LargestRectangleInHistogram &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> largestRectangleArea(<span class="hljs-type">int</span>[] heights) &#123;<br>        Stack&lt;<span class="hljs-type">Integer</span>&gt; stack = <span class="hljs-built_in">new</span> Stack&lt;&gt;();<br>        <span class="hljs-type">int</span> length = heights.length;<br>        <span class="hljs-type">int</span>[] left = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[length];<br>        <span class="hljs-type">int</span>[] right = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[length];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;<br>                stack.pop();<br>            &#125;<br>            left[i] = stack.isEmpty() ? <span class="hljs-number">-1</span> : stack.peek();<br>            stack.push(i);<br>        &#125;<br><br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;<br>                stack.pop();<br>            &#125;<br>            right[i] = stack.isEmpty() ? length : stack.peek();<br>            stack.push(i);<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] heights= <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(largestRectangleArea(heights));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>如果只是求解，倒是不难，双指针枚举，不过效率太低，可能过不了，所以采用了单调栈的方法。思路也是异常的简单和巧妙，就是遍历过程中，记录每个值左边和右边的边界。主要是每次比较的过程中，上一个已经帮我们筛选了一次，这一次，只需要比较自己和上一个值，以及上一个值的边界即可。详细的解释，可以参考其他答案，官网的解释有点费解。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedList</title>
    <link href="/2021/06/03/RemoveDuplicatesFromSortedList/"/>
    <url>/2021/06/03/RemoveDuplicatesFromSortedList/</url>
    
    <content type="html"><![CDATA[<h4 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/03/RemoveDuplicatesFromSortedList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/03/RemoveDuplicatesFromSortedList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="删除排序链表中的重复元素-1"><a href="#删除排序链表中的重复元素-1" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h4><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/list1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/list2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,2,3,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDuplicatesFromSortedList</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode deleteDuplicates(ListNode head) &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.<span class="hljs-keyword">next</span>.val) &#123;<br>                cur.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是遍历并修改指向的重复节点。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedListII</title>
    <link href="/2021/06/01/RemoveDuplicatesFromSortedListII/"/>
    <url>/2021/06/01/RemoveDuplicatesFromSortedListII/</url>
    
    <content type="html"><![CDATA[<h4 id="删除排序链表中的重复元素-II"><a href="#删除排序链表中的重复元素-II" class="headerlink" title="删除排序链表中的重复元素 II"></a>删除排序链表中的重复元素 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/06/01/RemoveDuplicatesFromSortedListII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/06/01/RemoveDuplicatesFromSortedListII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="删除排序链表中的重复元素-II-1"><a href="#删除排序链表中的重复元素-II-1" class="headerlink" title="删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></h4><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p><p>返回同样按升序排列的结果链表。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/linkedlist1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,3,4,4,5]</span><br>输出：<span class="hljs-comment">[1,2,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/linkedlist2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,1,1,2,3]</span><br>输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveDuplicatesFromSortedListII</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.next.val == cur.next.next.val) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cur.next.val;<br>                <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == x) &#123;<br>                    cur.next = cur.next.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1,2,3,3,4,4,5</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n1.next = n2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n2.next = n3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n3.next = n4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n4.next = n5;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n5.next = n6;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n6.next = n7;<br>        print(deleteDuplicates(n1));<br><br>        <span class="hljs-comment">// 1,1,1,2,3</span><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n1.next = n2;<br>        n3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2.next = n3;<br>        n4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n3.next = n4;<br>        n5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n4.next = n5;<br>        print(deleteDuplicates(n1));<br><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n1.next = n2;<br>        print(deleteDuplicates(n1));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(head.val + <span class="hljs-string">&quot; &quot;</span>);<br>            head = head.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是加一个哑节点。注意，不要思考过于复杂。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchInRotatedSortedArrayII</title>
    <link href="/2021/05/27/SearchInRotatedSortedArrayII/"/>
    <url>/2021/05/27/SearchInRotatedSortedArrayII/</url>
    
    <content type="html"><![CDATA[<h4 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a>搜索旋转排序数组 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/27/SearchInRotatedSortedArrayII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/27/SearchInRotatedSortedArrayII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索旋转排序数组-II-1"><a href="#搜索旋转排序数组-II-1" class="headerlink" title="搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li>−104&lt;&#x3D;nums[i]&lt;&#x3D;104</li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li>−104&lt;&#x3D;target&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SearchInRotatedSortedArrayII &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> <span class="hljs-keyword">search</span>(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;<br>                ++l;<br>                <span class="hljs-comment">--r;</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;<br>                <span class="hljs-keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="hljs-number">1</span>]) &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">search</span>(nums, target));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        target = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">search</span>(nums, target));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br>        target = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">search</span>(nums, target));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是比之前多了一个是否首尾中一致的判断。其实也是很巧妙了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedArrayII</title>
    <link href="/2021/05/25/RemoveDuplicatesFromSortedArrayII/"/>
    <url>/2021/05/25/RemoveDuplicatesFromSortedArrayII/</url>
    
    <content type="html"><![CDATA[<h4 id="删除有序数组中的重复项-II"><a href="#删除有序数组中的重复项-II" class="headerlink" title="删除有序数组中的重复项 II"></a>删除有序数组中的重复项 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/25/RemoveDuplicatesFromSortedArrayII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/25/RemoveDuplicatesFromSortedArrayII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="删除有序数组中的重复项-II-1"><a href="#删除有序数组中的重复项-II-1" class="headerlink" title="删除有序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II</a></h4><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    <span class="hljs-built_in">print</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,1,1,2,2,3]</span><br>输出：<span class="hljs-number">5</span>, nums = <span class="hljs-string">[1,1,2,2,3]</span><br>解释：函数应返回新长度 length = <span class="hljs-number">5</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> 。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,1,2,3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">7</span>, nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>解释：函数应返回新长度 length = <span class="hljs-number">7</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> 。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;3∗104</li><li>−104&lt;&#x3D;nums[i]&lt;&#x3D;104</li><li><code>nums</code> 已按升序排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RemoveDuplicatesFromSortedArrayII &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> removeDuplicates(<span class="hljs-keyword">int</span>[] nums) &#123;<br><br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> slow = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> fast = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[slow - <span class="hljs-number">2</span>] != nums[fast]) &#123;<br>                nums[slow] = nums[fast];<br>                slow ++;<br>            &#125;<br>            fast++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.<span class="hljs-keyword">println</span>(removeDuplicates(nums));<br>        <span class="hljs-keyword">print</span>(nums);<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.<span class="hljs-keyword">println</span>(removeDuplicates(nums));<br>        <span class="hljs-keyword">print</span>(nums);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br><span class="hljs-number">7</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。就是双指针，然后复制交换。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WordSearch</title>
    <link href="/2021/05/22/WordSearch/"/>
    <url>/2021/05/22/WordSearch/</url>
    
    <content type="html"><![CDATA[<h4 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/22/WordSearch/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/22/WordSearch/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="单词搜索-1"><a href="#单词搜索-1" class="headerlink" title="单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">单词搜索</a></h4><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/word-1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;SEE&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/word3.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCB&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordSearch</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">String</span> <span class="hljs-type">word</span>)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> m = board.length;<br>        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[i].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-type">word</span>.<span class="hljs-built_in">charAt</span>(<span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, <span class="hljs-number">0</span>, i, j, m, n)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">boolean</span>[][] visited, <span class="hljs-type">String</span> <span class="hljs-type">word</span>, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((row &lt; <span class="hljs-number">0</span> || row &gt;= m) || (col &lt; <span class="hljs-number">0</span> || col &gt;= n) || visited[row][col]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">word</span>.<span class="hljs-built_in">charAt</span>(index) == board[row][col] &amp;&amp; <span class="hljs-type">word</span>.<span class="hljs-built_in">length</span>() == index + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">word</span>.<span class="hljs-built_in">charAt</span>(index) == board[row][col]) &#123;<br>            visited[row][col] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row + <span class="hljs-number">1</span>, col, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row - <span class="hljs-number">1</span>, col, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row, col + <span class="hljs-number">1</span>, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, visited, <span class="hljs-type">word</span>, index + <span class="hljs-number">1</span>, row, col - <span class="hljs-number">1</span>, m, n)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            visited[row][col] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;&#125;;<br>        <span class="hljs-type">String</span> <span class="hljs-type">word</span> = <span class="hljs-string">&quot;ABCCED&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">exist</span>(board, <span class="hljs-type">word</span>));<br><br>        board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;&#125;;<br>        <span class="hljs-type">word</span> = <span class="hljs-string">&quot;SEE&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">exist</span>(board, <span class="hljs-type">word</span>));<br><br>        board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;&#125;;<br>        <span class="hljs-type">word</span> = <span class="hljs-string">&quot;ABCB&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">exist</span>(board, <span class="hljs-type">word</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单。但是因为一直对深度搜索和递归不是很熟，所以意外的一次性通过了。当然效率还是不太高，后续有时间再优化下。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Subsets</title>
    <link href="/2021/05/20/Subsets/"/>
    <url>/2021/05/20/Subsets/</url>
    
    <content type="html"><![CDATA[<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/20/Subsets/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/20/Subsets/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="子集-1"><a href="#子集-1" class="headerlink" title="子集"></a><a href="https://leetcode-cn.com/problems/subsets/">子集</a></h4><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Subsets &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; subsets(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        ans.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;());<br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-type">int</span> max = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">2</span>, length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; max; i++) &#123;<br>            ans.<span class="hljs-keyword">add</span>(compute(i, nums));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private static List&lt;<span class="hljs-type">Integer</span>&gt; compute(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span>[] nums) &#123;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num !=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = num % <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> == <span class="hljs-number">1</span>) &#123;<br>                list.<span class="hljs-keyword">add</span>(nums[count]);<br>            &#125;<br>            count++;<br>            num /= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; nums) &#123;<br>        <span class="hljs-keyword">for</span> (List&lt;<span class="hljs-type">Integer</span>&gt; num : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> : num) &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(<span class="hljs-type">integer</span> + &quot; &quot;);<br>            &#125;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        print(subsets(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        print(subsets(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">2 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <br><br><span class="hljs-symbol">0 </span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是数字二进制化，就可以找到所有的组合。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumWindowSubstring</title>
    <link href="/2021/05/18/MinimumWindowSubstring/"/>
    <url>/2021/05/18/MinimumWindowSubstring/</url>
    
    <content type="html"><![CDATA[<h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/18/MinimumWindowSubstring/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/18/MinimumWindowSubstring/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最小覆盖子串-1"><a href="#最小覆盖子串-1" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MinimumWindowSubstring &#123;<br><br>    static Map&lt;<span class="hljs-type">Character</span>, <span class="hljs-type">Integer</span>&gt; ori = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>    static Map&lt;<span class="hljs-type">Character</span>, <span class="hljs-type">Integer</span>&gt; cnt = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-built_in">public</span> static String minWindow(String s, String t) &#123;<br>        <span class="hljs-type">int</span> tLen = t.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tLen; i++) &#123;<br>            <span class="hljs-type">char</span> c = t.charAt(i);<br>            ori.put(c, ori.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-type">Integer</span>.MAX_VALUE, ansL = <span class="hljs-number">-1</span>, ansR = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> sLen = s.length();<br>        <span class="hljs-keyword">while</span> (r &lt; sLen) &#123;<br>            ++r;<br>            <span class="hljs-keyword">if</span> (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;<br>                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">check</span>() &amp;&amp; l &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    ansL = l;<br>                    ansR = l + len;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ori.containsKey(s.charAt(l))) &#123;<br>                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ansL == <span class="hljs-number">-1</span> ? &quot;&quot; : s.substring(ansL, ansR);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> <span class="hljs-keyword">check</span>() &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;<span class="hljs-type">Character</span>, <span class="hljs-type">Integer</span>&gt; entry : ori.entrySet()) &#123;<br>            <span class="hljs-type">Character</span> key = entry.getKey();<br>            <span class="hljs-type">Integer</span> val = entry.getValue();<br>            <span class="hljs-keyword">if</span> (cnt.getOrDefault(key, <span class="hljs-number">0</span>) &lt; val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>//        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(minWindow(&quot;ADOBECODEBANC&quot;, &quot;ABC&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(minWindow(&quot;a&quot;, &quot;a&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路：官方的提示有点坑，需要O(n)的时间，但是明显答案不满足这个条件，所以没有找到好的解题方法，看了官方答案，才明白和自己想的差不多，双指针思路。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Combinations</title>
    <link href="/2021/05/15/Combinations/"/>
    <url>/2021/05/15/Combinations/</url>
    
    <content type="html"><![CDATA[<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/15/Combinations/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/15/Combinations/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="组合-1"><a href="#组合-1" class="headerlink" title="组合"></a><a href="https://leetcode-cn.com/problems/combinations/">组合</a></h4><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: n = 4, k = 2<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs irpf90">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Combinations &#123;<br><br>    static List&lt;<span class="hljs-keyword">Integer</span>&gt; <span class="hljs-keyword">unit</span> = new ArrayList&lt;&gt;();<br>    static List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; ans = new ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> static List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combine(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k) &#123;<br>        dfs(<span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static void dfs(<span class="hljs-built_in">int</span> cur, <span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">unit</span>.<span class="hljs-built_in">size</span>()  + (n - cur + <span class="hljs-number">1</span>) &lt; k) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">unit</span>.<span class="hljs-built_in">size</span>() == k) &#123;<br>            ans.add(new ArrayList&lt;&gt;(<span class="hljs-keyword">unit</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">unit</span>.add(cur);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>        <span class="hljs-keyword">unit</span>.remove(<span class="hljs-keyword">unit</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        dfs(cur + <span class="hljs-number">1</span>, n, k);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        <span class="hljs-built_in">print</span>(combine(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static void <span class="hljs-built_in">print</span>(List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; ans) &#123;<br>        for (List&lt;<span class="hljs-keyword">Integer</span>&gt; an : ans) &#123;<br>            for (<span class="hljs-keyword">Integer</span> <span class="hljs-keyword">integer</span> : an) &#123;<br>                System.<span class="hljs-keyword">out</span>.<span class="hljs-built_in">print</span>(<span class="hljs-keyword">integer</span>);<br>                System.<span class="hljs-keyword">out</span>.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.<span class="hljs-keyword">out</span>.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路深度递归很简单，官方给出的另外的解法其实很巧妙，不过最近忙练车，没时间研究了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumWindowSubstring</title>
    <link href="/2021/05/13/SortColors/"/>
    <url>/2021/05/13/SortColors/</url>
    
    <content type="html"><![CDATA[<h4 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/13/SortColors/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/13/SortColors/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="颜色分类-1"><a href="#颜色分类-1" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h4><p>给定一个包含红色、白色和蓝色，一共 <code>n</code> 个元素的数组，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,0,2,1,1,0]</span><br>输出：<span class="hljs-string">[0,0,1,1,2,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,0,1]</span><br>输出：<span class="hljs-comment">[0,1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以不使用代码库中的排序函数来解决这道题吗？</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SortColors &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> sortColors(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> red = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> white = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> blue = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>                red++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                white++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                blue++;<br>            &#125;<br>        &#125;<br>        Arrays.fill(nums, <span class="hljs-number">0</span>, red, <span class="hljs-number">0</span>);<br>        Arrays.fill(nums, red, red + white, <span class="hljs-number">1</span>);<br>        Arrays.fill(nums, red + white, red + white + blue, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> sortColors1(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p1];<br>                nums[p1] = <span class="hljs-keyword">temp</span>;<br>                ++p1;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = <span class="hljs-keyword">temp</span>;<br>                <span class="hljs-keyword">if</span> (p0 &lt; p1) &#123;<br>                    <span class="hljs-keyword">temp</span> = nums[i];<br>                    nums[i] = nums[p1];<br>                    nums[p1] = <span class="hljs-keyword">temp</span>;<br>                &#125;<br>                ++p0;<br>                ++p1;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> sortColors2(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= p2; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p2];<br>                nums[p2] = <span class="hljs-keyword">temp</span>;<br>                <span class="hljs-comment">--p2;</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = <span class="hljs-keyword">temp</span>;<br>                ++p0;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">0</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[] &#123;<span class="hljs-number">1</span>&#125;;<br>        sortColors(nums);<br>        print(nums);<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(num);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(&quot; &quot;);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">0 </span><br><span class="hljs-symbol">1 </span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路统计并填充法很简单，但是双指针也很巧妙。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SetMatrixZeroes</title>
    <link href="/2021/05/11/SetMatrixZeroes/"/>
    <url>/2021/05/11/SetMatrixZeroes/</url>
    
    <content type="html"><![CDATA[<h4 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/08/SetMatrixZeroes/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/08/SetMatrixZeroes/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="矩阵置零-1"><a href="#矩阵置零-1" class="headerlink" title="矩阵置零"></a><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">矩阵置零</a></h4><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法。</p><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用 <code>O(m x n)</code> 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 <code>O(m + n)</code> 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个仅使用常量空间的解决方案吗？</li></ul><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat73-1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-string">[[1,0,1],[0,0,0],[1,0,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat73-2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br>输出：<span class="hljs-string">[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li>−231&lt;&#x3D;matrix[i][j]&lt;&#x3D;231−1</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetMatrixZeroes</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">colFlag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-comment">// 存第一列是否为0的标志</span><br>            <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>                colFlag = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 在第一行或者第一列保存判0的标志</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 开始从后往前逆序置0，保证初始化的正确性</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> col - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化第一列</span><br>        <span class="hljs-keyword">if</span> (colFlag) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        setZeroes(matrix);<br>        print(matrix);<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>        setZeroes(matrix);<br>        print(matrix);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.out.print(anInt);<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">0 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路其实很巧妙，但是题目本身的描述也给了答案，就是常量空间，那一定是要利用数组本身的空间了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchA2dMatrix</title>
    <link href="/2021/05/11/SearchA2dMatrix/"/>
    <url>/2021/05/11/SearchA2dMatrix/</url>
    
    <content type="html"><![CDATA[<h4 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/11/SearchA2dMatrix/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/11/SearchA2dMatrix/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索二维矩阵-1"><a href="#搜索二维矩阵-1" class="headerlink" title="搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵</a></h4><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mats2d1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mats2d2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,3,5,7],[10,11,16,20],[23,30,34,60]]</span>, target = <span class="hljs-number">13</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li>−104&lt;&#x3D;matrix[i][j],target&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchA2dMatrix</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> row = matrix.length;<br>        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">int</span> rowLow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rowHigh = row - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> midRow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (rowLow &lt;= rowHigh) &#123;<br>            midRow = (rowLow + rowHigh) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[midRow][<span class="hljs-number">0</span>] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(matrix[midRow][<span class="hljs-number">0</span>] &gt; <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>                rowHigh = midRow - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                rowLow = midRow + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (matrix[midRow][<span class="hljs-number">0</span>] &gt; <span class="hljs-keyword">target</span>) &#123;<br>            midRow -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (midRow &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> colLeft = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> colRight = col - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> midCol;<br>        <span class="hljs-keyword">while</span> (colLeft &lt;= colRight) &#123;<br>            midCol = (colLeft + colRight) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[midRow][midCol] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(matrix[midRow][midCol] &gt; <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>                colRight = midCol - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                colLeft = midCol + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">23</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">60</span>&#125;&#125;;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span>;<br>        System.out.println(searchMatrix(matrix, <span class="hljs-keyword">target</span>));<br><br>        matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">23</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">60</span>&#125;&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">13</span>;<br>        System.out.println(searchMatrix(matrix, <span class="hljs-keyword">target</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是二分搜索。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EditDistance</title>
    <link href="/2021/05/06/EditDistance/"/>
    <url>/2021/05/06/EditDistance/</url>
    
    <content type="html"><![CDATA[<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/06/EditDistance/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/06/EditDistance/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="编辑距离-1"><a href="#编辑距离-1" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h4><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EditDistance</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-type">String</span> word1, <span class="hljs-type">String</span> word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-type">word</span><span class="hljs-number">1.l</span>ength();<br>        <span class="hljs-type">int</span> m = <span class="hljs-type">word</span><span class="hljs-number">2.l</span>ength();<br><br>        <span class="hljs-comment">// 有一个字符串为空串</span><br>        <span class="hljs-keyword">if</span> (n * m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> n + m;<br>        &#125;<br><br>        <span class="hljs-comment">// DP 数组</span><br>        <span class="hljs-type">int</span>[][] D = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 边界状态初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            D[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>            D[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算所有 DP 值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-type">int</span> left = D[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> down = D[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left_down = D[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">word</span><span class="hljs-number">1.</span><span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) != <span class="hljs-type">word</span><span class="hljs-number">2.</span><span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>)) &#123;<br>                    left_down += <span class="hljs-number">1</span>;<br>                &#125;<br>                D[i][j] = Math.<span class="hljs-built_in">min</span>(left, Math.<span class="hljs-built_in">min</span>(down, left_down));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> D[n][m];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">minDistance</span>(<span class="hljs-string">&quot;horse&quot;</span>, <span class="hljs-string">&quot;ros&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">minDistance</span>(<span class="hljs-string">&quot;intention&quot;</span>, <span class="hljs-string">&quot;execution&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>5<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路是抄了官方答案，这个问题没遇到过，动态规划其实还简单了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SimplifyPath</title>
    <link href="/2021/05/04/SimplifyPath/"/>
    <url>/2021/05/04/SimplifyPath/</url>
    
    <content type="html"><![CDATA[<h4 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/04/SimplifyPath/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/04/SimplifyPath/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="简化路径-1"><a href="#简化路径-1" class="headerlink" title="简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/">简化路径</a></h4><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li><li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li></ul><p>返回简化后得到的 <strong>规范路径</strong> 。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home/&quot;</span><br>输出：<span class="hljs-string">&quot;/home&quot;</span><br>解释：注意，最后一个目录名后面没有斜杠。 <br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/../&quot;</span><br>输出：<span class="hljs-string">&quot;/&quot;</span><br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home//foo/&quot;</span><br>输出：<span class="hljs-string">&quot;/home/foo&quot;</span><br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/a/./b/../../c/&quot;</span><br>输出：<span class="hljs-string">&quot;/c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= path.length &lt;= 3000</code></li><li><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li><li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplifyPath</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">simplifyPath</span><span class="hljs-params">(<span class="hljs-type">String</span> path)</span> </span>&#123;<br><br>        LinkedList&lt;<span class="hljs-type">String</span>&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-type">char</span>[] chars = path.<span class="hljs-built_in">toCharArray</span>();<br>        List&lt;<span class="hljs-type">String</span>&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> end = <span class="hljs-number">0</span>; end &lt; chars.length; end++) &#123;<br>            <span class="hljs-keyword">if</span> (chars[end] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (end &gt; start) &#123;<br>                    strings.<span class="hljs-built_in">add</span>(path.<span class="hljs-built_in">substring</span>(start, end));<br>                &#125;<br>                strings.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>                start = end + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end == chars.length - <span class="hljs-number">1</span>) &#123;<br>                strings.<span class="hljs-built_in">add</span>(path.<span class="hljs-built_in">substring</span>(start, end + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> string : strings) &#123;<br>            <span class="hljs-keyword">switch</span> (string) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                    <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.<span class="hljs-built_in">get</span>(stack.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>).<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        stack.<span class="hljs-built_in">add</span>(string);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.&quot;</span>:<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;..&quot;</span>:<br>                    <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>                        stack.<span class="hljs-built_in">removeLast</span>();<br>                        stack.<span class="hljs-built_in">removeLast</span>();<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    stack.<span class="hljs-built_in">add</span>(string);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; stack.<span class="hljs-built_in">getLast</span>().<span class="hljs-built_in">equals</span>(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>            stack.<span class="hljs-built_in">removeLast</span>();<br>        &#125;<br><br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> s : stack) &#123;<br>            stringBuilder.<span class="hljs-built_in">append</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/home&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/../&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/home//foo/&quot;</span>));<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">simplifyPath</span>(<span class="hljs-string">&quot;/a/./b/../../c/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/home<br>/<br>/home/foo<br>/c<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是挨个匹配。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mySqrt</title>
    <link href="/2021/05/01/mySqrt/"/>
    <url>/2021/05/01/mySqrt/</url>
    
    <content type="html"><![CDATA[<h4 id="x-的平方根"><a href="#x-的平方根" class="headerlink" title="x 的平方根"></a>x 的平方根</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/01/mySqrt/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/01/mySqrt/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="x-的平方根-1"><a href="#x-的平方根-1" class="headerlink" title="x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">x 的平方根</a></h4><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 4</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 8</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">说明: 8 的平方根是 2.82842..., </span><br>     由于返回类型是整数，小数部分将被舍去。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) Math.<span class="hljs-built_in">sqrt</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">mySqrt</span>(<span class="hljs-number">4</span>));<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">mySqrt</span>(<span class="hljs-number">8</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路就是一道数学题，官方给出了3种数学解法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ClimbingStairs</title>
    <link href="/2021/05/01/ClimbingStairs/"/>
    <url>/2021/05/01/ClimbingStairs/</url>
    
    <content type="html"><![CDATA[<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><ul><li><a href="https://yangtzeshore.github.io/2021/05/01/ClimbingStairs/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/05/01/ClimbingStairs/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClimbingStairs</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br><br>        <span class="hljs-comment">// f[n] = f[n-1] + f[n-2]</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(climbStairs(<span class="hljs-number">2</span>));<br>        System.<span class="hljs-keyword">out</span>.println(climbStairs(<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路就是一道简单的动态方程。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TextJustification</title>
    <link href="/2021/04/29/TextJustification/"/>
    <url>/2021/04/29/TextJustification/</url>
    
    <content type="html"><![CDATA[<h4 id="文本左右对齐"><a href="#文本左右对齐" class="headerlink" title="文本左右对齐"></a>文本左右对齐</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/29/TextJustification/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/29/TextJustification/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="文本左右对齐-1"><a href="#文本左右对齐-1" class="headerlink" title="文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">文本左右对齐</a></h4><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p><p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p><p><strong>说明:</strong></p><ul><li>单词是指由非空格字符组成的字符序列。</li><li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li><li>输入单词数组 <code>words</code> 至少包含一个单词。</li></ul><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>]<br>maxWidth = 16<br><span class="hljs-section">输出:</span><br>[<br>   <span class="hljs-string">&quot;This    is    an&quot;</span>,<br>   <span class="hljs-string">&quot;example  of text&quot;</span>,<br>   <span class="hljs-string">&quot;justification.  &quot;</span><br>]<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;What&quot;</span>,<span class="hljs-string">&quot;must&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;acknowledgment&quot;</span>,<span class="hljs-string">&quot;shall&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>]<br>maxWidth = 16<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;What   must   be&quot;</span>,<br>  <span class="hljs-string">&quot;acknowledgment  &quot;</span>,<br>  <span class="hljs-string">&quot;shall be        &quot;</span><br>]<br><span class="hljs-section">解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span><br>     因为最后一行应为左对齐，而不是左右两端对齐。       <br>     第二行同样为左对齐，这是因为这行只包含一个单词。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;Science&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;what&quot;</span>,<span class="hljs-string">&quot;we&quot;</span>,<span class="hljs-string">&quot;understand&quot;</span>,<span class="hljs-string">&quot;well&quot;</span>,<span class="hljs-string">&quot;enough&quot;</span>,<span class="hljs-string">&quot;to&quot;</span>,<span class="hljs-string">&quot;explain&quot;</span>,<br>         <span class="hljs-string">&quot;to&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;computer.&quot;</span>,<span class="hljs-string">&quot;Art&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;everything&quot;</span>,<span class="hljs-string">&quot;else&quot;</span>,<span class="hljs-string">&quot;we&quot;</span>,<span class="hljs-string">&quot;do&quot;</span>]<br>maxWidth = 20<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;Science  is  what we&quot;</span>,<br>  <span class="hljs-string">&quot;understand      well&quot;</span>,<br>  <span class="hljs-string">&quot;enough to explain to&quot;</span>,<br>  <span class="hljs-string">&quot;a  computer.  Art is&quot;</span>,<br>  <span class="hljs-string">&quot;everything  else  we&quot;</span>,<br>  <span class="hljs-string">&quot;do                  &quot;</span><br>]<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 先取出一行能够容纳的单词，将这些单词根据规则填入一行</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 计算出额外空格的数量 spaceCount，额外空格就是正常书写用不到的空格</span><br><span class="hljs-comment"> * 2.1. 由总长度算起</span><br><span class="hljs-comment"> * 2.2. 除去每个单词末尾必须的空格，为了统一处理可以在结尾虚拟加上一个长度</span><br><span class="hljs-comment"> * 2.3. 除去所有单词的长度</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. 按照单词的间隙数量 wordCount - 1，简单来说就是商和余数的计算</span><br><span class="hljs-comment"> * 3.1 对于每个词填充之后，需要填充的空格数量等于 spaceSuffix + spaceAvg + ((i - bg) &lt; spaceExtra)</span><br><span class="hljs-comment"> * spaceSuffix 【单词尾部固定的空格，就是1】</span><br><span class="hljs-comment"> * spaceAvg 【额外空格的平均值，每个间隙都要填入 spaceAvg 个空格】</span><br><span class="hljs-comment"> * ((i - bg) &lt; spaceExtra) 【额外空格的余数，前 spaceExtra 个间隙需要多 1 个空格】，这个是补偿给前面的间隙的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 特殊处理</span><br><span class="hljs-comment"> * 4.1. 一行只有一个单词，单词左对齐，右侧填满空格</span><br><span class="hljs-comment"> * 4.2. 最后一行，所有单词左对齐，中间只有一个空格，最后一个单词右侧填满空格</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextJustification</span> &#123;<br><br>    <span class="hljs-comment">// 行整理函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">fillWords</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex, <span class="hljs-type">int</span> maxWidth, <span class="hljs-type">boolean</span> lastLine)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wordCount</span> <span class="hljs-operator">=</span> endIndex - startIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 除去每个单词尾部空格， + 1 是最后一个单词的尾部空格的特殊处理，就是实际减去间隙的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceCount</span> <span class="hljs-operator">=</span> maxWidth + <span class="hljs-number">1</span> - wordCount;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= endIndex; i++) &#123;<br>            <span class="hljs-comment">// 除去所有单词的长度</span><br>            spaceCount -= words[i].length();<br>        &#125;<br><br>        <span class="hljs-comment">// 词尾空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceSuffix</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 额外空格的平均值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceAvg</span> <span class="hljs-operator">=</span> (wordCount == <span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : spaceCount / (wordCount - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 额外空格的余数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceExtra</span> <span class="hljs-operator">=</span> (wordCount == <span class="hljs-number">1</span>) ? <span class="hljs-number">0</span> : spaceCount % (wordCount - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; endIndex; i++) &#123;<br>            <span class="hljs-comment">// 填入单词</span><br>            ans.append(words[i]);<br>            <span class="hljs-comment">// 特殊处理最后一行，需要左对齐且空格一个</span><br>            <span class="hljs-keyword">if</span> (lastLine) &#123;<br>                ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 根据计算结果补上空格</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> spaceSuffix + spaceAvg;<br>            <span class="hljs-keyword">if</span> ((i - startIndex) &lt; spaceExtra) &#123;<br>                temp += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (temp-- &gt; <span class="hljs-number">0</span>) &#123;<br>                ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 填入最后一个单词</span><br>        ans.append(words[endIndex]);<br>        <span class="hljs-comment">// 补上这一行最后的空格</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> maxWidth - ans.length();<br>        <span class="hljs-keyword">while</span> (temp-- &gt; <span class="hljs-number">0</span>) &#123;<br>            ans.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lineLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; i++) &#123;<br>            lineLength += words[i].length() + <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 如果是最后一个单词，或者加上下一个词就超过长度了，即可凑成一行</span><br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == words.length || lineLength + words[i + <span class="hljs-number">1</span>].length() &gt; maxWidth) &#123;<br>                ans.add(fillWords(words, startIndex, i, maxWidth, i + <span class="hljs-number">1</span> == words.length));<br>                startIndex = i + <span class="hljs-number">1</span>;<br>                lineLength = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxWidth</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>        System.out.println(fullJustify(words, maxWidth));<br><br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;What&quot;</span>, <span class="hljs-string">&quot;must&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;acknowledgment&quot;</span>, <span class="hljs-string">&quot;shall&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>&#125;;<br>        maxWidth = <span class="hljs-number">16</span>;<br>        System.out.println(fullJustify(words, maxWidth));<br><br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;Science&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;what&quot;</span>, <span class="hljs-string">&quot;we&quot;</span>, <span class="hljs-string">&quot;understand&quot;</span>, <span class="hljs-string">&quot;well&quot;</span>, <span class="hljs-string">&quot;enough&quot;</span>, <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;explain&quot;</span>,<br>                <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;computer.&quot;</span>, <span class="hljs-string">&quot;Art&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;everything&quot;</span>, <span class="hljs-string">&quot;else&quot;</span>, <span class="hljs-string">&quot;we&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>&#125;;<br>        maxWidth = <span class="hljs-number">20</span>;<br>        System.out.println(fullJustify(words, maxWidth));<br><br><span class="hljs-comment">//        String[] words = new String[]&#123;&quot;What&quot;, &quot;must&quot;, &quot;bexx&quot;, &quot;a&quot;&#125;;</span><br><span class="hljs-comment">//        int maxWidth = 16;</span><br><span class="hljs-comment">//        System.out.println(fullJustify(words, maxWidth));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[This    <span class="hljs-keyword">is</span>    an, example  <span class="hljs-keyword">of</span> <span class="hljs-type">text</span>, justification.  ]<br>[What   must   be, acknowledgment  , shall be        ]<br>[Science  <span class="hljs-keyword">is</span>  what we, understand      well, enough <span class="hljs-keyword">to</span> <span class="hljs-keyword">explain</span> <span class="hljs-keyword">to</span>, a  computer.  Art <span class="hljs-keyword">is</span>, everything  <span class="hljs-keyword">else</span>  we, <span class="hljs-keyword">do</span>    <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>参考了其他的答主，主要是将空间拆开成三部分，很巧妙，可以参考下图。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AddBinary</title>
    <link href="/2021/04/27/AddBinary/"/>
    <url>/2021/04/27/AddBinary/</url>
    
    <content type="html"><![CDATA[<h4 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/27/AddBinary/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/27/AddBinary/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二进制求和-1"><a href="#二进制求和-1" class="headerlink" title="二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/">二进制求和</a></h4><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><strong>示例1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出: <span class="hljs-string">&quot;100&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1011&quot;</span><br>输出: <span class="hljs-string">&quot;10101&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个字符串仅由字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code> 组成。</li><li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li><li>字符串如果不是 <code>&quot;0&quot;</code> ，就都不含前导零。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddBinary</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(<span class="hljs-type">String</span> a, <span class="hljs-type">String</span> b)</span> </span>&#123;<br><br>        <span class="hljs-type">char</span>[] charsA = a.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-type">char</span>[] charsB = b.<span class="hljs-built_in">toCharArray</span>();<br>        <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = a.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = b.<span class="hljs-built_in">length</span>();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-type">int</span> max = Math.<span class="hljs-built_in">max</span>(m, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (m - i &gt;= <span class="hljs-number">0</span>) &#123;<br>                sum += charsA[m - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n - i &gt;= <span class="hljs-number">0</span>) &#123;<br>                sum += charsB[n - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            sum += step;<br>            StringBuilder temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>().<span class="hljs-built_in">append</span>(sum % <span class="hljs-number">2</span>);<br>            sb = temp.<span class="hljs-built_in">append</span>(sb);<br>            step = sum / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (step == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span> + sb;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">addBinary</span>(<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));<br><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">addBinary</span>(<span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-string">&quot;1011&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">100<br>10101<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PlusOne</title>
    <link href="/2021/04/25/PlusOne/"/>
    <url>/2021/04/25/PlusOne/</url>
    
    <content type="html"><![CDATA[<h4 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/25/PlusOne/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/25/PlusOne/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="加一-1"><a href="#加一-1" class="headerlink" title="加一"></a><a href="https://leetcode-cn.com/problems/plus-one/">加一</a></h4><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,2,4]</span><br>解释：输入数组表示数字 123。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：digits = [<span class="hljs-number">4,3,2,1</span>]<br>输出：[<span class="hljs-number">4,3,2,2</span>]<br>解释：输入数组表示数字 <span class="hljs-number">4321</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PlusOne &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] plusOne(<span class="hljs-keyword">int</span>[] digits) &#123;<br><br>        <span class="hljs-keyword">int</span> length = digits.length;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">step</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">int</span> temp = digits[i];<br>            digits[i] = (temp + <span class="hljs-keyword">step</span>) % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">step</span> = (temp + <span class="hljs-keyword">step</span>) / <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">step</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span>[] digitss = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length + <span class="hljs-number">1</span>];<br>            digitss[<span class="hljs-number">0</span>] = <span class="hljs-keyword">step</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>                digitss[i + <span class="hljs-number">1</span>] = digits[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> digitss;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">int</span>[] digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br><br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br><br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br><br>        digits = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">9</span>&#125; ;<br>        <span class="hljs-keyword">print</span>(plusOne(digits));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(<span class="hljs-keyword">int</span>[] digits) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> digit : digits) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(digit);<br>            System.out.<span class="hljs-keyword">print</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidNumber</title>
    <link href="/2021/04/22/ValidNumber/"/>
    <url>/2021/04/22/ValidNumber/</url>
    
    <content type="html"><![CDATA[<h4 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/22/ValidNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/22/ValidNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="有效数字-1"><a href="#有效数字-1" class="headerlink" title="有效数字"></a><a href="https://leetcode-cn.com/problems/valid-number/">有效数字</a></h4><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：</p><ul><li>[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</li></ul><p>部分无效数字列举如下：</p><ul><li><code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></li></ul><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;e&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.1&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">package algorithm;</span><br><span class="language-xml"></span><br><span class="language-xml">import java.util.HashMap;</span><br><span class="language-xml">import java.util.Map;</span><br><span class="language-xml"></span><br><span class="language-xml">public class ValidNumber &#123;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static boolean isNumber(String s) &#123;</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = new HashMap<span class="hljs-tag">&lt;&gt;</span>();</span><br><span class="language-xml"></span><br><span class="language-xml">        // 开始的字符，以及这个字符目前所处的状态</span><br><span class="language-xml">        Map&lt;CharType, State&gt; initialMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_INTEGER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_POINT</span>, State.STATE_POINT_WITHOUT_INT);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_SIGN</span>, State.STATE_INT_SIGN);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        // 开始状态所包含的下一步能含有的字符及状态，下面依次类推</span><br><span class="language-xml">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // +/-，以及这个字符目前所处的状态</span><br><span class="language-xml">        Map&lt;CharType, State&gt; intSignMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_INTEGER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_POINT</span>, State.STATE_POINT_WITHOUT_INT);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // 0-9</span><br><span class="language-xml">        Map&lt;CharType, State&gt; integerMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_INTEGER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_EXP</span>, State.STATE_EXP);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_POINT</span>, State.STATE_POINT);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // .</span><br><span class="language-xml">        Map&lt;CharType, State&gt; pointMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_FRACTION);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_EXP</span>, State.STATE_EXP);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // .</span><br><span class="language-xml">        Map&lt;CharType, State&gt; pointWithoutIntMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_FRACTION);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;CharType, State&gt; fractionMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_FRACTION);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_EXP</span>, State.STATE_EXP);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        // E/e</span><br><span class="language-xml">        Map&lt;CharType, State&gt; expMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_EXP_NUMBER);</span><br><span class="hljs-template-variable">            put(<span class="hljs-name">CharType.CHAR_SIGN</span>, State.STATE_EXP_SIGN);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;CharType, State&gt; expSignMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_EXP_NUMBER);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        Map&lt;CharType, State&gt; expNumberMap = new HashMap&lt;CharType, State&gt;() </span><span class="hljs-template-variable">&#123;&#123;</span><br><span class="hljs-template-variable">            <span class="hljs-name">put</span>(<span class="hljs-name">CharType.CHAR_NUMBER</span>, State.STATE_EXP_NUMBER);</span><br><span class="hljs-template-variable">        &#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="language-xml"></span><br><span class="language-xml">        int length = s.length();</span><br><span class="language-xml">        State state = State.STATE_INITIAL;</span><br><span class="language-xml"></span><br><span class="language-xml">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="language-xml">            CharType type = toCharType(s.charAt(i));</span><br><span class="language-xml">            if (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="language-xml">                return false;</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            state = transfer.get(state).get(type);</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">        return state == State.STATE_INTEGER || state == State.STATE_POINT</span><br><span class="language-xml">                || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER</span><br><span class="language-xml">                || state == State.STATE_END;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static CharType toCharType(char ch) &#123;</span><br><span class="language-xml">        if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_NUMBER;</span><br><span class="language-xml">        &#125; else if (ch == &#x27;e&#x27; || ch == &#x27;E&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_EXP;</span><br><span class="language-xml">        &#125; else if (ch == &#x27;.&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_POINT;</span><br><span class="language-xml">        &#125; else if (ch == &#x27;+&#x27; || ch == &#x27;-&#x27;) &#123;</span><br><span class="language-xml">            return CharType.CHAR_SIGN;</span><br><span class="language-xml">        &#125; else &#123;</span><br><span class="language-xml">            return CharType.CHAR_ILLEGAL;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    enum State &#123;</span><br><span class="language-xml">        // 初始</span><br><span class="language-xml">        STATE_INITIAL,</span><br><span class="language-xml">        // 符号位+/-</span><br><span class="language-xml">        STATE_INT_SIGN,</span><br><span class="language-xml">        // 整数部分</span><br><span class="language-xml">        STATE_INTEGER,</span><br><span class="language-xml">        // 左侧有整数的小数点</span><br><span class="language-xml">        STATE_POINT,</span><br><span class="language-xml">        // 左侧无整数的小数点</span><br><span class="language-xml">        STATE_POINT_WITHOUT_INT,</span><br><span class="language-xml">        // 小数部分</span><br><span class="language-xml">        STATE_FRACTION,</span><br><span class="language-xml">        // 字符e</span><br><span class="language-xml">        STATE_EXP,</span><br><span class="language-xml">        // 指数部分的符号位+/-</span><br><span class="language-xml">        STATE_EXP_SIGN,</span><br><span class="language-xml">        // 指数部分的整数部分</span><br><span class="language-xml">        STATE_EXP_NUMBER,</span><br><span class="language-xml">        // 结束</span><br><span class="language-xml">        STATE_END,</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    enum CharType &#123;</span><br><span class="language-xml">        CHAR_NUMBER,</span><br><span class="language-xml">        CHAR_EXP,</span><br><span class="language-xml">        CHAR_POINT,</span><br><span class="language-xml">        CHAR_SIGN,</span><br><span class="language-xml">        CHAR_ILLEGAL,</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static void main(String[] args) &#123;</span><br><span class="language-xml">        System.out.println(isNumber(&quot;0&quot;));</span><br><span class="language-xml">        System.out.println(isNumber(&quot;e&quot;));</span><br><span class="language-xml">        System.out.println(isNumber(&quot;.&quot;));</span><br><span class="language-xml">        System.out.println(isNumber(&quot;.1&quot;));</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上直接抄了官方，虽然效率不是很高，主要是解题方式是有限状态机的设计。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MinimumPathSum</title>
    <link href="/2021/04/20/MinimumPathSum/"/>
    <url>/2021/04/20/MinimumPathSum/</url>
    
    <content type="html"><![CDATA[<h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/20/MinimumPathSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/20/MinimumPathSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最小路径和-1"><a href="#最小路径和-1" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/minpath.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs inform7">package algorithm;<br><br>public class MinimumPathSum &#123;<br><br>    public static int minPathSum(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> grid) &#123;<br><br>        int m = grid.length;<br>        int n = grid<span class="hljs-comment">[0]</span>.length;<br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> score = new int<span class="hljs-comment">[grid.length]</span><span class="hljs-comment">[grid<span class="hljs-comment">[0]</span>.length]</span>;<br>        score<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>;<br><br>        for (int i = 1; i &lt; m; i++) &#123;<br>            score<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = score<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>;<br>        &#125;<br>        for (int i = 1; i &lt; n; i++) &#123;<br>            score<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = score<span class="hljs-comment">[0]</span><span class="hljs-comment">[i - 1]</span> + grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>;<br>        &#125;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            for (int j = 1; j &lt; n; j++) &#123;<br>                score<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> + Math.min(score<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, score<span class="hljs-comment">[i]</span><span class="hljs-comment">[j -1]</span>);<br>            &#125;<br>        &#125;<br><br>        return score<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br><br>    public static void main(String<span class="hljs-comment">[]</span> args) &#123;<br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> grid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;1,3,1&#125;, &#123;1,5,1&#125;, &#123;4,2,1&#125;&#125;;<br>        System.out.println(minPathSum(grid));<br><br>        grid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;;<br>        System.out.println(minPathSum(grid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">7<br>12<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路不是很难，就是写个动态方程求解。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniquePathsII</title>
    <link href="/2021/04/17/UniquePathsII/"/>
    <url>/2021/04/17/UniquePathsII/</url>
    
    <content type="html"><![CDATA[<h4 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/17/UniquePathsII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/17/UniquePathsII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同路径-II-1"><a href="#不同路径-II-1" class="headerlink" title="不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II</a></h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot_maze.png" alt="img"></p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot1.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>m &#x3D;&#x3D; obstacleGrid.length</li><li>n &#x3D;&#x3D; obstacleGrid[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs inform7">package algorithm;<br><br>public class UniquePathsII &#123;<br><br>    public static int uniquePathsWithObstacles(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;<br>        int m = obstacleGrid.length;<br>        int n = obstacleGrid<span class="hljs-comment">[0]</span>.length;<br><br>        if (obstacleGrid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> == 1 || obstacleGrid<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span> == 1) &#123;<br>            return 0;<br>        &#125;<br><br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> path = new int<span class="hljs-comment">[m]</span><span class="hljs-comment">[n]</span>;<br>        path<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> == 0) &#123;<br>                path<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = path<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span>;<br>            &#125; else &#123;<br>                path<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = 0;<br>            &#125;<br>        &#125;<br>        for (int i = 1; i &lt; n; i++) &#123;<br>            if (obstacleGrid<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> == 0) &#123;<br>                path<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = path<span class="hljs-comment">[0]</span><span class="hljs-comment">[i - 1]</span>;<br>            &#125; else &#123;<br>                path<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = 0;<br>            &#125;<br>        &#125;<br><br>        for (int i = 1; i &lt; m; i++) &#123;<br>            for (int j = 1; j &lt; n; j++) &#123;<br>                if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> == 1) &#123;<br>                    path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 0;<br>                &#125; else &#123;<br>                    path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = path<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return path<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br><br>    public int uniquePathsWithObstacles1(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;<br>        int n = obstacleGrid.length, m = obstacleGrid<span class="hljs-comment">[0]</span>.length;<br>        int<span class="hljs-comment">[]</span> f = new int<span class="hljs-comment">[m]</span>;<br><br>        // 存储列，其实存储行也一样，默认的第一列后面的元素不计算，因为本身就是1，<br>        // 因为有置0的存在，所以不必担心其中有障碍物的情况<br>        f<span class="hljs-comment">[0]</span> = obstacleGrid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> == 0 ? 1 : 0;<br>        for (int i = 0; i &lt; n; ++i) &#123;<br>            for (int j = 0; j &lt; m; ++j) &#123;<br>                if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> == 1) &#123;<br>                    f<span class="hljs-comment">[j]</span> = 0;<br>                    continue;<br>                &#125;<br>                // 其实本格子就是左和上，上也就是上个f<span class="hljs-comment">[j]</span>，左就是f<span class="hljs-comment">[j-1]</span>，这个需要思考下，所以这是滚动数组<br>                if (j - 1 &gt;= 0 &amp;&amp; obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span> == 0) &#123;<br>                    f<span class="hljs-comment">[j]</span> += f<span class="hljs-comment">[j - 1]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return f<span class="hljs-comment">[m - 1]</span>;<br>    &#125;<br><br>    public static void main(String<span class="hljs-comment">[]</span> args) &#123;<br>        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;0,0,0&#125;,&#123;0,1,0&#125;,&#123;0,0,0&#125;&#125;;<br>        System.out.println(uniquePathsWithObstacles(obstacleGrid));<br><br>        obstacleGrid = new int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span>&#123;&#123;0,1&#125;,&#123;0,0&#125;&#125;;<br>        System.out.println(uniquePathsWithObstacles(obstacleGrid));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>代码给了两种解法，一种是基于上一题的延伸，一种是官方的解法，更加精炼，而且用到了滚动数组。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UniquePaths</title>
    <link href="/2021/04/16/UniquePaths/"/>
    <url>/2021/04/16/UniquePaths/</url>
    
    <content type="html"><![CDATA[<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/16/UniquePaths/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/16/UniquePaths/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="不同路径-1"><a href="#不同路径-1" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/robot_maze.png" alt="img"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 2∗109</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UniquePaths &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> uniquePaths(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] <span class="hljs-type">path</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m][n];<br>        <span class="hljs-type">path</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-type">path</span>[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">path</span>[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">path</span>[i][j] = <span class="hljs-type">path</span>[i - <span class="hljs-number">1</span>][j] + <span class="hljs-type">path</span>[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">path</span>[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">28<br>3<br>28<br>6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。写出动态方程就解决了。不过另外的解法，太过简单，巧妙的是居然这是一道数学题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RotateList</title>
    <link href="/2021/04/13/RotateList/"/>
    <url>/2021/04/13/RotateList/</url>
    
    <content type="html"><![CDATA[<h4 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/13/RotateList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/13/RotateList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="旋转链表-1"><a href="#旋转链表-1" class="headerlink" title="旋转链表"></a><a href="https://leetcode-cn.com/problems/rotate-list/">旋转链表</a></h4><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/rotate1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/roate2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4<br>输出：<span class="hljs-comment">[2,0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 2 * 109</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> RotateList &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode rotateRight(ListNode head, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode cur = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>) &#123;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>            length++;<br>        &#125;<br>        ListNode tail = cur;<br><br>        <span class="hljs-keyword">int</span> position = length - k % length;<br>        <span class="hljs-keyword">if</span> (position == length) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">step</span> = <span class="hljs-number">0</span>;<br>        ListNode prev = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> (cur.<span class="hljs-keyword">next</span> != <span class="hljs-keyword">null</span>) &#123;<br>            prev = cur;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">step</span> == position) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        tail.<span class="hljs-keyword">next</span> = head;<br>        prev.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-comment">// 输入：head = [1,2,3,4,5], k = 2</span><br>        <span class="hljs-comment">// 输出：[4,5,1,2,3]</span><br>        ListNode node5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>);<br>        ListNode node4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>, node5);<br>        ListNode node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>, node4);<br>        ListNode node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>, node3);<br>        ListNode node1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>, node2);<br>        <span class="hljs-keyword">print</span>(rotateRight(node1, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 输入：head = [0,1,2], k = 4</span><br>        <span class="hljs-comment">// 输出：[2,0,1]</span><br>        node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>, <span class="hljs-keyword">null</span>);<br>        node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>, node3);<br>        node1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, node2);<br>        <span class="hljs-keyword">print</span>(rotateRight(node1, <span class="hljs-number">4</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.<span class="hljs-keyword">println</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> ListNode &#123;<br>        <span class="hljs-keyword">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-keyword">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-keyword">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<br><span class="hljs-number">2</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">1</span>-&gt;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，其实很简单。官方排的困难有些其实很简单，有些就很难了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PermutationSequence</title>
    <link href="/2021/04/11/PermutationSequence/"/>
    <url>/2021/04/11/PermutationSequence/</url>
    
    <content type="html"><![CDATA[<h4 id="排列序列"><a href="#排列序列" class="headerlink" title="排列序列"></a>排列序列</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/11/PermutationSequence/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/11/PermutationSequence/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="排列序列-1"><a href="#排列序列-1" class="headerlink" title="排列序列"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/">排列序列</a></h4><p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p><p><strong>示例1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;213&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">4</span>, k = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">&quot;2314&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li><code>1 &lt;= k &lt;= n!</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PermutationSequence &#123;<br><br>    <span class="hljs-built_in">public</span> static String getPermutation(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span>[] factorial = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        // 记录n!有多少个数字组合<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            factorial[i] = factorial[i - <span class="hljs-number">1</span>] * i;<br>        &#125;<br><br>        <span class="hljs-comment">--k;</span><br>        StringBuffer ans = <span class="hljs-built_in">new</span> StringBuffer();<br>        <span class="hljs-type">int</span>[] <span class="hljs-keyword">valid</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(<span class="hljs-keyword">valid</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            // 找到第一个位置，k<span class="hljs-number">-1</span>是为了防止整除越界，因为一定会加<span class="hljs-number">1</span><br>            // 如果k整除又加<span class="hljs-number">1</span>，会最后一个多一位，下面也是如此<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">order</span> = k / factorial[n - i] + <span class="hljs-number">1</span>;<br>            // 记录目前使用的数字，已经使用过的当然跳过，<br>            // 不是说<span class="hljs-keyword">order</span>等于<span class="hljs-number">3</span>就选<span class="hljs-number">3</span>，而是选目前剩下的排第三的，<br>            // 所以这个<span class="hljs-keyword">order</span>算法太巧妙了<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">order</span> -= <span class="hljs-keyword">valid</span>[j];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">order</span> == <span class="hljs-number">0</span>) &#123;<br>                    ans.append(j);<br>                    <span class="hljs-keyword">valid</span>[j] = <span class="hljs-number">0</span>;<br>                    break;<br>                &#125;<br>            &#125;<br>            // 注意是i，不是<span class="hljs-number">1</span>，这里没有用公式+<span class="hljs-number">1</span>，相当于k自动减一，很巧妙<br>            k %= factorial[n - i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getPermutation(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getPermutation(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(getPermutation(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">213</span><br><span class="hljs-number">2314</span><br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是一道数学题呗。不过，官方的解题技巧太妙了，可以反复看。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpiralMatrixII</title>
    <link href="/2021/04/08/SpiralMatrixII/"/>
    <url>/2021/04/08/SpiralMatrixII/</url>
    
    <content type="html"><![CDATA[<h4 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/08/SpiralMatrixII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/08/SpiralMatrixII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="螺旋矩阵-II-1"><a href="#螺旋矩阵-II-1" class="headerlink" title="螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵 II</a></h4><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/spiraln.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3],[8,9,4],[7,6,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SpiralMatrixII &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n][n];<br><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> bottom = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> column = left; <span class="hljs-keyword">column</span> &lt;= right; <span class="hljs-keyword">column</span>++) &#123;<br>                ans[top][<span class="hljs-keyword">column</span>] = ++num;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = top + <span class="hljs-number">1</span>; <span class="hljs-keyword">row</span> &lt;= bottom; <span class="hljs-keyword">row</span>++) &#123;<br>                ans[<span class="hljs-keyword">row</span>][right] = ++num;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> column = right - <span class="hljs-number">1</span>; <span class="hljs-keyword">column</span> &gt; left; <span class="hljs-keyword">column</span><span class="hljs-comment">--) &#123;</span><br>                    ans[bottom][<span class="hljs-keyword">column</span>] = ++num;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = bottom; <span class="hljs-keyword">row</span> &gt; top; <span class="hljs-keyword">row</span><span class="hljs-comment">--) &#123;</span><br>                    ans[<span class="hljs-keyword">row</span>][left] = ++num;<br>                &#125;<br>            &#125;<br>            left++;<br>            right<span class="hljs-comment">--;</span><br>            bottom<span class="hljs-comment">--;</span><br>            top++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        print(generateMatrix(<span class="hljs-number">3</span>));<br><br>        print(generateMatrix(<span class="hljs-number">1</span>));<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(anInt);<br>            &#125;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">123<br>894<br>765<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，和螺旋矩阵1很类似。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LengthOfLastWord</title>
    <link href="/2021/04/06/LengthOfLastWord/"/>
    <url>/2021/04/06/LengthOfLastWord/</url>
    
    <content type="html"><![CDATA[<h4 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/06/LengthOfLastWord/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/06/LengthOfLastWord/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最后一个单词的长度-1"><a href="#最后一个单词的长度-1" class="headerlink" title="最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">最后一个单词的长度</a></h4><p>给你一个字符串 <code>s</code>，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;s.length&lt;&#x3D;104</li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LengthOfLastWord &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> lengthOfLastWord(String s) &#123;<br><br>        <span class="hljs-type">int</span> end = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">end</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(<span class="hljs-keyword">end</span>) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span> &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-keyword">end</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(<span class="hljs-keyword">start</span>) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">start</span><span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span> - <span class="hljs-keyword">start</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLastWord(&quot;Hello World&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLastWord(&quot; &quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，属于简单题目，看代码即可。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InsertInterval</title>
    <link href="/2021/04/01/InsertInterval/"/>
    <url>/2021/04/01/InsertInterval/</url>
    
    <content type="html"><![CDATA[<h4 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a>插入区间</h4><ul><li><a href="https://yangtzeshore.github.io/2021/04/01/InsertInterval/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/04/01/InsertInterval/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="插入区间-1"><a href="#插入区间-1" class="headerlink" title="插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/">插入区间</a></h4><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[12,16]</span>]</span>, newInterval = <span class="hljs-comment">[4,8]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,10]</span>,<span class="hljs-comment">[12,16]</span>]</span><br>解释：这是因为新的区间 <span class="hljs-comment">[4,8]</span> 与 <span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span> 重叠。<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = [], newInterval = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-string">[[5,7]]</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,5]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-string">[[1,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,5]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-string">[[1,7]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0&lt;&#x3D;intervals.length&lt;&#x3D;104</li><li><code>intervals[i].length == 2</code></li><li>0&lt;&#x3D;intervals[i][0]&lt;&#x3D;intervals[i][1]&lt;&#x3D;105</li><li><code>intervals</code> 根据 <code>intervals[i][0]</code> 按 <strong>升序</strong> 排列</li><li><code>newInterval.length == 2</code></li><li>0&lt;&#x3D;newInterval[0]&lt;&#x3D;newInterval[1]&lt;&#x3D;105</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">InsertInterval</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">int</span>[][] insert(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals, <span class="hljs-built_in">int</span>[] newInterval) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals == <span class="hljs-literal">null</span> || <span class="hljs-built_in">int</span>ervals.length == <span class="hljs-number">0</span> || <span class="hljs-built_in">int</span>ervals[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> new <span class="hljs-built_in">int</span>[][]&#123;&#123;newInterval[<span class="hljs-number">0</span>], newInterval[<span class="hljs-number">1</span>]&#125;&#125;;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> left = newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">int</span> right = newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 1 插入</span><br>        <span class="hljs-comment">// 2 合并，包括跨一个，和多个</span><br>        <span class="hljs-comment">// 想象成游标右移</span><br>        List&lt;<span class="hljs-built_in">int</span>[]&gt; ans = new ArrayList&lt;&gt;();<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-built_in">int</span>ervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &lt; left) &#123;<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-built_in">int</span>ervals.length - <span class="hljs-number">1</span>) &#123;<br>                    ans.add(new <span class="hljs-built_in">int</span>[]&#123;left, right&#125;);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &gt; right) &#123;<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;left, right&#125;);<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &gt;= right) &#123;<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;Math.min(left, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = Math.min(left, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]);<br>                i++;<br>                <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">int</span>ervals.length &amp;&amp; right &gt;= <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>]) &#123;<br>                    i++;<br>                &#125;<br>                i--;<br>                right = Math.max(right, <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]);<br>                ans.add(new <span class="hljs-built_in">int</span>[]&#123;left, right&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (++i &lt; <span class="hljs-built_in">int</span>ervals.length) &#123;<br>            ans.add(new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>]&#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans.toArray(new <span class="hljs-built_in">int</span>[ans.size()][]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br>        <span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;&#125;;<br>        <span class="hljs-built_in">int</span>[] newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">12</span>, <span class="hljs-number">16</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">8</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [], newInterval = [5,7]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [[1,5]], newInterval = [2,3]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-comment">// intervals = [[1,5]], newInterval = [2,7]</span><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">7</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>        newInterval = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br>        System.<span class="hljs-keyword">out</span>.println(Arrays.deepToString(insert(<span class="hljs-built_in">int</span>ervals, newInterval)));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[1, 5], [6, 9]]</span><br><span class="hljs-string">[[1, 2], [3, 10], [12, 16]]</span><br><span class="hljs-string">[[5, 7]]</span><br><span class="hljs-string">[[1, 5]]</span><br><span class="hljs-string">[[1, 7]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，可以将插入的值作为游标滑动在原数组上。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LowestCommonAncestorOfABinarySearchTree</title>
    <link href="/2021/03/31/LowestCommonAncestorOfABinarySearchTree/"/>
    <url>/2021/03/31/LowestCommonAncestorOfABinarySearchTree/</url>
    
    <content type="html"><![CDATA[<h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/31/LowestCommonAncestorOfABinarySearchTree/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/31/LowestCommonAncestorOfABinarySearchTree/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="二叉搜索树的最近公共祖先-1"><a href="#二叉搜索树的最近公共祖先-1" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/binarysearchtree_improved.png" alt="img"></p><p><strong>示例1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="hljs-section">输出: 6 </span><br><span class="hljs-section">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LowestCommonAncestorOfABinarySearchTree</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;<br><br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> == p.<span class="hljs-keyword">val</span> || root.<span class="hljs-keyword">val</span> == q.<span class="hljs-keyword">val</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> &lt; Math.min(p.<span class="hljs-keyword">val</span>, q.<span class="hljs-keyword">val</span>)) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> &gt; Math.max(p.<span class="hljs-keyword">val</span>, q.<span class="hljs-keyword">val</span>)) &#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        int <span class="hljs-keyword">val</span>;<br>        TreeNode left;<br>        TreeNode right;<br><br>        TreeNode(int x) &#123;<br>            <span class="hljs-keyword">val</span> = x;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是题目说的，简单。提前做这道题的缘由是看到微软的面试有，所以看下，没想到这么简单。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeIntervals</title>
    <link href="/2021/03/29/MergeIntervals/"/>
    <url>/2021/03/29/MergeIntervals/</url>
    
    <content type="html"><![CDATA[<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/29/MergeIntervals/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/29/MergeIntervals/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="合并区间-1"><a href="#合并区间-1" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h4><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 intervals[i]&#x3D;[starti,endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;intervals.length&lt;&#x3D;104</li><li><code>intervals[i].length == 2</code></li><li>0&lt;&#x3D;starti&lt;&#x3D;endi&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MergeIntervals</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">int</span>[][] merge(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals) &#123;<br><br>        <span class="hljs-comment">// 排序+合并</span><br>        Arrays.sort(<span class="hljs-built_in">int</span>ervals, (<span class="hljs-built_in">int</span>erval1, <span class="hljs-built_in">int</span>erval2) -&gt; <span class="hljs-built_in">int</span>erval1[<span class="hljs-number">0</span>] - <span class="hljs-built_in">int</span>erval2[<span class="hljs-number">0</span>]);<br><br>        List&lt;<span class="hljs-built_in">int</span>[]&gt; ans = new ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>ervals.length; i++) &#123;<br>            <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (ans.size() == <span class="hljs-number">0</span> || ans.<span class="hljs-keyword">get</span>(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                ans.add(<span class="hljs-built_in">int</span>ervals[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-keyword">get</span>(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(ans.<span class="hljs-keyword">get</span>(ans.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toArray(new <span class="hljs-built_in">int</span>[ans.size()][]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>        <span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">18</span>&#125;&#125;;<br>        print(merge(<span class="hljs-built_in">int</span>ervals));<br><br>        <span class="hljs-built_in">int</span>ervals = new <span class="hljs-built_in">int</span>[][] &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br>        print(merge(<span class="hljs-built_in">int</span>ervals));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static <span class="hljs-built_in">void</span> print(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span>[] <span class="hljs-built_in">int</span>erval : <span class="hljs-built_in">int</span>ervals) &#123;<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;[&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-built_in">int</span>erval[<span class="hljs-number">0</span>]);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;,&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-built_in">int</span>erval[<span class="hljs-number">1</span>]);<br>            System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;, &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[1,6]</span><span class="hljs-selector-attr">[8,10]</span><span class="hljs-selector-attr">[15,18]</span>, <span class="hljs-selector-attr">[1,5]</span>, <br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是排序和比较，不过效率很低。后续有时间，写一个效率好一点的算法。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JumpGame</title>
    <link href="/2021/03/28/JumpGame/"/>
    <url>/2021/03/28/JumpGame/</url>
    
    <content type="html"><![CDATA[<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/28/JumpGame/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/28/JumpGame/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="跳跃游戏-1"><a href="#跳跃游戏-1" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></h4><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为<span class="hljs-number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="hljs-number"> 0 </span>， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;3∗104</li><li>0&lt;&#x3D;nums[i]&lt;&#x3D;105</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JumpGame</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> last = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lastFlag = last;<br>        <span class="hljs-type">boolean</span>[] flags = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = last; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (i + nums[i] &gt;= lastFlag) &#123;<br>                flags[i] = <span class="hljs-literal">true</span>;<br>                lastFlag = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> flags[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">canJump</span>(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">canJump</span>(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是一个简单的动态规划方程。官方的贪吃当然效率会更好一点。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpiralMatrix</title>
    <link href="/2021/03/28/SpiralMatrix/"/>
    <url>/2021/03/28/SpiralMatrix/</url>
    
    <content type="html"><![CDATA[<h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/27/SpiralMatrix/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/27/SpiralMatrix/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="螺旋矩阵-1"><a href="#螺旋矩阵-1" class="headerlink" title="螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵</a></h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/spiral1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/spiral.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>m &#x3D;&#x3D; matrix.length</li><li>n &#x3D;&#x3D; matrix[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 10</li><li>-100 &lt;&#x3D; matrix[i][j]&lt;&#x3D; 100</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml">package algorithm;</span><br><span class="language-xml"></span><br><span class="language-xml">import java.util.ArrayList;</span><br><span class="language-xml">import java.util.List;</span><br><span class="language-xml"></span><br><span class="language-xml">public class SpiralMatrix &#123;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static List<span class="hljs-tag">&lt;<span class="hljs-name">Integer</span>&gt;</span> spiralOrder(int[][] matrix) &#123;</span><br><span class="language-xml">        List<span class="hljs-tag">&lt;<span class="hljs-name">Integer</span>&gt;</span> ans = new ArrayList<span class="hljs-tag">&lt;&gt;</span>();</span><br><span class="language-xml">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="language-xml">            return ans;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml">        int rows = matrix.length;</span><br><span class="language-xml">        int cols = matrix[0].length;</span><br><span class="language-xml">        int left = 0;</span><br><span class="language-xml">        int right = cols - 1;</span><br><span class="language-xml">        int top = 0;</span><br><span class="language-xml">        int bottom = rows - 1;</span><br><span class="language-xml">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="language-xml">            for (int column = left; column &lt;= right; column ++) &#123;</span><br><span class="language-xml">                ans.add(matrix[top][column]);</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            for (int row = top + 1; row &lt;= bottom; row ++) &#123;</span><br><span class="language-xml">                ans.add(matrix[row][right]);</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="language-xml">                for (int column = right - 1; column &gt; left; column --) &#123;</span><br><span class="language-xml">                    ans.add(matrix[bottom][column]);</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">                for (int row = bottom; row &gt; top; row --) &#123;</span><br><span class="language-xml">                    ans.add(matrix[row][left]);</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">            &#125;</span><br><span class="language-xml">            top ++;</span><br><span class="language-xml">            right --;</span><br><span class="language-xml">            bottom --;</span><br><span class="language-xml">            left ++;</span><br><span class="language-xml">        &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">        return ans;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"></span><br><span class="language-xml">    public static void main(String[] args) &#123;</span><br><span class="language-xml">        int[][] matrix = new int[][]</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        System.out.println(spiralOrder(matrix));</span><br><span class="language-xml"></span><br><span class="language-xml">        matrix = new int[][] </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        System.out.println(spiralOrder(matrix));</span><br><span class="language-xml"></span><br><span class="language-xml">        matrix = new int[][]</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>&#125;&#125;</span><span class="language-xml">;</span><br><span class="language-xml">        System.out.println(spiralOrder(matrix));</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 2, 3, 6, 9, 8, 7, 4, 5]</span><br><span class="hljs-string">[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</span><br><span class="hljs-string">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是把一个矩形成一个一个外在的框。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MaximumSubarray</title>
    <link href="/2021/03/27/MaximumSubarray/"/>
    <url>/2021/03/27/MaximumSubarray/</url>
    
    <content type="html"><![CDATA[<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/25/MaximumSubarray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/25/MaximumSubarray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最大子序和-1"><a href="#最大子序和-1" class="headerlink" title="最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></h4><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1&lt;&#x3D;nums.length&lt;&#x3D;3∗104</li><li>−105&lt;&#x3D;nums[i]&lt;&#x3D;105</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MaximumSubarray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> maxSubArray(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-type">int</span> prev = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max = <span class="hljs-type">Integer</span>.MIN_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            prev = Math.max(prev + nums[i], nums[i]);<br>            <span class="hljs-keyword">if</span> (max &lt; prev) &#123;<br>                max = prev;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-100000</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(maxSubArray(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">6<br>1<br>0<br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-100000</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是一个简单的动态规划方程，至于发散开来的线段树目前没有写出来。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NQueensII</title>
    <link href="/2021/03/23/NQueensII/"/>
    <url>/2021/03/23/NQueensII/</url>
    
    <content type="html"><![CDATA[<h4 id="N皇后-II"><a href="#N皇后-II" class="headerlink" title="N皇后 II"></a>N皇后 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/23/NQueensII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/23/NQueensII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="N皇后-II-1"><a href="#N皇后-II-1" class="headerlink" title="N皇后 II"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">N皇后 II</a></h4><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/queens.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NQueensII &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> totalNQueens(<span class="hljs-type">int</span> n) &#123;<br><br>        <span class="hljs-type">int</span>[] queens = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        Arrays.fill(queens, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span> = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br><br>        // 从第<span class="hljs-number">0</span>行开始<br>        <span class="hljs-keyword">return</span> track(queens, n, <span class="hljs-number">0</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br>    &#125;<br><br>    private static <span class="hljs-type">Integer</span> track(<span class="hljs-type">int</span>[] queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>,<br>                              <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span>, <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1,<br>                              <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            // 每一行都要从第<span class="hljs-number">0</span>列开始遍历<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">columns</span>.contains(i)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = <span class="hljs-keyword">row</span> - i;<br>                <span class="hljs-keyword">if</span> (diagonals1.contains(diagonal1)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = <span class="hljs-keyword">row</span> + i;<br>                <span class="hljs-keyword">if</span> (diagonals2.contains(diagonal2)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[<span class="hljs-keyword">row</span>] = i;<br>                <span class="hljs-keyword">columns</span>.<span class="hljs-keyword">add</span>(i);<br>                diagonals1.<span class="hljs-keyword">add</span>(diagonal1);<br>                diagonals2.<span class="hljs-keyword">add</span>(diagonal2);<br>                count += track(queens, n, <span class="hljs-keyword">row</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br>                queens[<span class="hljs-keyword">row</span>] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">columns</span>.remove(i);<br>                diagonals1.remove(diagonal1);<br>                diagonals2.remove(diagonal2);<br>            &#125;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(totalNQueens(<span class="hljs-number">4</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(totalNQueens(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是回溯，把上一个的解法稍微改一下。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NQueens</title>
    <link href="/2021/03/21/NQueens/"/>
    <url>/2021/03/21/NQueens/</url>
    
    <content type="html"><![CDATA[<h4 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/21/NQueens/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/21/NQueens/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="N-皇后-1"><a href="#N-皇后-1" class="headerlink" title="N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/">N 皇后</a></h4><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/queens.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[&quot;Q&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NQueens &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-type">int</span> n) &#123;<br>        List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-type">int</span>[] queens = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];<br>        Arrays.fill(queens, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span> = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2 = <span class="hljs-built_in">new</span> HashSet&lt;&gt;();<br><br>        // 从第<span class="hljs-number">0</span>行开始<br>        track(ans, queens, n, <span class="hljs-number">0</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> track(List&lt;List&lt;String&gt;&gt; ans, <span class="hljs-type">int</span>[] queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> <span class="hljs-keyword">row</span>,<br>                                            <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">columns</span>, <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals1,<br>                                            <span class="hljs-keyword">Set</span>&lt;<span class="hljs-type">Integer</span>&gt; diagonals2) &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == n) &#123;<br>            List&lt;String&gt; strings = generateBoard(n, queens);<br>            ans.<span class="hljs-keyword">add</span>(strings);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // 每一行都要从第<span class="hljs-number">0</span>列开始遍历<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">columns</span>.contains(i)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = <span class="hljs-keyword">row</span> - i;<br>                <span class="hljs-keyword">if</span> (diagonals1.contains(diagonal1)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = <span class="hljs-keyword">row</span> + i;<br>                <span class="hljs-keyword">if</span> (diagonals2.contains(diagonal2)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[<span class="hljs-keyword">row</span>] = i;<br>                <span class="hljs-keyword">columns</span>.<span class="hljs-keyword">add</span>(i);<br>                diagonals1.<span class="hljs-keyword">add</span>(diagonal1);<br>                diagonals2.<span class="hljs-keyword">add</span>(diagonal2);<br>                track(ans, queens, n, <span class="hljs-keyword">row</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">columns</span>, diagonals1, diagonals2);<br>                queens[<span class="hljs-keyword">row</span>] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">columns</span>.remove(i);<br>                diagonals1.remove(diagonal1);<br>                diagonals2.remove(diagonal2);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    private static List&lt;String&gt; generateBoard(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[] queens) &#123;<br>        List&lt;String&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">char</span>[] <span class="hljs-keyword">row</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[n];<br>            Arrays.fill(<span class="hljs-keyword">row</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-keyword">row</span>[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            String s = <span class="hljs-built_in">new</span> String(<span class="hljs-keyword">row</span>);<br>            result.<span class="hljs-keyword">add</span>(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(solveNQueens(<span class="hljs-number">4</span>));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(solveNQueens(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[.Q.., ...Q, Q..., ..Q.], [..Q., Q..., ...Q, .Q..]]</span><br><span class="hljs-string">[[Q]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是回溯。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pow(x, n)</title>
    <link href="/2021/03/20/PowxN/"/>
    <url>/2021/03/20/PowxN/</url>
    
    <content type="html"><![CDATA[<h4 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/20/PowxN/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/20/PowxN/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="Pow-x-n-1"><a href="#Pow-x-n-1" class="headerlink" title="Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">Pow(x, n)</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。</p><p><strong>示例1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.00000</span>, n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1024.00000</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.10000</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">9.26100</span><br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.00000</span>, n = -<span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.25000</span><br>解释：<span class="hljs-number">2</span>-<span class="hljs-number">2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0</span>.<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li>−231&lt;&#x3D;n&lt;&#x3D;231−1</li><li>−104&lt;&#x3D;xn&lt;&#x3D;104</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PowxN</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">myPow</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">int</span> n</span>)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> n &gt;= <span class="hljs-number">0</span> ? getMulti(x, n) :  <span class="hljs-number">1.0</span> / getMulti(x, -(<span class="hljs-built_in">long</span>) n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">getMulti</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">long</span> n</span>)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">double</span> multi = getMulti(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? multi * multi * x : multi * multi;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><br>        <span class="hljs-built_in">double</span> x = <span class="hljs-number">2.00000</span>;<br>        <span class="hljs-built_in">int</span> n = <span class="hljs-number">10</span>;<br>        System.<span class="hljs-keyword">out</span>.println(myPow(x, n));<br><br>        x = <span class="hljs-number">2.10000</span>;<br>        n = <span class="hljs-number">3</span>;<br>        System.<span class="hljs-keyword">out</span>.println(myPow(x, n));<br><br>        x = <span class="hljs-number">2.00000</span>;<br>        n = <span class="hljs-number">-2</span>;<br>        System.<span class="hljs-keyword">out</span>.println(myPow(x, n));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1024</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">9</span>.<span class="hljs-number">261000000000001</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，就是递归和二分。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GroupAnagrams</title>
    <link href="/2021/03/16/GroupAnagrams/"/>
    <url>/2021/03/16/GroupAnagrams/</url>
    
    <content type="html"><![CDATA[<h4 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/16/GroupAnagrams/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/16/GroupAnagrams/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="字母异位词分组-1"><a href="#字母异位词分组-1" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出:<br>[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupAnagrams</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-built_in">String</span>[] strs) &#123;<br>        Map&lt;<span class="hljs-built_in">String</span>, List&lt;<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> : strs) &#123;<br>            <span class="hljs-type">char</span>[] array = <span class="hljs-built_in">str</span>.<span class="hljs-property">toCharArray</span>();<br>            Arrays.<span class="hljs-property">sort</span>(array);<br>            <span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>(array);<br>            List&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-built_in">map</span>.<span class="hljs-property">getOrDefault</span>(<span class="hljs-built_in">key</span>, <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;());<br>            list.<span class="hljs-property">add</span>(<span class="hljs-built_in">str</span>);<br>            <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(<span class="hljs-built_in">key</span>, list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">map</span>.<span class="hljs-property">values</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-built_in">String</span>[] strs = <span class="hljs-keyword">new </span><span class="hljs-class title_">String</span>[]&#123;<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>&#125;;<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-title function_">groupAnagrams</span>(strs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[eat, tea, ate], [bat], [tan, nat]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，没想到官方的思路这么简单，而且效率这么低。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RotateImage</title>
    <link href="/2021/03/14/RotateImage/"/>
    <url>/2021/03/14/RotateImage/</url>
    
    <content type="html"><![CDATA[<h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/14/RotateImage/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/14/RotateImage/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="旋转图像-1"><a href="#旋转图像-1" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">旋转图像</a></h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/mat2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1]]</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-string">[[3,1],[4,2]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>matrix.length == n</code></li><li><code>matrix[i].length == n</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RotateImage</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">rotate</span>(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++j) &#123;<br>                <span class="hljs-type">int</span> temp = matrix[i][j];<br>                matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>                matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>                matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>                matrix[j][n - i - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-type">int</span>[][] matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br><br>        matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br><br>        matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br><br>        matrix = <span class="hljs-keyword">new </span><span class="hljs-class title_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br>        <span class="hljs-built_in">print</span>(matrix);<br>        <span class="hljs-built_in">rotate</span>(matrix);<br>        <span class="hljs-built_in">print</span>(matrix);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-type">int</span>[][] matrix) &#123;<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;=====&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : matrix) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.<span class="hljs-property">out</span>.<span class="hljs-property">print</span>(anInt);<br>            &#125;<br>            System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>();<br>        &#125;<br>        System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;=====&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">123</span><br><span class="hljs-number">456</span><br><span class="hljs-number">789</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">741</span><br><span class="hljs-number">852</span><br><span class="hljs-number">963</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">51911</span><br><span class="hljs-number">24810</span><br><span class="hljs-number">13367</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">132511</span><br><span class="hljs-number">34110</span><br><span class="hljs-number">6897</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">12</span><br><span class="hljs-number">34</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">31</span><br><span class="hljs-number">42</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，当成数学题就好了。然后用个变量承接需要翻转的值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PermutationsII</title>
    <link href="/2021/03/12/PermutationsII/"/>
    <url>/2021/03/12/PermutationsII/</url>
    
    <content type="html"><![CDATA[<h4 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/12/PermutationsII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/12/PermutationsII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="全排列-II-1"><a href="#全排列-II-1" class="headerlink" title="全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a></h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><p><strong>示例1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermutationsII</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span>[] vis;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; perm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        Arrays.sort(nums);<br>        backtrack(nums, ans, <span class="hljs-number">0</span>, perm);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-type">int</span> idx, List&lt;Integer&gt; perm)</span> &#123;<br>        <span class="hljs-keyword">if</span> (idx == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(perm));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-comment">// 从左往右第一个未被填过的数字</span><br>            <span class="hljs-keyword">if</span> (vis[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !vis[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            perm.add(nums[i]);<br>            vis[i] = <span class="hljs-literal">true</span>;<br><br>            backtrack(nums, ans, idx + <span class="hljs-number">1</span>, perm);<br><br>            vis[i] = <span class="hljs-literal">false</span>;<br>            perm.remove(idx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        System.out.println(permuteUnique(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(permuteUnique(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[1, 1, 2]</span>, <span class="hljs-comment">[1, 2, 1]</span>, <span class="hljs-comment">[2, 1, 1]</span>]</span><br><span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>, <span class="hljs-comment">[3, 2, 1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，使用回溯，排序然后排重。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Permutations</title>
    <link href="/2021/03/09/Permutations/"/>
    <url>/2021/03/09/Permutations/</url>
    
    <content type="html"><![CDATA[<h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/09/Permutations/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/09/Permutations/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h4><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,2,3]</span><br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Permutations</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        List&lt;Integer&gt; output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            output.add(num);<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(output, ans, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-type">int</span> first)</span> &#123;<br>        <span class="hljs-keyword">if</span> (first == output.size()) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(output));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> first; i &lt; output.size(); i++) &#123;<br>            Collections.swap(output, i, first);<br>            backtrack(output, ans, first + <span class="hljs-number">1</span>);<br>            Collections.swap(output, i, first);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(permute(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 2, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，使用回溯。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JumpGameII</title>
    <link href="/2021/03/06/JumpGameII/"/>
    <url>/2021/03/06/JumpGameII/</url>
    
    <content type="html"><![CDATA[<h4 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/06/JumpGameII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/06/JumpGameII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="跳跃游戏-II-1"><a href="#跳跃游戏-II-1" class="headerlink" title="跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为<span class="hljs-number"> 0 </span>跳到下标为<span class="hljs-number"> 1 </span>的位置，跳<span class="hljs-number"> 1 </span>步，然后跳<span class="hljs-number"> 3 </span>步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>假设你总是可以到达数组的最后一个位置。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JumpGameII</span> &#123;<br><br>    <span class="hljs-comment">// 贪心算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 怎么样才能找到每一步的最大</span><br>        <span class="hljs-comment">// 倒过来，算到终点的最小跳数，然后返回第一个数字的值</span><br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] stepArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[length - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + i &gt;= length - <span class="hljs-number">1</span>) &#123;<br>                stepArray[i] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> value = nums[i];<br>                <span class="hljs-type">int</span> min = Integer.MAX_VALUE - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= value; j++) &#123;<br>                    min = Math.<span class="hljs-built_in">min</span>(min, stepArray[i + j]);<br>                &#125;<br>                stepArray[i] = min + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stepArray[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">jump</span>(nums));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">jump</span>(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，我用的是反向贪心，效率一般。官方的反向贪心效率更差了。正向贪心效率会好一点，也很优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WildcardMatching</title>
    <link href="/2021/03/04/WildcardMatching/"/>
    <url>/2021/03/04/WildcardMatching/</url>
    
    <content type="html"><![CDATA[<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/04/WildcardMatching/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/04/WildcardMatching/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="通配符匹配-1"><a href="#通配符匹配-1" class="headerlink" title="通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">通配符匹配</a></h4><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27;?&#x27; 可以匹配任何单个字符。<br>&#x27;*&#x27; 可以匹配任意字符串（包括空字符串）。<br></code></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><p><strong>说明:</strong></p><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;aa&quot;</span><br>p = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;aa&quot;</span><br>p = <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: &#x27;*&#x27; 可以匹配任意字符串。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入:<br>s = <span class="hljs-string">&quot;cb&quot;</span><br>p = <span class="hljs-string">&quot;?a&quot;</span><br>输出: <span class="hljs-literal">false</span><br>解释: <span class="hljs-string">&#x27;?&#x27;</span> 可以匹配 <span class="hljs-string">&#x27;c&#x27;</span>, 但第二个 <span class="hljs-string">&#x27;a&#x27;</span> 无法匹配 <span class="hljs-string">&#x27;b&#x27;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;adceb&quot;</span><br>p = <span class="hljs-string">&quot;*a*b&quot;</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;.</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;acdcb&quot;</span><br>p = <span class="hljs-string">&quot;a*c?b&quot;</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> WildcardMatching &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isMatch(String s, String p) &#123;<br>        <span class="hljs-type">int</span> m = s.length();<br>        <span class="hljs-type">int</span> n = p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] || dp[i - <span class="hljs-number">1</span>][j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;?&#x27;</span> || s.charAt(i - <span class="hljs-number">1</span>) == p.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;aa&quot;, &quot;a&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;aa&quot;, &quot;*&quot;));//t<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;cb&quot;, &quot;?a&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;adceb&quot;, &quot;*a*b&quot;));//t<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isMatch(&quot;acdcb&quot;, &quot;a*c?b&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，效率一般，用的是递归。所以改用了官方的动态方程，其实效率还是一般。动态方程和边界条件写好了，答案也就出来了，不是很难。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MultiplyStrings</title>
    <link href="/2021/03/02/MultiplyStrings/"/>
    <url>/2021/03/02/MultiplyStrings/</url>
    
    <content type="html"><![CDATA[<h4 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h4><ul><li><a href="https://yangtzeshore.github.io/2021/03/02/MultiplyStrings/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/03/02/MultiplyStrings/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="字符串相乘-1"><a href="#字符串相乘-1" class="headerlink" title="字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span><br>输出: <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span><br>输出: <span class="hljs-string">&quot;56088&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>num1 和 num2 的长度小于110。</code></li><li><code>num1 和 num2 只包含数字 0-9。</code></li><li><code>num1 和 num2 均不以零开头，除非是数字 0 本身。</code></li><li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MultiplyStrings &#123;<br><br>    <span class="hljs-built_in">public</span> String multiply1(String num1, String num2) &#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;<br>            <span class="hljs-keyword">return</span> &quot;0&quot;;<br>        &#125;<br>        <span class="hljs-type">int</span> m = num1.length(), n = num2.length();<br>        <span class="hljs-type">int</span>[] ansArr = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[m + n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-type">int</span> x = num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j<span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-type">int</span> y = num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        StringBuffer ans = <span class="hljs-built_in">new</span> StringBuffer();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; m + n) &#123;<br>            ans.append(ansArr[<span class="hljs-keyword">index</span>]);<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static String multiply(String num1, String num2) &#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;<br>            <span class="hljs-keyword">return</span> &quot;0&quot;;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">222</span>];<br>        Arrays.fill(result, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">char</span>[] chars1 = num1.toCharArray();<br>        <span class="hljs-type">char</span>[] chars2 = num2.toCharArray();<br><br>        <span class="hljs-type">int</span> length1 = chars1.length - <span class="hljs-number">1</span>;//<span class="hljs-number">456</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length1; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123; //123</span><br>            <span class="hljs-type">int</span> length2 = chars2.length - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = length2; j &gt;= <span class="hljs-number">0</span>; j<span class="hljs-comment">--) &#123;//456</span><br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = (chars1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (chars2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">index</span> = length1 - i + length2 - j;<br>                <span class="hljs-keyword">temp</span> += result[<span class="hljs-keyword">index</span>] + carry;<br><br>                result[<span class="hljs-keyword">index</span>] = <span class="hljs-keyword">temp</span> % <span class="hljs-number">10</span>;<br>                carry = <span class="hljs-keyword">temp</span> / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>               result[<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>] = carry;<br>            &#125;<br>        &#125;<br>        StringBuilder sb = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-type">boolean</span> first = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = result.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>            <span class="hljs-keyword">if</span> (!first &amp;&amp; result[i] != <span class="hljs-number">0</span>) &#123;<br>                sb.append(result[i]);<br>                first = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first) &#123;<br>                sb.append(result[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(multiply(&quot;2&quot;, &quot;3&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(multiply(&quot;123&quot;, &quot;456&quot;));<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(multiply(&quot;999&quot;, &quot;99999&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">6</span><br><span class="hljs-number">56088</span><br><span class="hljs-number">99899001</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，效率一般，类似于官方的乘法算法，比加法算法效率好一点。官方的乘法优化非常彻底，可以仔细品味。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TrappingRainWater</title>
    <link href="/2021/02/27/TrappingRainWater/"/>
    <url>/2021/02/27/TrappingRainWater/</url>
    
    <content type="html"><![CDATA[<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/27/TrappingRainWater/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/27/TrappingRainWater/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="接雨水-1"><a href="#接雨水-1" class="headerlink" title="接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></h4><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/rainwatertrap.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TrappingRainWater &#123;<br><br>    // 凹形槽的两个条件：一个是往右找，比自己高的，那就停止；一个是找最近接自己高度的<br>    // 也就是第二高的，记录位置<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> trap(<span class="hljs-type">int</span>[] height) &#123;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; height.length &amp;&amp; left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                left++;<br>                right = left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> tempMax = right;<br>            <span class="hljs-keyword">while</span> (right &lt; height.length &amp;&amp; height[left] &gt; height[right]) &#123;<br>                <span class="hljs-keyword">if</span> (height[right] &gt; height[tempMax]) &#123;<br>                    tempMax = right;<br>                &#125;<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right &lt; height.length &amp;&amp; height[right] &gt; height[tempMax]) &#123;<br>                tempMax = right;<br>            &#125;<br>            <span class="hljs-type">int</span> minHeight = Math.min(height[left], height[tempMax]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; tempMax; i++) &#123;<br>                area += minHeight - height[i];<br>            &#125;<br>            left = tempMax;<br>            right = left + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> trap1(<span class="hljs-type">int</span>[] height) &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rightMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                <span class="hljs-keyword">if</span> (height[left] &gt;= leftMax) &#123;<br>                    leftMax = height[left];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans += leftMax - height[left];<br>                &#125;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (height[right] &gt;= rightMax) &#123;<br>                    rightMax = height[right];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans += rightMax - height[right];<br>                &#125;<br>                right<span class="hljs-comment">--;</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] height = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(trap1(height));<br><br>        height = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(trap1(height));<br><br>        height = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(trap1(height));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>9<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，效率一般，也是双指针的变形，不过没有官方的优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FirstMissingPositive</title>
    <link href="/2021/02/25/FirstMissingPositive/"/>
    <url>/2021/02/25/FirstMissingPositive/</url>
    
    <content type="html"><![CDATA[<h4 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/25/FirstMissingPositive/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/25/FirstMissingPositive/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="缺失的第一个正数-1"><a href="#缺失的第一个正数-1" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></h4><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p><strong>进阶：</strong>你可以实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案吗？</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,0]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,4,-1,1]</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,8,9,11,12]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> FirstMissingPositive &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> firstMissingPositive1(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> length = nums.length;<br><br>        // 转成正数，注意用下标，否则不生效<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>                nums[i] = length + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> num = Math.abs(nums[i]);<br>            <span class="hljs-keyword">if</span> (num &lt;= length) &#123;<br>                nums[num - <span class="hljs-number">1</span>] = -Math.abs(nums[num - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length + <span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> firstMissingPositive(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; length &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[nums[i] - <span class="hljs-number">1</span>];<br>                nums[nums[i] - <span class="hljs-number">1</span>] = nums[i];<br>                nums[i] = <span class="hljs-keyword">temp</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        // <span class="hljs-number">3</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(firstMissingPositive(nums));<br><br>        // <span class="hljs-number">2</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(firstMissingPositive(nums));<br><br>        // <span class="hljs-number">1</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(firstMissingPositive(nums));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路上，自己写了一版，比hash方法的稍微好一点，比两两互换的差了些许。不过还是采纳了官方的解法。考察的其实还是数学功底，算法本身不难。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CombinationSumII</title>
    <link href="/2021/02/23/CombinationSumII/"/>
    <url>/2021/02/23/CombinationSumII/</url>
    
    <content type="html"><![CDATA[<h4 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/23/CombinationSumII/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/23/CombinationSumII/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="组合总和-II-1"><a href="#组合总和-II-1" class="headerlink" title="组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></h4><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,<br>所求解集为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 2, 5]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2, 6]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1, 1, 6]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,<br>所求解集为:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CombinationSumII &#123;<br><br>    static List&lt;<span class="hljs-type">int</span> []&gt; freq = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; ans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    static List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">sequence</span> = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum2(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;<br>        Arrays.sort(candidates);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> candidate : candidates) &#123;<br>            <span class="hljs-keyword">if</span> (freq.isEmpty() || freq.<span class="hljs-keyword">get</span>(freq.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] != candidate) &#123;<br>                freq.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;candidate, <span class="hljs-number">1</span>&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++freq.<span class="hljs-keyword">get</span>(freq.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        dfs(<span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> dfs(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">sequence</span>));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pos == freq.size() || target &lt; freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        // 跳过<br>        dfs(pos + <span class="hljs-number">1</span>, target);<br><br>        <span class="hljs-type">int</span> most = Math.min(target / freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>], freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= most; i++) &#123;<br>            <span class="hljs-keyword">sequence</span>.<span class="hljs-keyword">add</span>(freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]);<br>            // 虽然每次都会循环，但是pos都不变，也就是每次从下一个为为孩子开始，但是重复数字会叠加<br>            dfs(pos + <span class="hljs-number">1</span>, target - i * freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= most; i++) &#123;<br>            <span class="hljs-keyword">sequence</span>.remove(<span class="hljs-keyword">sequence</span>.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> targe = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum2(candidates, targe));<br><br>        candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>        targe = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum2(candidates, targe));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[2, 6]</span>, <span class="hljs-comment">[1, 7]</span>, <span class="hljs-comment">[1, 2, 5]</span>, <span class="hljs-comment">[1, 1, 6]</span>]</span><br><span class="hljs-comment">[<span class="hljs-comment">[2, 6]</span>, <span class="hljs-comment">[1, 7]</span>, <span class="hljs-comment">[1, 2, 5]</span>, <span class="hljs-comment">[1, 1, 6]</span>, <span class="hljs-comment">[5]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是搜索回溯。注意的是，不能有重复。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CombinationSum</title>
    <link href="/2021/02/20/CombinationSum/"/>
    <url>/2021/02/20/CombinationSum/</url>
    
    <content type="html"><![CDATA[<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/20/CombinationSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/20/CombinationSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="组合总和-1"><a href="#组合总和-1" class="headerlink" title="组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></h4><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：candidates = <span class="hljs-comment">[2,3,6,7]</span>, target = 7,<br>所求解集为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,2,3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8,<br>所求解集为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,2,2,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都是独一无二的。</li><li><code>1 &lt;= target &lt;= 500</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> CombinationSum &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        List&lt;<span class="hljs-type">Integer</span>&gt; element = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        dfs(result, element, candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> dfs(List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result, List&lt;<span class="hljs-type">Integer</span>&gt; element, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> <span class="hljs-keyword">index</span>) &#123;<br><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            // 注意因为会回溯，所以需要新建一个，回溯会改变集合<br>            result.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(element));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> == candidates.length) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        // 跳过<span class="hljs-keyword">index</span><br>        dfs(result, element, candidates, target, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>);<br>        // 使用当前<span class="hljs-keyword">index</span><br>        <span class="hljs-keyword">if</span> (target - candidates[<span class="hljs-keyword">index</span>] &gt;= <span class="hljs-number">0</span>) &#123;<br>            element.<span class="hljs-keyword">add</span>(candidates[<span class="hljs-keyword">index</span>]);<br>            dfs(result, element, candidates, target - candidates[<span class="hljs-keyword">index</span>], <span class="hljs-keyword">index</span>);<br>            element.remove(element.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span> targe = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum(candidates, targe));<br><br>        candidates = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        targe = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(combinationSum(candidates, targe));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">[[7], [2, 2, 3]]</span><br><span class="hljs-string">[[3, 5], [2, 3, 3], [2, 2, 2, 2]]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是搜索回溯。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CountAndSay</title>
    <link href="/2021/02/18/CountAndSay/"/>
    <url>/2021/02/18/CountAndSay/</url>
    
    <content type="html"><![CDATA[<h4 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/18/CountAndSay/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/18/CountAndSay/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="外观数列-1"><a href="#外观数列-1" class="headerlink" title="外观数列"></a><a href="https://leetcode-cn.com/problems/count-and-say/">外观数列</a></h4><p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p><p>你可以将其视作是由递归公式定义的数字字符串序列：</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li></ul><p>前五项如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">1.     1<br>2.     11<br>3.     21<br>4.     1211<br>5.     111221<br>第一项是数字<span class="hljs-number"> 1 </span><br>描述前一项，这个数是<span class="hljs-number"> 1 </span>即 “ 一 个<span class="hljs-number"> 1 </span>”，记作 &quot;11&quot;<br>描述前一项，这个数是<span class="hljs-number"> 11 </span>即 “ 二 个<span class="hljs-number"> 1 </span>” ，记作 &quot;21&quot;<br>描述前一项，这个数是<span class="hljs-number"> 21 </span>即 “ 一 个<span class="hljs-number"> 2 </span>+ 一 个<span class="hljs-number"> 1 </span>” ，记作 &quot;1211&quot;<br>描述前一项，这个数是<span class="hljs-number"> 1211 </span>即 “ 一 个<span class="hljs-number"> 1 </span>+ 一 个<span class="hljs-number"> 2 </span>+ 二 个<span class="hljs-number"> 1 </span>” ，记作 &quot;111221&quot;<br></code></pre></td></tr></table></figure><p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><p>例如，数字字符串 <code>&quot;3322251&quot;</code> 的描述如下图：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/countandsay.jpg" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;1&quot;</span><br>解释：这是一个基本样例。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span><br>输出：<span class="hljs-string">&quot;1211&quot;</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span> = <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span> = 读 <span class="hljs-string">&quot;1&quot;</span> = 一 个 <span class="hljs-number">1</span> = <span class="hljs-string">&quot;11&quot;</span><br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span> = 读 <span class="hljs-string">&quot;11&quot;</span> = 二 个 <span class="hljs-number">1</span> = <span class="hljs-string">&quot;21&quot;</span><br><span class="hljs-function"><span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span> = 读 <span class="hljs-string">&quot;21&quot;</span> = 一 个 <span class="hljs-number">2</span> + 一 个 <span class="hljs-number">1</span> = <span class="hljs-string">&quot;12&quot;</span> + <span class="hljs-string">&quot;11&quot;</span> = <span class="hljs-string">&quot;1211&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CountAndSay &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String countAndSay(<span class="hljs-keyword">int</span> n) &#123;<br><br>        String result = <span class="hljs-string">&quot;1&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            result = <span class="hljs-keyword">count</span>(result);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-keyword">count</span>(String s) &#123;<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">char</span> comp = s.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span>(comp == c) &#123;<br>                <span class="hljs-keyword">count</span>++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stringBuilder.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">count</span>);<br>                stringBuilder.<span class="hljs-keyword">append</span>(comp);<br>                comp = c;<br>                <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        stringBuilder.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">count</span>);<br>        stringBuilder.<span class="hljs-keyword">append</span>(comp);<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">1</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">2</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">3</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">4</span>));<br>        System.out.<span class="hljs-keyword">println</span>(countAndSay(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><br><span class="hljs-number">11</span><br><span class="hljs-number">21</span><br><span class="hljs-number">1211</span><br><span class="hljs-number">111221</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是迭代每个数字，并且计算数字出现的次数。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SudokuSolver</title>
    <link href="/2021/02/16/SudokuSolver/"/>
    <url>/2021/02/16/SudokuSolver/</url>
    
    <content type="html"><![CDATA[<h4 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/16/SudokuSolver/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/16/SudokuSolver/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="解数独-1"><a href="#解数独-1" class="headerlink" title="解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">解数独</a></h4><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需<strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>一个数独。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p><p>答案被标成红色。</p><p><strong>提示：</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SudokuSolver</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[][] line = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[][] column = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span>[][][] block = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> valid = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> List&lt;<span class="hljs-type">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    spaces.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> digit = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">1</span>;<br>                    line[i][digit] = column[j][digit] = block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == spaces.<span class="hljs-built_in">size</span>()) &#123;<br>            valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] space = spaces.<span class="hljs-built_in">get</span>(pos);<br>        <span class="hljs-comment">// 递归空间</span><br>        <span class="hljs-type">int</span> i = space[<span class="hljs-number">0</span>], j = space[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> digit = <span class="hljs-number">0</span>; digit &lt; <span class="hljs-number">9</span> &amp;&amp; !valid; ++digit) &#123;<br>            <span class="hljs-keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit]) &#123;<br>                line[i][digit] = column[j][digit] = block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-literal">true</span>;<br>                board[i][j] = (<span class="hljs-type">char</span>) (digit + <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">dfs</span>(board, pos + <span class="hljs-number">1</span>);<br>                line[i][digit] = column[j][digit] = block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][digit] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[][]&#123;<br>                &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        <span class="hljs-built_in">solveSudoku</span>(board);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是递归。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidSudoku</title>
    <link href="/2021/02/14/ValidSudoku/"/>
    <url>/2021/02/14/ValidSudoku/</url>
    
    <content type="html"><![CDATA[<h4 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/14/ValidSudoku/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/14/ValidSudoku/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="有效的数独-1"><a href="#有效的数独-1" class="headerlink" title="有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">有效的数独</a></h4><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入:<br>[<br>  [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br>  [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br>  [<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br>]<br>输出: true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入:<br>[<br>  [<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<br>  [<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],<br>  [<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>],<br>  [<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]<br>]<br>输出: false<br>解释: 除了第一行的第一个数字从 <span class="hljs-number">5</span> 改为 <span class="hljs-number">8</span> 以外，空格内其他数字均与 示例<span class="hljs-number">1</span> 相同。<br>     但由于位于左上角的 <span class="hljs-number">3</span>x3 宫内有两个 <span class="hljs-number">8</span> 存在, 因此这个数独是无效的。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ValidSudoku &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isValidSudoku(<span class="hljs-type">char</span>[][] board) &#123;<br><br>        // init data<br>        HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;[] <span class="hljs-keyword">rows</span> = <span class="hljs-built_in">new</span> HashMap[<span class="hljs-number">9</span>];<br>        HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;[] <span class="hljs-keyword">columns</span> = <span class="hljs-built_in">new</span> HashMap[<span class="hljs-number">9</span>];<br>        HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;[] boxes = <span class="hljs-built_in">new</span> HashMap[<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">rows</span>[i] = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>            <span class="hljs-keyword">columns</span>[i] = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>            boxes[i] = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>        &#125;<br><br>        // <span class="hljs-keyword">validate</span> a board<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-type">char</span> num = board[i][j];<br>                <span class="hljs-keyword">if</span> (num != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> n = num;<br>                    <span class="hljs-type">int</span> box_index = (i / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;<br><br>                    // keep the <span class="hljs-keyword">current</span> cell <span class="hljs-keyword">value</span><br>                    <span class="hljs-keyword">rows</span>[i].put(n, <span class="hljs-keyword">rows</span>[i].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">columns</span>[j].put(n, <span class="hljs-keyword">columns</span>[j].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    boxes[box_index].put(n, boxes[box_index].getOrDefault(n, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>                    // <span class="hljs-keyword">check</span> <span class="hljs-keyword">if</span> this <span class="hljs-keyword">value</span> has been already seen <span class="hljs-keyword">before</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">rows</span>[i].<span class="hljs-keyword">get</span>(n) &gt; <span class="hljs-number">1</span> || <span class="hljs-keyword">columns</span>[j].<span class="hljs-keyword">get</span>(n) &gt; <span class="hljs-number">1</span> || boxes[box_index].<span class="hljs-keyword">get</span>(n) &gt; <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">char</span>[][] board = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[][]&#123;<br>                &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isValidSudoku(board));<br><br>        board = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[][]&#123;<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>&#125;,<br>                &#123;<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>&#125;&#125;;<br><br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isValidSudoku(board));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路也很简单，就是一次迭代，记录所有的数字。然后比对是否有大于1的记录。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchInsertPosition</title>
    <link href="/2021/02/12/SearchInsertPosition/"/>
    <url>/2021/02/12/SearchInsertPosition/</url>
    
    <content type="html"><![CDATA[<h4 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/12/SearchInsertPosition/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/12/SearchInsertPosition/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索插入位置-1"><a href="#搜索插入位置-1" class="headerlink" title="搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,5,6], 0</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchInsertPosition</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span> || <span class="hljs-keyword">target</span> &lt; nums[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> &gt; nums[length - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == nums[left]) &#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == nums[right]) &#123;<br>                <span class="hljs-keyword">return</span> right;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == nums[mid]) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> &gt; nums[mid]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 5</span><br>        <span class="hljs-comment">//输出: 2</span><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 2</span><br>        <span class="hljs-comment">//输出: 1</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">2</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 7</span><br>        <span class="hljs-comment">//输出: 4</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//输入: [1,3,5,6], 0</span><br>        <span class="hljs-comment">//输出: 0</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br><br>        <span class="hljs-comment">//[1,3,5]</span><br>        <span class="hljs-comment">//4</span><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span>;<br>        System.out.println(searchInsert(nums, <span class="hljs-keyword">target</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br>4<br>0<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是二分查找，不过官方的解答比较优雅。还有就是这个除法：((right−left)&gt;&gt;1)+left。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FindFirstAndLastPositionOfElementInSortedArray</title>
    <link href="/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/"/>
    <url>/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/</url>
    
    <content type="html"><![CDATA[<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><ul><li><a href="https://yangtzeshore.github.io/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/10/FindFirstAndLastPositionOfElementInSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="在排序数组中查找元素的第一个和最后一个位置-1"><a href="#在排序数组中查找元素的第一个和最后一个位置-1" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0&lt;&#x3D;nums.length&lt;&#x3D;105</li><li>10−9&lt;&#x3D;nums[i]&lt;&#x3D;109</li><li><code>nums</code> 是一个非递减数组</li><li>10−9&lt;&#x3D;target&lt;&#x3D;109</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> FindFirstAndLastPositionOfElementInSortedArray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        <span class="hljs-type">int</span>[] result;<br><br>        <span class="hljs-type">int</span> length = nums.length;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                left = right = mid;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-comment">--left &gt;= 0 &amp;&amp; nums[left] == target) &#123;</span><br><br>                &#125;<br>                left++;<br>                <span class="hljs-keyword">while</span> (++right &lt; length &amp;&amp; nums[right] == target) &#123;<br><br>                &#125;<br>                right<span class="hljs-comment">--;</span><br>                result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;left, right&#125;;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        //nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">8</span><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(searchRange(nums, target)));<br><br>        //nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">6</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>        target = <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(searchRange(nums, target)));<br><br>        //nums = [], target = <span class="hljs-number">0</span><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>        target = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(searchRange(nums, target)));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[3, 4]<br>[<span class="hljs-string">-1</span>, <span class="hljs-string">-1</span>]<br>[<span class="hljs-string">-1</span>, <span class="hljs-string">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是二分查找，然后扩展边界。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SearchInRotatedSortedArray</title>
    <link href="/2021/02/07/SearchInRotatedSortedArray/"/>
    <url>/2021/02/07/SearchInRotatedSortedArray/</url>
    
    <content type="html"><![CDATA[<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/07/SearchInRotatedSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/07/SearchInRotatedSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="搜索旋转排序数组-1"><a href="#搜索旋转排序数组-1" class="headerlink" title="搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h4><p>升序排列的整数数组 <code>nums</code> 在预先未知的某个点上进行了旋转（例如， <code>[0,1,2,4,5,6,7]</code> 经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> ）。</p><p>请你在数组中搜索 <code>target</code> ，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchInRotatedSortedArray</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(nums[mid] &lt; nums[right])</span> </span>&#123;<span class="hljs-comment">// 右边有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &lt; <span class="hljs-keyword">target</span> &amp;&amp; <span class="hljs-keyword">target</span> &lt;= nums[right]) &#123; <span class="hljs-comment">// 落在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 落在左边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 左边有序</span><br>                <span class="hljs-keyword">if</span> (nums[mid] &gt; <span class="hljs-keyword">target</span> &amp;&amp; <span class="hljs-keyword">target</span> &gt;= nums[left]) &#123; <span class="hljs-comment">// 落在左边</span><br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 落在右边</span><br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        System.out.println(search(nums, <span class="hljs-keyword">target</span>));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">3</span>;<br>        System.out.println(search(nums, <span class="hljs-keyword">target</span>));<br><br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">target</span> = <span class="hljs-number">0</span>;<br>        System.out.println(search(nums, <span class="hljs-keyword">target</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">4<br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是旋转后，怎么判断数据在左边还是右边，然后结合二分查找。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestValidParentheses</title>
    <link href="/2021/02/06/LongestValidParentheses/"/>
    <url>/2021/02/06/LongestValidParentheses/</url>
    
    <content type="html"><![CDATA[<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/06/LongestValidParentheses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/06/LongestValidParentheses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="最长有效括号-1"><a href="#最长有效括号-1" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a></h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;)()())&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span>xxxxxxxxxx 输入：s = <span class="hljs-string">&quot;&quot;</span>输出：<span class="hljs-number">0</span>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestValidParentheses</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[s.<span class="hljs-built_in">length</span>()];<br><br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt; <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.<span class="hljs-built_in">charAt</span>(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + (i - dp[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                max = Math.<span class="hljs-built_in">max</span>(max, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">print</span>(dp);<br><br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>[] dp)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : dp) &#123;<br>            System.out.<span class="hljs-built_in">print</span>(i);<br>        &#125;<br>        System.out.<span class="hljs-built_in">println</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-type">String</span> s = <span class="hljs-string">&quot;(()&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestValidParentheses</span>(s));<br>        s = <span class="hljs-string">&quot;)()())&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestValidParentheses</span>(s));<br>        s = <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestValidParentheses</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">002<br>2<br>002040<br>4<br><br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题思路很简单，就是dp，写出方程后，就简单了。不过，需要注意，只是求最大值，不是求每个dp位置上准确的数值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NextPermutation</title>
    <link href="/2021/02/05/NextPermutation/"/>
    <url>/2021/02/05/NextPermutation/</url>
    
    <content type="html"><![CDATA[<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/05/NextPermutation/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/05/NextPermutation/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="下一个排列-1"><a href="#下一个排列-1" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></h4><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,5]</span><br>输出：<span class="hljs-comment">[1,5,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> NextPermutation &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> nextPermutation(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-type">int</span> i = nums.length - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="hljs-number">1</span>]) &#123;<br>            i<span class="hljs-comment">--;</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> j = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &gt; i &amp;&amp; nums[i] &gt;= nums[j]) &#123;<br>                j<span class="hljs-comment">--;</span><br>            &#125;<br>            swap(nums, i, j);<br>        &#125;<br>        reverse(nums, i + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> reverse(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left) &#123;<br>        <span class="hljs-type">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            swap(nums, left, right);<br>            left ++;<br>            right <span class="hljs-comment">--;</span><br>        &#125;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> swap(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = <span class="hljs-keyword">temp</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        // nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        nextPermutation(nums);<br>        print(nums);<br><br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(num);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">132<br>123<br>151<br>1<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题没做出来。主要是需要证明一个算法有效性：就是从右往左扫描，分两次。第一次，需要判定某个数往右，是降序排列；然后，交换这个数字与右边从后往前第一个大于它的数字，然后将右边数字升序。这种算法是容易证明是正确的，但是需要意识到这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SubstringWithConcatenationOfAllWords</title>
    <link href="/2021/02/02/SubstringWithConcatenationOfAllWords/"/>
    <url>/2021/02/02/SubstringWithConcatenationOfAllWords/</url>
    
    <content type="html"><![CDATA[<h2 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/02/SubstringWithConcatenationOfAllWords/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/02/SubstringWithConcatenationOfAllWords/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="串联所有单词的子串-1"><a href="#串联所有单词的子串-1" class="headerlink" title="串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">串联所有单词的子串</a></h4><p>给定一个字符串 <strong>s</strong> 和一些长度相同的单词 <strong>words。</strong>找出 <strong>s</strong> 中恰好可以由 <strong>words</strong> 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 <strong>words</strong> 中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words</strong> 中单词串联的顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>  s = <span class="hljs-string">&quot;barfoothefoobarman&quot;</span>,<br>  words = [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">9</span>]<br>解释：<br>从索引 <span class="hljs-number">0</span> 和 <span class="hljs-number">9</span> 开始的子串分别是 <span class="hljs-string">&quot;barfoo&quot;</span> 和 <span class="hljs-string">&quot;foobar&quot;</span> 。<br>输出的顺序不重要, [<span class="hljs-number">9</span>,<span class="hljs-number">0</span>] 也是有效答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>  s = <span class="hljs-string">&quot;wordgoodgoodgoodbestword&quot;</span>,<br>  words = [<span class="hljs-string">&quot;word&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>,<span class="hljs-string">&quot;best&quot;</span>,<span class="hljs-string">&quot;word&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubstringWithConcatenationOfAllWords</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br><br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span> || words == <span class="hljs-literal">null</span> || words.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">one_word</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">word_num</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">all_len</span> <span class="hljs-operator">=</span> one_word * word_num;<br>        <span class="hljs-comment">// 统计单词出现次数</span><br>        <span class="hljs-keyword">for</span> (String word : words) &#123;<br>            map.put(word, map.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 母串从0到可以容纳的长度，循环匹配</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - all_len + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> s.substring(i, i + all_len);<br>            Map&lt;String, Integer&gt; tmp_map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">// 每次截取字符串，最后判断是否相等</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; all_len; j += one_word) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> tmp.substring(j, j + one_word);<br>                tmp_map.put(w, tmp_map.getOrDefault(w, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.equals(tmp_map)) &#123;<br>                res.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring1</span><span class="hljs-params">(String s, String[] words)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Map&lt;String, Integer&gt; wordsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span> || words.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span> (String word: words) &#123;<br>            <span class="hljs-comment">// 主串s中没有这个单词，直接返回空</span><br>            <span class="hljs-keyword">if</span> (s.indexOf(word) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-comment">// map中保存每个单词，和它出现的次数</span><br>            wordsMap.put(word, wordsMap.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 每个单词的长度， 总长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oneLen</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length(), wordsLen = oneLen * words.length;<br>        <span class="hljs-comment">// 主串s长度小于单词总和，返回空</span><br>        <span class="hljs-keyword">if</span> (wordsLen &gt; s.length()) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 只讨论从0，1，...， oneLen-1 开始的子串情况，</span><br>        <span class="hljs-comment">// 每次进行匹配的窗口大小为 wordsLen，每次后移一个单词长度，由左右窗口维持当前窗口位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; oneLen; ++i) &#123;<br>            <span class="hljs-comment">// 左右窗口</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i, count = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 统计每个符合要求的word</span><br>            Map&lt;String, Integer&gt; subMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">// 右窗口不能超出主串长度</span><br>            <span class="hljs-keyword">while</span> (right + oneLen &lt;= s.length()) &#123;<br>                <span class="hljs-comment">// 得到一个单词</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(right, right + oneLen);<br>                <span class="hljs-comment">// 有窗口右移</span><br>                right += oneLen;<br>                <span class="hljs-comment">// words[]中没有这个单词，那么当前窗口肯定匹配失败，直接右移到这个单词后面</span><br>                <span class="hljs-keyword">if</span> (!wordsMap.containsKey(word)) &#123;<br>                    left = right;<br>                    <span class="hljs-comment">// 窗口内单词统计map清空，重新统计</span><br>                    subMap.clear();<br>                    <span class="hljs-comment">// 符合要求的单词数清0</span><br>                    count = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 统计当前子串中这个单词出现的次数</span><br>                    subMap.put(word, subMap.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                    ++count;<br>                    <span class="hljs-comment">// 如果这个单词出现的次数大于words[]中它对应的次数，又由于每次匹配和words长度相等的子串</span><br>                    <span class="hljs-comment">// 如 &quot;foobarfoobarfoothe&quot;  [&quot;foo&quot;,&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span><br>                    <span class="hljs-comment">// 第二个bar虽然是words[]中的单词，但是次数抄了，那么右移一个单词长度后 &quot;barfoobarfoothe&quot;</span><br>                    <span class="hljs-comment">// bar还是不符合，所以直接从这个不符合的bar之后开始匹配，也就是将这个不符合的bar和它之前的单词(串)全移出去</span><br>                    <span class="hljs-keyword">while</span> (subMap.getOrDefault(word, <span class="hljs-number">0</span>) &gt; wordsMap.getOrDefault(word, <span class="hljs-number">0</span>)) &#123;<br>                        <span class="hljs-comment">// 从当前窗口字符统计map中删除从左窗口开始到数量超限的所有单词(次数减一)</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> s.substring(left, left + oneLen);<br>                        subMap.put(w, subMap.getOrDefault(w, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>                        <span class="hljs-comment">// 符合的单词数减一</span><br>                        --count;<br>                        <span class="hljs-comment">// 左窗口位置右移</span><br>                        left += oneLen;<br>                    &#125;<br>                    <span class="hljs-comment">// 当前窗口字符串满足要求</span><br>                    <span class="hljs-keyword">if</span> (count == words.length) res.add(left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaaaaaaaaaaaa&quot;</span>;<br>        String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>&#125;;<br>        System.out.println(findSubstring(s, words));<br><br>        s = <span class="hljs-string">&quot;wordgoodgoodgoodbestword&quot;</span>;<br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;word&quot;</span>, <span class="hljs-string">&quot;good&quot;</span>, <span class="hljs-string">&quot;best&quot;</span>, <span class="hljs-string">&quot;word&quot;</span>&#125;;<br>        System.out.println(findSubstring(s, words));<br><br>        s = <span class="hljs-string">&quot;barfoofoobarthefoobarman&quot;</span>;<br>        words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br>        System.out.println(findSubstring(s, words));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题没做出来。本来以为是字符匹配。应该好好审题，子串长度都是一致的。算法大致有两种，hash存储子串和个数，最终比较；另一种，与之类似，只不过，用滑动窗口实现优化。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DivideTwoIntegers</title>
    <link href="/2021/02/01/DivideTwoIntegers/"/>
    <url>/2021/02/01/DivideTwoIntegers/</url>
    
    <content type="html"><![CDATA[<h2 id="两数相除"><a href="#两数相除" class="headerlink" title="两数相除"></a>两数相除</h2><ul><li><a href="https://yangtzeshore.github.io/2021/02/01/DivideTwoIntegers/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/02/01/DivideTwoIntegers/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><h4 id="两数相除-1"><a href="#两数相除-1" class="headerlink" title="两数相除"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/">两数相除</a></h4><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p><p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：truncate(8.345) &#x3D; 8<code>以及</code>truncate(-2.7335) &#x3D; -2</p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: dividend = 10, divisor = 3</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: dividend = 7, divisor = <span class="hljs-string">-3</span><br>输出: <span class="hljs-string">-2</span><br>解释: 7/<span class="hljs-string">-3</span> = truncate(<span class="hljs-string">-2</span>.33333..) = <span class="hljs-string">-2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>被除数和除数均为 32 位有符号整数。</li><li>除数不为 0。</li><li>假设我们的环境只能存储 32 位有符号整数，其数值范围是[−231,231−1]。本题中，如果除法结果溢出，则返回231−1。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DivideTwoIntegers</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 越界后，只能返回-2147483648</span><br>        System.out.println(-(-<span class="hljs-number">2147483648</span>));<br>        System.out.println((-<span class="hljs-number">2147483648</span> - <span class="hljs-number">1</span>));<br><br>        System.out.println(<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            numLen++;<br>            num = num &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numLen;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getBit</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> pos)</span> &#123;<span class="hljs-comment">//获取从右到左的第pos位置的值1/0</span><br>        pos = pos - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; pos;<br>        <span class="hljs-keyword">if</span> ((num &amp; index) &gt;&gt; pos != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> &#123;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">minus</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 被除数是否是最大值</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">minValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> (dividend &lt; <span class="hljs-number">0</span> || divisor &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>) &#123;<br>                dividend = -dividend;<br>                divisor = -divisor;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dividend = dividend &lt; <span class="hljs-number">0</span> ? -dividend : dividend;<br>                divisor = divisor &lt; <span class="hljs-number">0</span> ? -divisor : divisor;<br>                minus = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (dividend == -<span class="hljs-number">2147483648</span>) &#123;<br>                minValue = <span class="hljs-literal">true</span>;<br>                dividend = dividend - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (divisor == -<span class="hljs-number">2147483648</span>) &#123;<br>                <span class="hljs-comment">// 被除数与除数相同</span><br>                <span class="hljs-keyword">if</span> (minValue)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 任何数除以最大值都是0，不区分符号了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dividend &lt; divisor)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (minus) &#123;<br>                <span class="hljs-comment">// 被除数为最大值</span><br>                <span class="hljs-keyword">if</span> (minValue)<br>                    <span class="hljs-keyword">return</span> -dividend - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> -dividend;<br>            &#125; <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> dividend;<br>        &#125;<br><br>        <span class="hljs-comment">// 二进制数头部可以除的数，每次用减法代替除，然后留下余数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">divide</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 目前除法或者说减法得到的结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> getBits(dividend);<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从头部用二进制减去除数，余数留下来</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> getBit(dividend, index--);<br>            divide = (divide &lt;&lt; <span class="hljs-number">1</span>) + val;<br><br>            <span class="hljs-keyword">if</span> (divide &lt; divisor)<br>                res = res &lt;&lt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res = (res &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>                divide = divide - divisor;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// -2147483648 2  因为最大数，转成正数后，少了1，所以如果余数加1能够被整除，当然加1</span><br>        <span class="hljs-keyword">if</span> (minValue &amp;&amp; (divide + <span class="hljs-number">1</span>) &gt;= divisor) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minus) &#123;<br>            <span class="hljs-keyword">return</span> -res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">-<span class="hljs-number">2147483648</span><br><span class="hljs-number">2147483647</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题没做出来。主要考察了怎么用减法代替除法，这个倒好理解。主要是最大最小值，这个边界问题，困扰一很久。</p><p>根据文档：</p><p>int数据类型是32位带符号的二进制补码整数。最小值为-2,147,483,648(0x80000000)，最大值为2,147,483,647(0x7FFFFFFF)(含)。</p><p>因此，当您将1加到整数的最大值时：</p><p>0x7FFFFFFF + 0x00000001 &#x3D; 0x80000000(-2,147,483,648)</p><p>也就是所谓的最大+1等于最小，最小-1等于最大。最小乘以-1还是最小，因为越界了，刚好是最大+1。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ImplementStrstr</title>
    <link href="/2021/01/31/ImplementStrstr/"/>
    <url>/2021/01/31/ImplementStrstr/</url>
    
    <content type="html"><![CDATA[<h2 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/31/ImplementStrstr/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/31/ImplementStrstr/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/">实现 strStr()</a></p><p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 <strong>-1</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;ll&quot;</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;aaaaa&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;bba&quot;</span><br>输出: -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImplementStrstr</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(<span class="hljs-type">String</span> haystack, <span class="hljs-type">String</span> needle)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (needle == null || needle.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> hayLength = haystack.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> needleLength = needle.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= hayLength - needleLength; i++) &#123;<br>            <span class="hljs-keyword">if</span> (haystack.<span class="hljs-built_in">substring</span>(i, i + needleLength).<span class="hljs-built_in">equals</span>(needle)) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span> haystack = <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> needle = <span class="hljs-string">&quot;ll&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">strStr</span>(haystack, needle));<br><br>        haystack = <span class="hljs-string">&quot;aaaaa&quot;</span>;<br>        needle = <span class="hljs-string">&quot;bba&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">strStr</span>(haystack, needle));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">2<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单，就是依次匹配。但是这里有个问题，我第一次用char挨个匹配，但是超时了；改用substring才能不超时。其二，官方的第二种算法，我也想到过，这里就不展示了，不过效率确实很好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveDuplicatesFromSortedArray</title>
    <link href="/2021/01/29/RemoveDuplicatesFromSortedArray/"/>
    <url>/2021/01/29/RemoveDuplicatesFromSortedArray/</url>
    
    <content type="html"><![CDATA[<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/29/RemoveDuplicatesFromSortedArray/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/29/RemoveDuplicatesFromSortedArray/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></p><p>给定一个排序数组，你需要在**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">给定数组 nums </span>=<span class="hljs-string"> [1,1,2], </span><br><span class="hljs-string"></span><br><span class="hljs-string">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="hljs-string"></span><br><span class="hljs-string">你不需要考虑数组中超出新长度后面的元素。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">给定 nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,2,2,3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br><br>函数应该返回新的长度 <span class="hljs-number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>。<br><br>你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>为什么返回数值是整数，但输出的答案是数组呢?</li><li>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</li></ul><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    <span class="hljs-built_in">print</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> RemoveDuplicatesFromSortedArray &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> removeDuplicates(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>;<br>        <span class="hljs-type">int</span> last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            start = i;<br>            <span class="hljs-keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                i++;<br>            &#125;<br>            last = i;<br>            <span class="hljs-keyword">if</span> (start == last) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            copyNums(nums, <span class="hljs-keyword">start</span>, last);<br>            i = <span class="hljs-keyword">start</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>            i++;<br>            length++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> copyNums(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> last) &#123;<br>        <span class="hljs-type">int</span> space = last - <span class="hljs-keyword">start</span>;<br>        <span class="hljs-keyword">for</span> (; <span class="hljs-keyword">start</span> &lt; nums.length - space; <span class="hljs-keyword">start</span>++, last++) &#123;<br>            nums[<span class="hljs-keyword">start</span>] = nums[last];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>        print(nums, removeDuplicates(nums));<br>        nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>        print(nums, removeDuplicates(nums));<br>    &#125;<br><br>    private static <span class="hljs-type">void</span> print(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> length) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">12<br>01234<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>思路很简单了，不过官方的双指针很优雅。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ReverseNodesInKGroup</title>
    <link href="/2021/01/28/ReverseNodesInKGroup/"/>
    <url>/2021/01/28/ReverseNodesInKGroup/</url>
    
    <content type="html"><![CDATA[<h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/28/ReverseNodesInKGroup/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/28/ReverseNodesInKGroup/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></p><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。<em>k</em> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">给你这个链表：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br><br>当 k = <span class="hljs-number">2</span> 时，应当返回: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span><br><br>当 k = <span class="hljs-number">3</span> 时，应当返回: <span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseNodesInKGroup</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || k &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (length &lt; k &amp;&amp; cur != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            prev = cur;<br>            cur = cur.next;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span> (length &lt; k)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        prev.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> reverse(head, k);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> reverseKGroup(cur, k);<br>        left.next = right;<br><span class="hljs-comment">// prev此时是头结点</span><br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>            length++;<br>            prev = prev.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length &lt; k)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 两两翻转</span><br>        prev = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prev.next;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n1.next = n2;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n2.next = n3;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n3.next = n4;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">n5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n4.next = n5;<br>        print(reverseKGroup(n1, <span class="hljs-number">3</span>));<br><br>        n1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">1</span>);<br>        n2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        n1.next = n2;<br>        n3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        n2.next = n3;<br>        n4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        n3.next = n4;<br>        n5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        n4.next = n5;<br>        print(reverseKGroup(n1, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.print(head.val);<br>            head = head.next;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">32145<br>21435<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题解法很简单，先分段反转，然后通过递归拼接。难点在于链表的指针，一不小心就指错了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SwapNodesInPairs</title>
    <link href="/2021/01/27/SwapNodesInPairs/"/>
    <url>/2021/01/27/SwapNodesInPairs/</url>
    
    <content type="html"><![CDATA[<h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/27/SwapNodesInPairs/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/27/SwapNodesInPairs/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwapNodesInPairs</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode swapPairs(ListNode head) &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode left = head;<br>        ListNode right = head.<span class="hljs-keyword">next</span>;<br>        ListNode <span class="hljs-keyword">next</span> = right.<span class="hljs-keyword">next</span>;<br>        ListNode prev = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        <span class="hljs-built_in">int</span> headIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 交换左右位置</span><br>            left.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>            right.<span class="hljs-keyword">next</span> = left;<br><br>            <span class="hljs-comment">// 保证链表不断</span><br>            prev.<span class="hljs-keyword">next</span> = right;<br>            prev = left;<br>            <span class="hljs-keyword">if</span> (headIndex == <span class="hljs-number">0</span>) &#123;<br>                head = right;<br>                headIndex ++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>                left = <span class="hljs-keyword">next</span>;<br>                right = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">next</span> = right.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        ListNode n1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode n2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        n1.<span class="hljs-keyword">next</span> = n2;<br>        ListNode n3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        n2.<span class="hljs-keyword">next</span> = n3;<br>        ListNode n4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        n3.<span class="hljs-keyword">next</span> = n4;<br>        <span class="hljs-keyword">print</span>(swapPairs(n1));<br><br>        ListNode n5 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(swapPairs(n5));<br><br>        ListNode n6 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">print</span>(swapPairs(n6));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2143</span><br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题居然没有想到可以递归，递归的代码少到可怜；然后自己写出来的是迭代，当然和官方答案比，代码量还是稍显多。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeKSortedLists</title>
    <link href="/2021/01/26/MergeKSortedLists/"/>
    <url>/2021/01/26/MergeKSortedLists/</url>
    
    <content type="html"><![CDATA[<h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/26/MergeKSortedLists/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/26/MergeKSortedLists/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><p>这里：元素为[]在java就是null，列表为空就是数组大小为空。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeKSortedLists</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode mergeKLists(ListNode[] lists) &#123;<br><br>        <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        ListNode head = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);<br>        ListNode cur = head;<br>        ListNode prev = cur;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (lists[i] == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">count</span> ++;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == lists.length &amp;&amp; <span class="hljs-keyword">index</span> &gt; <span class="hljs-number">-1</span>) &#123;<br>                        prev.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">return</span> head;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == lists.length) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (lists[i] != <span class="hljs-literal">null</span> &amp;&amp; lists[i].val &lt;= cur.val) &#123;<br>                    cur.val = lists[i].val;<br>                    <span class="hljs-keyword">index</span> = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lists[<span class="hljs-keyword">index</span>] != <span class="hljs-literal">null</span>) &#123;<br>                lists[<span class="hljs-keyword">index</span>] = lists[<span class="hljs-keyword">index</span>].<span class="hljs-keyword">next</span>;<br>            &#125;<br><br>            cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> ListNode(Integer.MAX_VALUE);<br>            prev = cur;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-comment">// lists = [[1,4,5],[1,3,4],[2,6]]</span><br>        ListNode a1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode a2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        a1.<span class="hljs-keyword">next</span> = a2;<br>        ListNode a3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);<br>        a2.<span class="hljs-keyword">next</span> = a3;<br><br>        ListNode a4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode a5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        a4.<span class="hljs-keyword">next</span> = a5;<br>        ListNode a6 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        a5.<span class="hljs-keyword">next</span> = a6;<br><br>        ListNode a7 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        ListNode a8 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">6</span>);<br>        a7.<span class="hljs-keyword">next</span> = a8;<br><br>        ListNode[] lists = <span class="hljs-keyword">new</span> ListNode[]&#123;a1, a4, a7&#125;;<br>        <span class="hljs-keyword">print</span>(mergeKLists(lists));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode node) &#123;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(node.val);<br>            node = node.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">11234456</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>这道题依然想出了三种思路，大致对应了官方的三种思路。第一种：一个一个合并，直到结束；第二种思路，就是两两归并，没想到效率这么高，所以计算复杂度是需要考虑到的；第三种，也是自己给出的结果，效率不是很理想，参考了官方答案，没想到用了PriorityQueue，利用优先队列本身的排序机制（小顶堆），非常巧妙。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GenerateParentheses</title>
    <link href="/2021/01/25/GenerateParentheses/"/>
    <url>/2021/01/25/GenerateParentheses/</url>
    
    <content type="html"><![CDATA[<h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/25/GenerateParentheses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/25/GenerateParentheses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></p><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java<span class="hljs-variable">.util</span><span class="hljs-variable">.ArrayList</span>;<br><span class="hljs-keyword">import</span> java<span class="hljs-variable">.util</span><span class="hljs-variable">.List</span>;<br><br>public <span class="hljs-keyword">class</span> GenerateParentheses &#123;<br><br>    <span class="hljs-comment">// n&lt;=8，所以最多也就64，因为开头结尾必须()</span><br>    <span class="hljs-keyword">static</span> ArrayList[] cache = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">100</span>];<br><br>    public <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-keyword">generate</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">if</span> (cache[n] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cache[n];<br>        &#125;<br>        ArrayList&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 长度为0当然是空</span><br>            ans<span class="hljs-variable">.add</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// c表示几对，因为已经有了默认的一对，所以小于n</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; ++c) &#123;<br>                <span class="hljs-keyword">for</span> (String left : <span class="hljs-keyword">generate</span>(c)) &#123;<br>                    <span class="hljs-comment">// 最大也就n-1，因为已经有了默认的一对</span><br>                    <span class="hljs-keyword">for</span> (String right: <span class="hljs-keyword">generate</span>(n - <span class="hljs-number">1</span> - c)) &#123;<br>                        <span class="hljs-comment">// 一对默认的，和左边的一对，右边的一对</span><br>                        ans<span class="hljs-variable">.add</span>(<span class="hljs-string">&quot;(&quot;</span> + left + <span class="hljs-string">&quot;)&quot;</span> + right);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cache[n] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> List&lt;String&gt; generateParenthesis(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">generate</span>(n);<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        System<span class="hljs-variable">.out</span><span class="hljs-variable">.println</span>(<span class="hljs-keyword">generate</span>(<span class="hljs-number">3</span>));<br><br>        System<span class="hljs-variable">.out</span><span class="hljs-variable">.println</span>(<span class="hljs-keyword">generate</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[()()(), ()(()), (())(), (()()), ((()))]<br>[()]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>本来以为是很难的，官方的三种思路都想过，自己算了下复杂度，感觉不对，没想到三种都想到了。也就是，一个生成，一个校验，这是第一种；校验的过程再给个优化，括号数量配对，这是第二种；开头结尾必须是()这两个，这是第三种，然后通过拼接分割右括号的左右字符串完成。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MergeTwoSortedLists</title>
    <link href="/2021/01/24/MergeTwoSortedLists/"/>
    <url>/2021/01/24/MergeTwoSortedLists/</url>
    
    <content type="html"><![CDATA[<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/24/MergeTwoSortedLists/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/24/MergeTwoSortedLists/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/merge_ex1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeTwoSortedLists</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br><br>        ListNode head;<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            head = l1;<br>            l1 = l1.<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = l2;<br>            l2 = l2.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                cur.<span class="hljs-keyword">next</span> = l1;<br>                cur = cur.<span class="hljs-keyword">next</span>;<br>                l1 = l1.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.<span class="hljs-keyword">next</span> = l2;<br>                cur = cur.<span class="hljs-keyword">next</span>;<br>                l2 = l2.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>            cur.<span class="hljs-keyword">next</span> = l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>            cur.<span class="hljs-keyword">next</span> = l1;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        ListNode node1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>        node1.<span class="hljs-keyword">next</span> = node2;<br>        ListNode node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        node2.<span class="hljs-keyword">next</span> = node3;<br><br>        ListNode node4 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>        ListNode node5 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>        node4.<span class="hljs-keyword">next</span> = node5;<br>        ListNode node6 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);<br>        node5.<span class="hljs-keyword">next</span> = node6;<br><br>        <span class="hljs-keyword">print</span>(mergeTwoLists(node1, node4));<br><br>        node1 = <span class="hljs-literal">null</span>;<br>        node2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(mergeTwoLists(node1, node2));<br><br>        node1 = <span class="hljs-literal">null</span>;<br>        node2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        node2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(mergeTwoLists(node1, node2));<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode node) &#123;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(node.val);<br>            node = node.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-built_in">int</span> val;<br>        ListNode <span class="hljs-keyword">next</span>;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">112344<br><br>0<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就是比较大小，顺序延展下去。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValidParentheses</title>
    <link href="/2021/01/24/ValidParentheses/"/>
    <url>/2021/01/24/ValidParentheses/</url>
    
    <content type="html"><![CDATA[<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/24/ValidParentheses/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/24/ValidParentheses/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;(]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;([)]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidParentheses</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">String</span> s)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() &lt; <span class="hljs-number">2</span> || s.<span class="hljs-built_in">length</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Map&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;Character, Character&gt;()&#123;&#123;<br>            <span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>            <span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>);<br>            <span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>);<br>        &#125;&#125;;<br><br>        <span class="hljs-type">char</span>[] chars = s.<span class="hljs-built_in">toCharArray</span>();<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> aChar : chars) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">get</span>(aChar) != null &amp;&amp; deque.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">1</span> &amp;&amp; deque.<span class="hljs-built_in">getLast</span>() == map.<span class="hljs-built_in">get</span>(aChar)) &#123;<br>                deque.<span class="hljs-built_in">pollLast</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                deque.<span class="hljs-built_in">add</span>(aChar);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br><br>        <span class="hljs-type">String</span> s = <span class="hljs-string">&quot;()&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br><br>        s = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br><br>        s = <span class="hljs-string">&quot;(]&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br><br>        s = <span class="hljs-string">&quot;)&#123;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">isValid</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就是栈。不过java的栈最好不要用stack类，用queue的实现比较好。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RemoveNthNodeFromEndOfList</title>
    <link href="/2021/01/23/RemoveNthNodeFromEndOfList/"/>
    <url>/2021/01/23/RemoveNthNodeFromEndOfList/</url>
    
    <content type="html"><![CDATA[<h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/23/RemoveNthNodeFromEndOfList/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/23/RemoveNthNodeFromEndOfList/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/remove_ex1.jpg" alt="1"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs axapta">package algorithm;<br><br>import java.util.HashMap;<br>import java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoveNthNodeFromEndOfList</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br><br>        Map&lt;Integer, ListNode&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        ListNode cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            map.put(<span class="hljs-keyword">index</span>, cur);<br>            <span class="hljs-keyword">index</span>++;<br>            cur = cur.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> addr = map.size() - n;<br>        <span class="hljs-keyword">if</span> (addr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> map.get(addr).<span class="hljs-keyword">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ListNode prev = map.get(addr - <span class="hljs-number">1</span>);<br>            cur = map.get(addr);<br>            prev.<span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">return</span> map.get(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        ListNode h1 = <span class="hljs-keyword">new</span> ListNode();<br>        h1.val = <span class="hljs-number">1</span>;<br><br>        ListNode h2 = <span class="hljs-keyword">new</span> ListNode();<br>        h2.val = <span class="hljs-number">2</span>;<br>        h1.<span class="hljs-keyword">next</span> = h2;<br><br>        ListNode h3 = <span class="hljs-keyword">new</span> ListNode();<br>        h3.val = <span class="hljs-number">3</span>;<br>        h2.<span class="hljs-keyword">next</span> = h3;<br><br>        ListNode h4 = <span class="hljs-keyword">new</span> ListNode();<br>        h4.val = <span class="hljs-number">4</span>;<br>        h3.<span class="hljs-keyword">next</span> = h4;<br><br>        ListNode h5 = <span class="hljs-keyword">new</span> ListNode();<br>        h5.val = <span class="hljs-number">5</span>;<br>        h4.<span class="hljs-keyword">next</span> = h5;<br>        <span class="hljs-keyword">print</span>(removeNthFromEnd1(h1, <span class="hljs-number">2</span>));<br><br>        h1.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(removeNthFromEnd1(h1, <span class="hljs-number">1</span>));<br><br>        h1.<span class="hljs-keyword">next</span> = h2;<br>        h2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">print</span>(removeNthFromEnd1(h1, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>(ListNode head) &#123;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            System.out.<span class="hljs-keyword">print</span>(head.val);<br>            head = head.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-built_in">int</span> val;<br>    ListNode <span class="hljs-keyword">next</span>;<br><br>    ListNode() &#123;<br>    &#125;<br><br>    ListNode(<span class="hljs-built_in">int</span> val) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br><br>    ListNode(<span class="hljs-built_in">int</span> val, ListNode <span class="hljs-keyword">next</span>) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1235</span><br><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是用存储获取位置。然后发现提交的效率不高，参考了官方的解题思路，又写了一版，这道题应该是不难的。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode removeNthFromEnd1(ListNode head, <span class="hljs-built_in">int</span> n) &#123;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        ListNode first = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>, head);<br>        ListNode second = first;<br>        ListNode lamd = first;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (first.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">count</span>++;<br>            first = first.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> &gt; n) &#123;<br><span class="hljs-comment">//                1 2 3 4 5</span><br>                second = second.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        second.<span class="hljs-keyword">next</span> = second.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>       <span class="hljs-keyword">return</span> lamd.<span class="hljs-keyword">next</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是两个指针，一个提前n个位置去右移。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FourSum</title>
    <link href="/2021/01/22/FourSum/"/>
    <url>/2021/01/22/FourSum/</url>
    
    <content type="html"><![CDATA[<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/22/FourSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/22/FourSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/4sum/">四数之和</a></p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[1, 0, -1, 0, -2, 2]</span>，和 target = 0。<br><br>满足要求的四元组集合为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1,  0, 0, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-2, -1, 1, 2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-2,  0, 0, 2]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FourSum</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists;<br>        &#125;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[length - <span class="hljs-number">3</span>] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="hljs-number">2</span>] + nums[length - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];<br>                    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                        List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[j], nums[left], nums[right]);<br>                        lists.add(list);<br>                        <span class="hljs-comment">// 这一段优化很精妙</span><br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>                            left++;<br>                        &#125;<br>                        left++;<br>                        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>                            right--;<br>                        &#125;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                        right--;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        left++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        System.out.println(fourSum(nums, target));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[[<span class="hljs-string">-3</span>, <span class="hljs-string">-2</span>, 2, 3], [<span class="hljs-string">-3</span>, <span class="hljs-string">-1</span>, 1, 3], [<span class="hljs-string">-3</span>, 0, 0, 3], [<span class="hljs-string">-3</span>, 0, 1, 2], [<span class="hljs-string">-2</span>, <span class="hljs-string">-1</span>, 0, 3], [<span class="hljs-string">-2</span>, <span class="hljs-string">-1</span>, 1, 2], [<span class="hljs-string">-2</span>, 0, 0, 2], [<span class="hljs-string">-1</span>, 0, 0, 1]]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针。其实做出来后，虽然pass了，但是发现效率比较低。所以还是参考了官方的解答，最后一层循环的优化，确实比较厉害。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LetterCombinationsOfAPhoneNumber</title>
    <link href="/2021/01/22/LetterCombinationsOfAPhoneNumber/"/>
    <url>/2021/01/22/LetterCombinationsOfAPhoneNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/22/LetterCombinationsOfAPhoneNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/22/LetterCombinationsOfAPhoneNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/17_telephone_keypad.png" alt="17"></p><p><strong>示例 :</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>, <span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-string">&quot;af&quot;</span>, <span class="hljs-string">&quot;bd&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;bf&quot;</span>, <span class="hljs-string">&quot;cd&quot;</span>, <span class="hljs-string">&quot;ce&quot;</span>, <span class="hljs-string">&quot;cf&quot;</span>].<br></code></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LetterCombinationsOfAPhoneNumber</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; combinations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> combinations;<br>        &#125;<br>        backtrack(combinations, phoneMap, digits, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>());<br>        <span class="hljs-keyword">return</span> combinations;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>        put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>        put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>        put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>        put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>        put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>        put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap,</span><br><span class="hljs-params">                          String digits, <span class="hljs-type">int</span> index, StringBuffer combination)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>            <span class="hljs-comment">// 已经到最后了，不需要递归</span><br>            combinations.add(combination.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> digits.charAt(index);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">letters</span> <span class="hljs-operator">=</span> phoneMap.get(first);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; letters.length(); i++) &#123;<br>                combination.append(letters.charAt(i));<br>                backtrack(combinations, phoneMap, digits, index + <span class="hljs-number">1</span>, combination);<br>                <span class="hljs-comment">// 上一步的拼装如果成功，for循环进行下一轮，需要删除这一层追加的同等级字母</span><br>                combination.deleteCharAt(index);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">digits</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;23&quot;</span>;<br>        System.out.println(letterCombinations(digits));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">[ad, ae, af, <span class="hljs-keyword">bd</span>, <span class="hljs-keyword">be</span>, <span class="hljs-keyword">bf</span>, <span class="hljs-keyword">cd</span>, <span class="hljs-keyword">ce</span>, <span class="hljs-keyword">cf</span>]<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>递归。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreeSumClosest</title>
    <link href="/2021/01/21/ThreeSumClosest/"/>
    <url>/2021/01/21/ThreeSumClosest/</url>
    
    <content type="html"><![CDATA[<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/21/ThreeSumClosest/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/21/ThreeSumClosest/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和</a></p><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p><strong>示例 :</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-4</span>], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (<span class="hljs-string">-1</span> + 2 + 1 = 2) 。<br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ThreeSumClosest &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> threeSumClosest(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> min = <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> k = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> == target) &#123;<br>                    <span class="hljs-keyword">return</span> target;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (Math.abs(<span class="hljs-keyword">temp</span> - target) &lt; Math.abs(min - target)) &#123;<br>                    min = <span class="hljs-keyword">temp</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">temp</span> &gt; target) &#123;<br>                    <span class="hljs-type">int</span> k1 = k - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> (k1 &gt; j &amp;&amp; nums[k] == nums[k1]) &#123;<br>                        k1<span class="hljs-comment">--;</span><br>                    &#125;<br>                    k = k1;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> j1 = j + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> (j1 &lt; k &amp;&amp; nums[j] == nums[j1]) &#123;<br>                        j1++;<br>                    &#125;<br>                    j = j1;<br>                &#125;<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-4</span>&#125;;<br>        <span class="hljs-type">int</span> target = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSumClosest(nums, target));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针思想。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreeSum</title>
    <link href="/2021/01/20/ThreeSum/"/>
    <url>/2021/01/20/ThreeSum/</url>
    
    <content type="html"><![CDATA[<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/20/ThreeSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/20/ThreeSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></p><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素<em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ThreeSum &#123;<br><br>    <span class="hljs-built_in">public</span> static List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; threeSum(<span class="hljs-type">int</span>[] nums) &#123;<br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; result = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                break;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> k = nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> target = -nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &gt; target) &#123;<br>                    break;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                // 缩小范围<br>                <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] + nums[j] &gt; target) &#123;<br>                    k<span class="hljs-comment">--;</span><br>                &#125;<br>                // 缩小范围<br>                <span class="hljs-keyword">if</span> (j == k) &#123;<br>                    break;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (nums[k] + nums[j] == target) &#123;<br>                    List&lt;<span class="hljs-type">Integer</span>&gt; unit = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>                    unit.<span class="hljs-keyword">add</span>(nums[i]);<br>                    unit.<span class="hljs-keyword">add</span>(nums[j]);<br>                    unit.<span class="hljs-keyword">add</span>(nums[k]);<br>                    result.<span class="hljs-keyword">add</span>(unit);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main (String[]args)&#123;<br><br>            <span class="hljs-type">int</span>[] nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>&#125;;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSum(nums));<br><br>            nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSum(nums));<br><br>            nums = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(threeSum(nums));<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[-1, -1, 2]</span>, <span class="hljs-comment">[-1, 0, 1]</span>]</span><br><span class="hljs-comment">[]</span><br><span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestCommonPrefix</title>
    <link href="/2021/01/19/LongestCommonPrefix/"/>
    <url>/2021/01/19/LongestCommonPrefix/</url>
    
    <content type="html"><![CDATA[<h2 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/19/LongestCommonPrefix/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/19/LongestCommonPrefix/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongestCommonPrefix</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(<span class="hljs-type">String</span>[] strs)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (strs.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        StringBuilder s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-type">String</span> str = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-type">boolean</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">char</span> a = str.<span class="hljs-built_in">charAt</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= strs[j].<span class="hljs-built_in">length</span>() || a != strs[j].<span class="hljs-built_in">charAt</span>(i)) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            s.<span class="hljs-built_in">append</span>(a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">toString</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span>[] strs = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[]&#123;<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestCommonPrefix</span>(strs));<br><br>        strs = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[]&#123;<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">longestCommonPrefix</span>(strs));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fl</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就不说了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IntegerToRoman</title>
    <link href="/2021/01/12/IntegerToRoman/"/>
    <url>/2021/01/12/IntegerToRoman/</url>
    
    <content type="html"><![CDATA[<h2 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/12/RomanToInteger/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/12/RomanToInteger/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数</a></p><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">字符          数值<br><span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><br><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><br><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><br><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><br><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><br><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><br><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: III</span><br><span class="hljs-section">输出: &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: IV</span><br><span class="hljs-section">输出: &quot;4&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: IX</span><br><span class="hljs-section">输出: &quot;9&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: LVIII</span><br><span class="hljs-section">输出: &quot;58&quot;</span><br><span class="hljs-section">解释: L = 50, V = 5, III = 3.</span><br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: MCMXCIV</span><br><span class="hljs-section">输出: &quot;1994&quot;</span><br><span class="hljs-section">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></code></pre></td></tr></table></figure><h3 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs sas">package algorithm;<br><br>import java.util.HashMap;<br>import java.util.Map;<br><br>public class RomanToInteger &#123;<br><br>    public static Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;()&#123;&#123;<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;I&#x27;</span>, 1);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;V&#x27;</span>, 5);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;X&#x27;</span>, 10);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;L&#x27;</span>, 50);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;C&#x27;</span>, 100);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;D&#x27;</span>, 500);<br>        <span class="hljs-meta">put</span>(<span class="hljs-string">&#x27;M&#x27;</span>, 1000);<br>    &#125;&#125;;<br><br>    public static int romanTo<span class="hljs-meta">Int</span>(String s) &#123;<br><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-meta">length</span>() &lt;= 1) &#123;<br>            <span class="hljs-keyword">return</span> map.get(s.charAt(0));<br>        &#125;<br><br>        int result = 0;<br>        for (int i = 0; i &lt; s.<span class="hljs-meta">length</span>() - 1; i++) &#123;<br>            int first = map.get(s.charAt(i));<br>            int next = map.get(s.charAt(i + 1));<br><br>            <span class="hljs-keyword">if</span> (first &lt; next) &#123;<br>                first <span class="hljs-comment">*= -1;</span><br>            &#125;<br>            result += first;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result + map.get(s.charAt(s.<span class="hljs-meta">length</span>() - 1));<br>    &#125;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br><br>        String s;<br><br>        s = <span class="hljs-string">&quot;III&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;IV&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;IX&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;LVIII&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br><br>        s = <span class="hljs-string">&quot;MCMXCIV&quot;</span>;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(romanTo<span class="hljs-meta">Int</span>(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">9</span><br><span class="hljs-number">58</span><br><span class="hljs-number">1994</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>很简单，就不说了。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis 如何存储上亿级别的用户状态？</title>
    <link href="/2021/01/11/Redis%20%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%8A%E4%BA%BF%E7%BA%A7%E5%88%AB%E7%9A%84%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%EF%BC%9F/"/>
    <url>/2021/01/11/Redis%20%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E4%B8%8A%E4%BA%BF%E7%BA%A7%E5%88%AB%E7%9A%84%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-如何存储上亿级别的用户状态？"><a href="#Redis-如何存储上亿级别的用户状态？" class="headerlink" title="Redis 如何存储上亿级别的用户状态？"></a>Redis 如何存储上亿级别的用户状态？</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自[这篇博客](<a href="https://yangtzeshore.github.io/2021/01/11/Redis">https://yangtzeshore.github.io/2021/01/11/Redis</a> 如何存储上亿级别的用户状态&#x2F;<a href="http://www.jianshu.com/p/ee79ae681b74)%EF%BC%8C%E4%BD%9C%E4%B8%BA%E6%95%B4%E7%90%86%E5%92%8C%E6%94%B6%E5%BD%95%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%90%8E%E7%BB%AD%E6%9F%A5%E9%98%85%E3%80%82">www.jianshu.com/p/ee79ae681b74)，作为整理和收录，方便后续查阅。</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><hr><p>前段时间，在网上看到一道面试题：</p><p><strong>如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量。</strong></p><p>觉得很有意思，就仔细想了下 。并做了一系列实验，自己模拟了下 。还是有点收获的，现整理下来。和大家一起分享。</p><p>Redis是一个内存数据库，采用单线程和事件驱动的机制来处理网络请求。实际生产的QPS和TPS单台都能达到3,4W，读写性能非常棒。用来存储一些对核心业务弱影响的用户状态信息还是非常不错的。</p><p><strong>对于这题，有2个重要的点需要考虑：</strong></p><p>1.如何用合适的数据类型来存储1亿用户的数据，用普通的字符串来存储肯定不行。经过查看一个最简单的kv(key为aaa，value为1)的内存占用，发现为48byte。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi1.png" alt="图片"></p><p>假设每个用户每天登陆需要占据1对KV的话，那一亿就是(48*100000000)&#x2F;1024&#x2F;1024&#x2F;1024&#x3D;4.47G。这还是一天的量。</p><p>2.如何满足搜索，redis是一个键值对的内存结构，只能根据key来进行定位value值，无法做到像elastic search那样对文档进行倒排索引快速全文检索。</p><p>redis其实有这种数据结构的，可以以很少的空间来存储大量的信息。</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><hr><p>在redis 2.2.0版本之后，新增了一个位图数据，其实它不是一种数据结构。实际上它就是一个一个字符串结构，只不过value是一个二进制数据，每一位只能是0或者1。</p><p>redis单独对bitmap提供了一套命令。可以对任意一位进行设置和读取。</p><p>bitmap的核心命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SETBIT</span><br></code></pre></td></tr></table></figure><blockquote><p>语法：SETBIT key offset value</p><p>例如：</p><p>setbit abc 5 1 ——&gt; 00001</p><p>setbit abc 2 1 ——&gt; 00101</p></blockquote><p>GETBIT</p><blockquote><p>语法：GETBIT key offset</p><p>例如：</p><p>getbit abc 5 ——&gt; 1</p><p>getbit abc 1 ——&gt; 0</p></blockquote><p>bitmap的其他命令还有bitcount，bitcount，bitpos，bitop等命令。都是对位的操作。</p><p>因为bitmap的每一位只占据1bit的空间 ，所以利用这个特性我们可以把每一天作为key，value为1亿用户的活跃度状态。假设一个用户一天内只要登录了一次就算活跃。活跃我们就记为1，不活跃我们就记为0。把用户Id作为偏移量(offset)。这样我们一个key就可以存储1亿用户的活跃状态。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi2.png" alt="图片"></p><p>我们再来算下，这样一个位图结构的值对象占据多少空间。每一个位是1bit，一亿用户就是一亿bit。8bit&#x3D;1Byte</p><p>100000000&#x2F;8&#x2F;1024&#x2F;1024&#x3D;11.92M</p><p>我用测试工程往一个key里通过lua塞进了1亿个bit，然后用rdb tools对内存进行统计，实测如下：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi3.png" alt="图片"></p><p>一天1亿用户也就消耗12M的内存空间。这完全符合要求。1年的话也就4个G。几年下来的话，redis可以集群部署来进行扩容存储。我们也可以用位图压缩算法对bitmap进行压缩存储。例如WAH，EWAH，Roaring Bitmaps。这个以后可以单独拉出来聊聊。</p><p>我们把每一天1亿用户的登陆状态都用bitmap的形式存进了redis，那要获取某一天id为88000的用户是否活跃，直接使用<code>getbit</code>命令：</p><blockquote><p>getbit 2020-01-01 88000 [时间复杂度为O(1)]</p></blockquote><p>如果要统计某一天的所有的活跃用户数，使用<code>bitcount</code>命令，bitcount可以统计1的个数，也就是活跃用户数：</p><blockquote><p>bitcount 2019-01-01 [时间复杂度为O(N)]</p></blockquote><p>如果要统计某一段时间内的活跃用户数，需要用到bitop命令。这个命令提供四种位运算，<code>AND(与)</code>，<code>(OR)或</code>，<code>XOR(亦或)</code>，<code>NOT(非)</code>。我们可以对某一段时间内的所有key进行<code>OR(或)</code>操作，或操作出来的位图是0的就代表这段时间内一次都没有登陆的用户。那只要我们求出1的个数就可以了。以下例子求出了2019-01-01到2019-01-05这段时间内的活跃用户数。</p><blockquote><p>bitop or result 2019-01-01 2019-01-02 2019-01-03 2019-01-04 2019-01-05 [时间复杂度为O(N)]</p><p>bitcount result</p></blockquote><p>从时间复杂度上说，无论是统计某一天，还是统计一段时间。在实际测试时，基本上都是秒出的。符合我们的预期。</p><h3 id="bitmap使用场景"><a href="#bitmap使用场景" class="headerlink" title="bitmap使用场景"></a>bitmap使用场景</h3><hr><p>bitmap可以很好的满足一些需要记录大量而简单信息的场景。所占空间十分小。通常来说使用场景分2类：</p><p>1.某一业务对象的横向扩展，key为某一个业务对象的id，比如记录某一个终端的功能开关，1代表开，0代表关。基本可以无限扩展，可以记录2^32个位信息。不过这种用法由于key上带有了业务对象的id，导致了key的存储空间大于了value的存储空间，从空间使用角度上来看有一定的优化空间。</p><p>2.某一业务的纵向扩展，key为某一个业务，把每一个业务对象的id作为偏移量记录到位上。这道面试题的例子就是用此法来进行解决。十分巧妙的利用了用户的id作为偏移量来找到相对应的值。当业务对象数量超过2^32时（约等于42亿），还可以分片存储。</p><p>看起来bitmap完美的解决了存储和统计的问题。那有没有比这个更加省空间的存储吗？</p><p>答案是有的。</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><hr><p>redis从2.8.9之后增加了HyperLogLog数据结构。这个数据结构，根据redis的官网介绍，这是一个概率数据结构，用来估算数据的基数。能通过牺牲准确率来减少内存空间的消耗。</p><p>我们先来看看HyperLogLog的方法</p><blockquote><p>PFADD 添加一个元素，如果重复，只算作一个</p><p>PFCOUNT 返回元素数量的近似值</p><p>PFMERGE 将多个 HyperLogLog 合并为一个 HyperLogLog</p></blockquote><p>这很好理解，是不是。那我们就来看看同样是存储一亿用户的活跃度，HyperLogLog数据结构需要多少空间。是不是比bitmap更加省空间呢。</p><p>我通过测试工程往HyperLogLog里PFADD了一亿个元素。通过rdb tools工具统计了这个key的信息：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Redis/yi4.png" alt="图片"></p><p>只需要14392 Bytes！也就是14KB的空间。对，你没看错。就是14K。bitmap存储一亿需要12M，而HyperLogLog只需要14K的空间。</p><p>这是一个很惊人的结果。我似乎有点不敢相信使用如此小的空间竟能存储如此大的数据量。</p><p>接下来我又放了1000w数据，统计出来还是14k。也就是说，无论你放多少数据进去，都是14K。</p><p>查了文档，发现HyperLogLog是一种概率性数据结构，在标准误差0.81%的前提下，能够统计2^64个数据。所以 HyperLogLog 适合在比如统计日活月活此类的对精度要不不高的场景。</p><p>HyperLogLog使用概率算法来统计集合的近似基数。而它算法的最本源则是伯努利过程。</p><p>伯努利过程就是一个抛硬币实验的过程。抛一枚正常硬币，落地可能是正面，也可能是反面，二者的概率都是 1&#x2F;2 。伯努利过程就是一直抛硬币，直到落地时出现正面位置，并记录下抛掷次数k。比如说，抛一次硬币就出现正面了，此时 k 为 1; 第一次抛硬币是反面，则继续抛，直到第三次才出现正面，此时 k 为 3。</p><p>对于 n 次伯努利过程，我们会得到 n 个出现正面的投掷次数值 k1, k2 … kn , 其中这里的最大值是k_max。</p><p>根据一顿数学推导，我们可以得出一个结论：2^{k_ max} 来作为n的估计值。也就是说你可以根据最大投掷次数近似的推算出进行了几次伯努利过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><p>虽然HyperLogLog数据类型这么牛逼，但终究不是精确统计。只适用于对精度要求不高的场景。而且这种类型无法得出每个用户的活跃度信息。毕竟只有14K嘛。也不可能存储下那么多数量的信息。</p><p>总结一下：对于文章开头所提到的面试题来说，用bitmap和HyperLogLog都可以解决。</p><p>bitmap的优势是：非常均衡的特性，精准统计，可以得到每个统计对象的状态，秒出。缺点是：当你的统计对象数量十分十分巨大时，可能会占用到一点存储空间，但也可在接受范围内。也可以通过分片，或者压缩的额外手段去解决。</p><p>HyperLogLog的优势是：可以统计夸张到无法想象的数量，并且占用小的夸张的内存。缺点是：建立在牺牲准确率的基础上，而且无法得到每个统计对象的状态。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[1. Redis 如何存储上亿级别的用户状态？](<a href="https://yangtzeshore.github.io/2021/01/11/Redis">https://yangtzeshore.github.io/2021/01/11/Redis</a> 如何存储上亿级别的用户状态&#x2F;<a href="http://www.jianshu.com/p/ee79ae681b74">www.jianshu.com/p/ee79ae681b74</a>)</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单点登录的三种实现方式</title>
    <link href="/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单点登录的三种实现方式"><a href="#单点登录的三种实现方式" class="headerlink" title="单点登录的三种实现方式"></a>单点登录的三种实现方式</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://yangtzeshore.github.io/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/cnblogs.com/yonghengzh/p/13712729.html">这篇博客</a>，作为整理和收录，方便后续查阅。</p><ul><li>引子</li><li>实现方式一：父域 Cookie</li><li>实现方式二：认证中心</li><li>实现方式三：LocalStorage 跨域</li><li>补充：域名分级</li></ul><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>在 B&#x2F;S 系统中，登录功能通常都是基于 Cookie 来实现的。当用户登录成功后，一般会将登录状态记录到 Session 中，或者是给用户签发一个 Token，无论哪一种方式，都需要在客户端保存一些信息（Session ID 或 Token ），并要求客户端在之后的每次请求中携带它们。</p><p>在这样的场景下，使用 Cookie 无疑是最方便的，因此我们一般都会将 Session 的 ID 或 Token 保存到 Cookie 中，当服务端收到请求后，通过验证 Cookie 中的信息来判断用户是否登录 。</p><p>单点登录（Single Sign On, SSO）是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。</p><p>举例来说，百度贴吧和百度地图是百度公司旗下的两个不同的应用系统，如果用户在百度贴吧登录过之后，当他访问百度地图时无需再次登录，那么就说明百度贴吧和百度地图之间实现了单点登录。</p><p>单点登录的本质就是在多个应用系统中共享登录状态。如果用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，比如可以将 Session 序列化到 Redis 中，让多个应用系统共享同一个 Redis，直接读取 Redis 来获取 Session。</p><p>当然仅此是不够的，因为不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 Session ID 是往往保存在浏览器 Cookie 中的，因此存在作用域的限制，无法跨域名传递，也就是说当用户在 app1.com 中登录后，Session ID 仅在浏览器访问 app1.com 时才会自动在请求头中携带，而当浏览器访问 app2.com 时，Session ID 是不会被带过去的。实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。</p><h3 id="实现方式一：父域-Cookie"><a href="#实现方式一：父域-Cookie" class="headerlink" title="实现方式一：父域 Cookie"></a>实现方式一：父域 Cookie</h3><p>在将具体实现之前，我们先来聊一聊 Cookie 的作用域。</p><p>Cookie 的作用域由 domain 属性和 path 属性共同决定。domain 属性的有效值为当前域或其父域的域名&#x2F;IP地址，在 Tomcat 中，domain 属性默认为当前域的域名&#x2F;IP地址。path 属性的有效值是以“&#x2F;”开头的路径，在 Tomcat 中，path 属性默认为当前 Web 应用的上下文路径。</p><p>如果将 Cookie 的 domain 属性设置为当前域的父域，那么就认为它是父域 Cookie。Cookie 有一个特点，即父域中的 Cookie 被子域所共享，换言之，子域会自动继承父域中的Cookie。</p><p>利用 Cookie 的这个特点，不难想到，将 Session ID（或 Token）保存到父域中不就行了。没错，我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。</p><p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。</p><p>总结：此种实现方式比较简单，但不支持跨主域名。</p><h3 id="实现方式二：认证中心"><a href="#实现方式二：认证中心" class="headerlink" title="实现方式二：认证中心"></a>实现方式二：认证中心</h3><p>我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。</p><p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）</p><p>应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。</p><p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。</p><p>应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。</p><p>这里顺便介绍两款认证中心的开源实现：</p><ul><li>Apereo CAS 是一个企业级单点登录系统，其中 CAS 的意思是”Central Authentication Service“。它最初是耶鲁大学实验室的项目，后来转让给了 JASIG 组织，项目更名为 JASIG CAS，后来该组织并入了Apereo 基金会，项目也随之更名为 Apereo CAS。</li><li>XXL-SSO 是一个简易的单点登录系统，由大众点评工程师许雪里个人开发，代码比较简单，没有做安全控制，因而不推荐直接应用在项目中，这里列出来仅供参考。</li></ul><p>总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。</p><h3 id="实现方式三：LocalStorage-跨域"><a href="#实现方式三：LocalStorage-跨域" class="headerlink" title="实现方式三：LocalStorage 跨域"></a>实现方式三：LocalStorage 跨域</h3><p>前面，我们说实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。</p><p>父域 Cookie 确实是一种不错的解决方案，但是不支持跨域。那么有没有什么奇淫技巧能够让 Cookie 跨域传递呢？</p><p>很遗憾，浏览器对 Cookie 的跨域限制越来越严格。Chrome 浏览器还给 Cookie 新增了一个 SameSite 属性，此举几乎禁止了一切跨域请求的 Cookie 传递（超链接除外），并且只有当使用 HTTPs 协议时，才有可能被允许在 AJAX 跨域请求中接受服务器传来的 Cookie。</p><p>不过，在前后端分离的情况下，完全可以不使用 Cookie，我们可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID （或 Token ）放在响应体中传递给前端。</p><p>在这样的场景下，单点登录完全可以在前端实现。前端拿到 Session ID （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中。</p><p>关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取 token</span><br><span class="hljs-keyword">var</span> token = result.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>;<br><br><span class="hljs-comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span><br><span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;iframe&quot;</span>);<br>iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://app1.com/localstorage.html&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(iframe);<br><span class="hljs-comment">// 使用postMessage()方法将token传递给iframe</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(token, <span class="hljs-string">&quot;http://app1.com&quot;</span>);<br>&#125;, <span class="hljs-number">4000</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    iframe.<span class="hljs-title function_">remove</span>();<br>&#125;, <span class="hljs-number">6000</span>);<br><br><span class="hljs-comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, event.<span class="hljs-property">data</span>)<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。</p><p>总结：此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域。</p><h3 id="补充：域名分级"><a href="#补充：域名分级" class="headerlink" title="补充：域名分级"></a>补充：域名分级</h3><p>从专业的角度来说（根据《计算机网络》中的定义），.com、.cn 为一级域名（也称顶级域名），.com.cn、baidu.com 为二级域名，sina.com.cn、tieba.baidu.com 为三级域名，以此类推，N 级域名就是 N-1 级域名的直接子域名。</p><p>从使用者的角度来说，一般把可支持独立备案的主域名称作一级域名，如 baidu.com、sina.com.cn 皆可称作一级域名，在主域名下建立的直接子域名称作二级域名，如 tieba.baidu.com 为二级域名。</p><p>为了避免歧义，本人将使用“主域名“替代”一级域名“的说法。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://yangtzeshore.github.io/2021/01/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/cnblogs.com/yonghengzh/p/13712729.html">1. 单点登录的三种实现方式</a></p>]]></content>
    
    
    <categories>
      
      <category>登录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ContainerWithMostWater</title>
    <link href="/2021/01/10/ContainerWithMostWater/"/>
    <url>/2021/01/10/ContainerWithMostWater/</url>
    
    <content type="html"><![CDATA[<h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/10/ContainerWithMostWater/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/10/ContainerWithMostWater/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p><p>给你 n 个非负整数 a1,a2,…,an，每个数代表坐标中的一个点 (i,ai) 。在坐标内画条垂直 n 线，垂直线 i 的两个端点分别为 (i,ai) 和 (i,0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/ContainerWithMostWater.jpg" alt="ContainerWithMostWater"></p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,3,2,1,4]</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n = height.length</code></li><li><code>2 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li></ul><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题如果没想到双指针，也很简单，下面是自己写的一版。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerWithMostWater</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = height.length - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;<br>                <span class="hljs-type">int</span> temp = (j - i) * Math.<span class="hljs-built_in">min</span>(height[i], height[j]);<br>                <span class="hljs-keyword">if</span> (temp &gt; max) &#123;<br>                    max = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] height = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>        height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>        height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>        height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">maxArea</span>(height));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">49<br>1<br>16<br>2<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是类似于暴力破解。</p><p>如果是双指针，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> area = Math.<span class="hljs-built_in">min</span>(height[l], height[r]) * (r - l);<br>            ans = Math.<span class="hljs-built_in">max</span>(ans, area);<br>            <span class="hljs-keyword">if</span> (height[l] &lt;= height[r]) &#123;<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                --r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针的思路需要数学证明的。</p><p><strong>证明</strong></p><p>为什么双指针的做法是正确的？</p><blockquote><p>双指针代表了什么？</p></blockquote><p>双指针代表的是 <strong>可以作为容器边界的所有位置的范围</strong>。在一开始，双指针指向数组的左右边界，表示 <strong>数组中所有的位置都可以作为容器的边界</strong>，因为我们还没有进行过任何尝试。在这之后，我们每次将 <strong>对应的数字较小的那个指针</strong> 往 <strong>另一个指针</strong> 的方向移动一个位置，就表示我们认为 <strong>这个指针不可能再作为容器的边界了</strong>。</p><blockquote><p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p></blockquote><p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p><p><strong>考虑第一步</strong>，假设当前左指针和右指针指向的数分别为 x 和 y ，不失一般性，我们假设 x&lt;y。同时，两个指针之间的距离为 t 。那么，它们组成的容器的容量为：</p><p>min(x,y)∗t&#x3D;x∗t</p><p>我们可以断定，<strong>如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 x∗t 了</strong>。注意这里右指针只能向左移动，因为 <strong>我们考虑的是第一步</strong>，也就是 <strong>指针还指向数组的左右边界的时候</strong>。</p><p>我们任意向左移动右指针，指向的数为 y1，两个指针之间的距离为 t1 ，那么显然有 t1&lt;t，并且 min(x,y1)≤min(x,y) ：</p><ul><li>如果 y1≤y，那么 min(x,y1)≤min(x,y)；</li><li>如果 y1&gt;y，那么 min(x,y1)&#x3D;x&#x3D;min(x,y)；</li></ul><p>因此有：</p><p>min(x,y1)∗t1&lt;min(x,y)∗t</p><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，<strong>这个左指针对应的数不会作为容器的边界了</strong>，那么我们就可以丢弃这个位置，<strong>将左指针向右移动一个位置</strong>，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p><p>这样以来，我们将问题的规模减小了 1 ，被我们丢弃的那个位置就相当于消失了。<strong>此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界</strong>，因此，我们可以继续像之前 <strong>考虑第一步</strong> 那样考虑这个问题：</p><ul><li>求出当前双指针对应的容器的容量；</li><li>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</li></ul><blockquote><p>最后的答案是什么？</p></blockquote><p>答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PalindromeNumber</title>
    <link href="/2021/01/09/PalindromeNumber/"/>
    <url>/2021/01/09/PalindromeNumber/</url>
    
    <content type="html"><![CDATA[<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/09/PalindromeNumber/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/09/PalindromeNumber/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/palindrome-number/">回文数</a></p><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 121</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: -121</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 10</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="hljs-section">进阶:</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong></p><p>你能不将整数转为字符串来解决这个问题吗？</p><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题如果不考虑进阶，那很简单，下面是自己写的一版。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> PalindromeNumber &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isPalindrome(<span class="hljs-type">int</span> x) &#123;<br>        String result = String.valueOf(x);<br>        <span class="hljs-keyword">if</span> (result.length() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (result.charAt(i) != result.charAt(result.length() - i - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isPalindrome(<span class="hljs-number">121</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isPalindrome(<span class="hljs-number">-121</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(isPalindrome(<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>就是类似于暴力破解。</p><p>如果是进阶版，不需要用字符串：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> isPalindrome1(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = x;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">temp</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> modNum = <span class="hljs-keyword">temp</span> % <span class="hljs-number">10</span>;<br>            result = result * <span class="hljs-number">10</span> + modNum;<br>            <span class="hljs-keyword">temp</span> /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == result;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>也很简单，无法是取模。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>StringToIntegerAtoi</title>
    <link href="/2021/01/08/StringToIntegerAtoi/"/>
    <url>/2021/01/08/StringToIntegerAtoi/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/08/StringToIntegerAtoi/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/08/StringToIntegerAtoi/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a></p><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><ul><li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li><li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li><li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li></ul><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p><strong>提示：</strong></p><ul><li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li><li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [− 231, 231−1]。如果数值超过这个范围，请返回 INT_MAX ( 231−1 )或INT_MIN (− 231 ) 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。因此无法执行有效的转换。</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 20</li><li>0 &lt;&#x3D; p.length &lt;&#x3D; 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题没有做出来，参考了官方的解题思路，只要看懂了，写出自动机，解题并不难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringToIntegerAtoi</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myAtoi</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">Automaton</span> <span class="hljs-variable">automaton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Automaton</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            automaton.get(str.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (automaton.sign * automaton.ans);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;21474836460&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;   -42&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;4193 with words&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;words and 987&quot;</span>;<br>        System.out.println(myAtoi(s));<br><br>        s = <span class="hljs-string">&quot;-91283472332&quot;</span>;<br>        System.out.println(myAtoi(s));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Automaton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;start&quot;</span>;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String[]&gt; table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String[]&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        put(<span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        put(<span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        put(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>    &#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        state = table.get(state)[get_col(c)];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;in_number&quot;</span>.equals(state)) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ans = sign == <span class="hljs-number">1</span> ? Math.min(ans, (<span class="hljs-type">long</span>) Integer.MAX_VALUE) : Math.min(ans, -(<span class="hljs-type">long</span>) Integer.MIN_VALUE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;signed&quot;</span>.equals(state)) &#123;<br>            sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_col</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">2147483647<br><span class="hljs-deletion">-42</span><br>4193<br>0<br><span class="hljs-deletion">-2147483648</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p><strong>自动机</strong></p><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。</p><p>因此，为了有条理地分析每个输入字符的处理方法，我们可以使用自动机这个概念：</p><p>我们的程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，并根据字符 c 转移到下一个状态 s’。这样，我们只需要建立一个覆盖所有情况的从 s 与 c 映射到 s’ 的表格即可解决题目中的问题。</p><p><strong>算法</strong></p><p>本题可以建立如下图所示的自动机：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Leetcode/%E8%87%AA%E5%8A%A8%E6%9C%BA.png" alt="自动机"></p><p>我们也可以用下面的表格来表示这个自动机：</p><table><thead><tr><th align="center"></th><th align="center">‘ ‘</th><th align="center">+&#x2F;-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">in_number</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>接下来编程部分就非常简单了：我们只需要把上面这个状态转换表抄进代码即可。</p><p>另外自动机也需要记录当前已经输入的数字，只要在 s’ 为 in_number 时，更新我们输入的数字，即可最终得到输入的数字。</p><p>注意：只有5个状态是有效的。</p><p><strong>复杂度分析</strong></p><p><strong>时间复杂度</strong>：O(n)，其中 n为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。</p><p><strong>空间复杂度</strong>：O(1)，自动机的状态只需要常数空间存储。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RegularExpressionMatching</title>
    <link href="/2021/01/07/RegularExpressionMatching/"/>
    <url>/2021/01/07/RegularExpressionMatching/</url>
    
    <content type="html"><![CDATA[<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/07/RegularExpressionMatching/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/07/RegularExpressionMatching/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></p><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa&quot;</span> p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span><br>输出：false<br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span> p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span> p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aab&quot;</span> p = <span class="hljs-string">&quot;c*a*b&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="hljs-string">&#x27;c&#x27;</span> 为 <span class="hljs-number">0</span> 个, <span class="hljs-string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="hljs-string">&quot;aab&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mississippi&quot;</span> p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mis*is*p*.&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 20</li><li>0 &lt;&#x3D; p.length &lt;&#x3D; 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这道题没有做出来，参考了官方的解题思路，只要看懂了，写出动态方程，解题并不难。如果是感性的字符匹配理解的话，很容易陷入死循环的理解和字符匹配泥沼。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegularExpressionMatching</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">String</span> s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;aa&quot;</span>; p = <span class="hljs-string">&quot;a*&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;ab&quot;</span>; p = <span class="hljs-string">&quot;.*&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;aab&quot;</span>; p = <span class="hljs-string">&quot;c*a*b&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br><br>        s = <span class="hljs-string">&quot;mississippi&quot;</span>; p = <span class="hljs-string">&quot;mis*is*p*.&quot;</span>;<br>        System.out.<span class="hljs-built_in">print</span>(<span class="hljs-built_in">isMatch</span>(s, p));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-comment">// 注意初始化都是false</span><br>        <span class="hljs-type">boolean</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-type">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 对着公式，这是缩减写法</span><br>                    f[i][j] = f[i][j - <span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matches</span>(s, p, i, j - <span class="hljs-number">1</span>)) &#123;<br>                        f[i][j] = f[i][j] || f[i - <span class="hljs-number">1</span>][j];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matches</span>(s, p, i, j)) &#123;<br>                        f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br><br>    <span class="hljs-comment">// 这里比较的一定是字符情况，所以不必考虑星号；且j一定是大于1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(<span class="hljs-type">String</span> s, <span class="hljs-type">String</span> p, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == p.<span class="hljs-built_in">charAt</span>(j - <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>题目中的匹配是一个「逐步匹配」的过程：我们每次从字符串 <code>p</code> 中取出一个字符或者「字符 + 星号」的组合，并在 <code>s</code> 中进行匹配。对于 <code>p</code> 中一个字符而言，它只能在<code>s</code>中匹配一个字符，匹配的方法具有唯一性；而对于 <code>p</code> 中字符 + 星号的组合而言，它可以在 <code>s</code> 中匹配任意自然数个字符，并不具有唯一性。因此我们可以考虑使用动态规划，对匹配的方案进行枚举。</p><p>我们用 <code>f[i][j]</code>表示 <code>s</code> 的前<code>i</code>个字符与<code>p</code> 中的前<code>j</code>个字符是否能够匹配。在进行状态转移时，我们考虑<code>p</code>的第<code>j</code>个字符的匹配情况：</p><ul><li>如果<code>p</code>的第<code>j</code>个字符是一个小写字母，那么我们必须在<code>s</code>中匹配一个相同的小写字母，即，，f[i][j]&#x3D;{f[i−1][j−1]，s[i]&#x3D;p[j]false，s[i]≠p[j]</li></ul><p>也就是说，如果s的第i个字符与p 的第j个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符，完整的匹配结果取决于两个字符串前面的部分。</p><ul><li>如果p 的第j个字符是 <code>*</code>，那么就表示我们可以对 p 的第j−1 个字符匹配任意自然数次。在匹配 0 次的情况下，我们有f[i][j]&#x3D;f[i][j−2]</li></ul><p>也就是我们「浪费」了一个字符 + 星号的组合，没有匹配任何 s中的字符。</p><p>在匹配 1,2,3,⋯ 次的情况下，类似地我们有</p><p>{f[i][j]&#x3D;f[i−1][j−1],ifs[i]&#x3D;p[j−1]f[i][j]&#x3D;f[i−2][j−1],ifs[i−1]&#x3D;s[i]&#x3D;p[j−1]f[i][j]&#x3D;f[i−3][j−1],ifs[i−2]&#x3D;s[i−1]&#x3D;s[i]&#x3D;p[j−1]…</p><p>如果我们通过这种方法进行转移，那么我们就需要枚举这个组合到底匹配了s中的几个字符，会增导致时间复杂度增加，并且代码编写起来十分麻烦。我们不妨换个角度考虑这个问题：字母 + 星号的组合在匹配的过程中，本质上只会有两种情况：</p><ul><li>匹配 s末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</li><li>不匹配字符，将该组合扔掉，不再进行匹配。</li></ul><p>如果按照这个角度进行思考，我们可以写出很精巧的状态转移方程：</p><p>，，f[i][j]&#x3D;{f[i−1][j]orf[i][j−2]，s[i]&#x3D;p[j−1]f[i][j−2]，s[i]≠p[j]</p><p>右边的很好理解，就是没有匹配的情况。左边的需要结合实例，理解下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">aaaa*<br><span class="hljs-keyword">aaa</span><br><br><span class="hljs-keyword">aaa</span>*<br><span class="hljs-keyword">aaa</span><br><br><span class="hljs-keyword">aaa</span>*<br>aaaa<br></code></pre></td></tr></table></figure><ul><li>在任意情况下，只要p[j] 是 .，那么一定p[j]成功匹配中的任 s意一个小写字母。</li></ul><p>最终的状态转移方程如下：</p><p>，，，，f[i][j]&#x3D;{if(p[j]≠′∗′)&#x3D;{f[i−1][j−1]，matchs(s[i],p[j])false，otherwiseotherwise&#x3D;{f[i−1][j]orf[i][j−2]，matchs(s[i],p[j−1])f[i][j−2]，otherwise</p><p>其中 matches(x,y)判断两个字符是否匹配的辅助函数。只有当 y是 . 或者 x和y本身相同时，这两个字符才会匹配。</p><p><strong>细节</strong></p><p>动态规划的边界条件为 f[0][0]&#x3D;true，即两个空字符串是可以匹配的。最终的答案即为 f[m][n]，其中 m 和 n 分别是字符串 s和 p的长度。由于大部分语言中，字符串的字符下标是从 0 开始的，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。</p><p>在上面的状态转移方程中，如果字符串 p中包含一个「字符 + 星号」的组合（例如 <code>a*</code> ），那么在进行状态转移时，会先将 a 进行匹配（当 p[j]为 a 时），再将<code>a*</code> 作为整体进行匹配（当 p[j]为 <code>*</code>时）。然而，在题目描述中，我们必须将 <code>a*</code> 看成一个整体，因此将 a 进行匹配是不符合题目要求的。看来我们进行了额外的状态转移，这样会对最终的答案产生影响吗？这个问题留给读者进行思考。这里我认为是不影响的，题目是解法的一个特例。</p>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2021/01/04/Reverse/"/>
    <url>/2021/01/04/Reverse/</url>
    
    <content type="html"><![CDATA[<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/04/Reverse/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/04/Reverse/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/">整数反转</a></p><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 123</span><br><span class="hljs-section">输出: 321</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: -123</span><br><span class="hljs-section">输出: -321</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 120</span><br><span class="hljs-section">输出: 21</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这一版性能不是很好，可以参考下。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">Reverse</span> &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> reverse(<span class="hljs-type">int</span> x) &#123;<br><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        StringBuilder s = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            String will = String.valueOf(x).substring(<span class="hljs-number">1</span>);<br>            s.append(<span class="hljs-string">&#x27;-&#x27;</span>);<br>            <span class="hljs-type">boolean</span> flag0 = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = will.length() - <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-keyword">if</span> (will.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; flag0) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                s.append(will.charAt(i));<br>                flag0 = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String will = String.valueOf(x);<br>            <span class="hljs-type">boolean</span> flag0 = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = will.length() - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i<span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-keyword">if</span> (will.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; flag0) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                s.append(will.charAt(i));<br>                flag0 = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (checkOutOfRange(s.toString())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Integer</span>.parseInt(s.toString());<br>    &#125;<br><br>    private static <span class="hljs-type">boolean</span> checkOutOfRange(String will) &#123;<br>        String max = String.valueOf(<span class="hljs-type">Integer</span>.MAX_VALUE);<br>        String min = String.valueOf(<span class="hljs-type">Integer</span>.MIN_VALUE);<br><br>        <span class="hljs-keyword">if</span> (will.equals(&quot;0&quot;)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(will.startsWith(&quot;-&quot;)) &#123;<br>            <span class="hljs-keyword">if</span> (will.equals(min)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (will.length() &gt; min.length()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (will.length() &lt; min.length()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; will.length(); i++) &#123;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &gt; (<span class="hljs-type">int</span>) min.charAt(i)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &lt; (<span class="hljs-type">int</span>) min.charAt(i)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (will.equals(max)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (will.length() &gt; max.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (will.length() &lt; max.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; will.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &gt; (<span class="hljs-type">int</span>) max.charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>) will.charAt(i) &lt; (<span class="hljs-type">int</span>) max.charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        <span class="hljs-type">int</span> test = <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">-123</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">120</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">1534236469</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">-2147483648</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br>        test = <span class="hljs-number">-2147483412</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(reverse(test));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">321<br><span class="hljs-deletion">-321</span><br>21<br>0<br>0<br><span class="hljs-deletion">-2143847412</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是类似暴力破解。</li></ul><p>比较优雅的一版如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> reverse1(<span class="hljs-keyword">int</span> x) &#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">pop</span> = x % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">// max == 2,147,483,647</span><br>            <span class="hljs-keyword">if</span> (ans &gt; Integer.MAX_VALUE <span class="hljs-regexp">/ 10 || (ans == Integer.MAX_VALUE /</span> <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-keyword">pop</span> &gt; <span class="hljs-number">7</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// min == 2,147,483,648</span><br>            <span class="hljs-keyword">if</span> (ans &lt; Integer.MIN_VALUE <span class="hljs-regexp">/ 10 || (ans == Integer.MIN_VALUE /</span> <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-keyword">pop</span> &lt; -<span class="hljs-number">8</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            ans = ans * <span class="hljs-number">10</span> + <span class="hljs-keyword">pop</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是拆解成取模算法，并且根据最大最小值做校验判断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——条分缕析分布式：因果一致性和相对论时空</title>
    <link href="/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%AE%BA%E6%97%B6%E7%A9%BA/"/>
    <url>/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%9B%A0%E6%9E%9C%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%AE%BA%E6%97%B6%E7%A9%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——条分缕析分布式：因果一致性和相对论时空"><a href="#分布式系统原理——条分缕析分布式：因果一致性和相对论时空" class="headerlink" title="分布式系统原理——条分缕析分布式：因果一致性和相对论时空"></a>分布式系统原理——条分缕析分布式：因果一致性和相对论时空</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://mp.weixin.qq.com/s/wkXsRufVsbKqTwjzTgNqYQ">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p><p>  在上一篇文章《<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：浅析强弱一致性</a>》中，我们重点讨论了顺序一致性、线性一致性和最终一致性这几个概念。本文我们将继续深入，详细探讨另一种一致性模型——因果一致性，并在这个过程中逐步逼近分布式系统最深层的事件排序的本质。沿着这个方向，如果我们走得稍微再远一点，就会触达我们所生活的这个宇宙的时空本质，以及因果律的本质（这才是真正有意思的地方，希望你能一口气读到最后）。</p><p>  回到现实，《Designing Data-Intensive Applications》[1]一书的作者在他的书中提到，基于因果一致性构建分布式数据库系统，是未来一个非常有前景的研究方向。而且，估计很少有人注意到，我们经常使用的ZooKeeper，其实就在session维度上提供了因果一致性的保证[2]。理解「因果一致性」的概念，有助于我们对于分布式系统的认识更进一层。</p><h3 id="为什么要考虑因果一致性？"><a href="#为什么要考虑因果一致性？" class="headerlink" title="为什么要考虑因果一致性？"></a>为什么要考虑因果一致性？</h3><p>  结合<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>的讨论，我们再把一致性模型的来历简单梳理一下。</p><p>  早期的分布式系统设计者，为了让使用系统的开发者能够以比较简单的方式来使用系统，希望分布式系统能提供单一系统视图 (SSI，<em>single-system image</em>)[3]，即系统“表现得就好像只有一个单一的副本”。线性一致性和顺序一致性就是沿着这个思路设计的。满足线性一致性或顺序一致性的系统，对读写操作的排序呈现全局唯一的一种次序。</p><p>  然而，系统为了维持这种全局排序的一致性是有成本的，必然需要在副本节点之间做很多通信和协调工作。这降低了系统的可用性（<em>availability</em>）和性能。于是，在一致性、可用性、系统性能之间进行权衡的结果，就是降低系统提供的一致性保障，转向了最终一致性[4]。</p><p>  不过最终一致性提供的一致性保障是如此之弱，它放弃了所有的<em>safety</em>属性（具体讨论见<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261790&idx=1&sn=08449ee5b39d93b25442c1e583e3ba99&scene=21#wechat_redirect">上一篇文章</a>）。这给系统的使用带来了额外的困难。面向最终一致性系统进行编程，需要随时关注数据不一致的情况。加州大学伯克利分校在2013年发表了一篇非常不错的文章[3]，对于如何在最终一致性系统上构建应用，进行了非常深入的研究。文章指出了两种思路：</p><ul><li>针对可能出现的数据不一致情况实施补偿措施 (<em>compensation</em>)。这需要在分布式系统之上的应用层面进行额外的处理，是非常容易出错且费时费力的。</li><li>基于CALM定理和CRDTs，完全消除补偿操作。但这样做其实限制了应用编程能够使用的操作类型，也就限制了系统能力。</li></ul><p>  以上两种思路都涉及到了大量细节，我们不打算在这里深入讨论，有兴趣的读者可以仔细去阅读论文[3]。</p><p>  总之，为了提高系统可用性和系统性能，人们放弃了强一致性，采取了几乎最弱的一类一致性模型（最终一致性），但也同时牺牲了系统的能力或系统使用的便利性。那么，到底有没有必要一定采取这么「弱」的一致性模型呢？有没有可能在最终一致性的基础上增加一点<em>safety</em>属性，提供稍强一点的一致性，但同时也不至于对系统可用性和性能产生明显的损害呢？</p><p>  基于最新的研究，这是有可能的。这个问题的答案就是本文接下来要讨论的因果一致性 (<em>causal consistency</em>)。</p><p>  德克萨斯大学奥斯汀分校在2011年的一项研究表明[5]：</p><ul><li>不存在比因果一致性更强的一致性模型，能够在网络分区的情况下仍然可用。</li><li>在一个永远保持可用且单程收敛 (<em>always-available, one-way convergent</em>) 的系统里，因果一致性是可以被实现出来的。</li></ul><h3 id="因果一致性的直观解释"><a href="#因果一致性的直观解释" class="headerlink" title="因果一致性的直观解释"></a>因果一致性的直观解释</h3><p>  因果律是这个世界最基础的规律，物理法则决定了我们总是先看到事物的「因」，后看到事物的「果」。对于一个分布式系统来说，在数字世界中保持这种因果关系，当然也是一个最基本的要求。</p><p>  为了能比较通俗地理解因果一致性，我们这里引用一个假想的实例（来自论文[6]）。假设Billy是一个小男孩，Sally是他的妈妈。下面的故事发生在一个类似Facebook的社交网站上：</p><ol><li>有一天，Billy失踪了。Sally找不到他的儿子，很着急，于是在社交网站上发布了一条状态：“我儿子Billy丢了！”</li><li>过了一会，Sally突然接到了儿子的电话。Billy告诉妈妈，他跑到朋友家玩去了。Sally长出一口气，又重新修改了刚才发布的状态：“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”</li><li>Sally的一个朋友，叫James，看到了她发的最新的状态，在社交网站上回复了她：“太好了，总算松了一口气！”</li></ol><p>  假如这家社交网站的数据库系统没能保证因果一致性，那么我们就可能看到比较奇怪的事件次序。假设Sally的另外一个朋友，叫Henry，也在浏览这个社交网站。可能由于系统延迟，数据还未收敛到一致的状态，Henry可能会看到Sally发的第一条状态和James的回复，但却看不到Sally发的第二条状态。于是，在Henry看来：</p><ol><li>Sally说：“我儿子Billy丢了！”</li><li>James回复：“太好了，总算松了一口气！”</li></ol><p>  Henry可能会错误地认为，James满心希望Sally的儿子丢了（James肯定是恨透了Sally）！</p><p>  之所以发生这样的问题，就是因为因果倒置了。考虑两个事件：事件A，Sally发布第二条状态（称自己的儿子找到了）；事件B，James回复Sally表示安慰。显然，事件B是由事件A引发的，也就是说，事件A是事件B的「因」，事件B是事件A的「果」。但在Henry看来，却只看到了事件B，没有看到事件A，这违反了因果规律。（当然，这个例子隐藏了很多具体实现细节，你可能会产生一些疑问，但不妨碍我们讨论事件的因果关系）</p><p>  这里需要注意，如果分布式系统是满足线性一致性或者顺序一致性的，那么是不会发生这样的问题的。因为线性一致性和顺序一致性是能够保持因果关系的（下一章节我们还会继续讨论这个问题）。而只是满足最终一致性的系统，是没法总是保持因果关系的。但是，如果一个系统满足因果一致性，那么我们可以放心地认为，事件的因果关系是能够得到保证的。</p><p>  现在，让我们来尝试对因果一致性进行定义。我们先采取一种不那么严格，但比较直观的说法（下个章节再进行精确定义）。因果一致性遵守下面三条规则：</p><ol><li>单进程写操作有序。</li><li>“writes follow reads”规则。</li><li>因果关系可传递。</li></ol><p>  我们来分别解释一下：</p><ol><li>单进程写操作有序，指的是一个进程的多个写操作（可能是针对不同的数据对象的），在所有进程看来都是遵循同样的执行顺序。对应到前面的例子中，Sally的所有朋友都会看到，Sally是先发了一条状态“我儿子Billy丢了！”，然后又发了第二条状态“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”这条规则保证了没有人是先看到第二条状态然后才看到第一条状态的。对于这个次序的保证也是因果性的一种体现。</li><li>“writes follow reads”指的是，假设第一个进程先读取到了数据对象<em>x&#x3D;5</em>，后写入了另一个数据对象<em>y&#x3D;10</em>，然后第二个进程读到了<em>y&#x3D;10</em>，那么接下来如果这个进程读取数据对象<em>x</em>的值，那么不能读到一个比<em>x&#x3D;5</em>更旧的值。这条规则在不同进程的不同数据对象之间建立了因果关联。对应到前面的例子中，James看到了Sally发的最新状态：“谢天谢地，虚惊一场！Billy原来是跑出去玩了。”（相当于读到了<em>x&#x3D;5</em>），然后回复说：“太好了，总算松了一口气！”（相当于写入了<em>y&#x3D;10</em>），再然后Henry看到了James的回复内容（相当于第二个进程读到了<em>y&#x3D;10</em>），这时候站在Henry的视角上看Sally发布的状态，他不能比James看到的数据版本更旧。前面的例子中出现的问题就在于，Henry比James看到了更旧的一个数据版本：“我儿子Billy丢了！”，致使因果关系混乱了。</li><li>因果关系是具有传递性的。如果操作A和操作B在因果关系上满足先后次序，而且操作B和操作C在因果关系上也满足先后次序，那么A和C在因果关系上必然是满足先后次序的。</li></ol><h3 id="因果一致性的精确定义"><a href="#因果一致性的精确定义" class="headerlink" title="因果一致性的精确定义"></a>因果一致性的精确定义</h3><p>  在前一章节我们讨论了因果一致性的直观解释，但我们还需要一个精确的定义。这样对于一个具体的包含读写操作的并发执行过程来说，我们才能知道如何判定它是否满足因果一致性。</p><p>  我们采用<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>的表示方法，还是先通过一个例子来看一个并发执行过程，如下图：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/5.webp" alt="图片"></p><p>  图中线段上面的符号表示具体的读写操作：</p><ul><li><em>A</em> —&gt; <em>w**i</em>(<em>x</em>)，表示一个写操作：第<em>i</em>个进程向数据对象<em>x</em>写入了值<em>A</em>。</li><li><em>r**i</em>(<em>x</em>) —&gt; <em>A</em>，表示一个读操作：第<em>i</em>个进程从数据对象<em>x</em>中读到了值<em>A</em>。</li></ul><p>  这个图表达了3个进程（<em>P</em>1、<em>P</em>2和<em>P</em>3）对于数据存储的读写执行过程。它是否满足因果一致性呢？</p><p>  跟线性一致性和顺序一致性的定义一样，因果一致性也是表达了系统对于读写操作的某种排序规则。为此我们首先需要定义清楚一个关键概念——<strong>因果顺序</strong> (causality order)，它表明了两个不同操作之间的排序是怎样规定的。</p><p>  <strong>因果顺序</strong>的定义：如果两个操作<em>o</em>1和<em>o</em>2满足下面三个条件之一，那么它们就是满足因果顺序的，记为<em>o</em>1→<em>o</em>2：</p><ul><li>(1) <em>o</em>1和<em>o</em>2属于同一个进程，且<em>o</em>1在<em>o</em>2前面执行。</li><li>(2) <em>o</em>1是个写操作，<em>o</em>2是个读操作，且<em>o</em>2读到的值是由<em>o</em>1写入的。</li><li>(3) 存在一个操作<em>o</em>‘满足<em>o</em>1→<em>o</em>‘→<em>o</em>2。</li></ul><p>  结合上图的例子，我们解释一下这三个条件：</p><ul><li>(1) 同一个进程内部先后执行的两个操作，不管他们是读操作还是写操作，都是满足因果顺序的。比如上图中<em>P</em>1进程的 <em>A</em> —&gt;<em>w**1</em>(<em>x</em>) 和 <em>B</em> —&gt; <em>w**1</em>(<em>x</em>) 两个操作就是满足因果顺序的；<em>P</em>2进程的<em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 和 <em>C</em> —&gt; <em>w**2</em>(<em>y</em>) 也是满足因果顺序的。这一条件表明，因果顺序遵从了进程的执行顺序。</li><li>(2) 如果一个读操作读到的值是由另一个写操作写入的（肯定是针对同一个数据对象），那么不管它们是不是属于同一个进程，这个写操作和读操作就是满足因果关系的。比如上图中的 <em>B</em> —&gt;<em>w**1</em>(<em>x</em>) 和 <em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 就是满足因果顺序的；<em>C</em> —&gt; <em>w**2</em>(<em>y</em>) 和 <em>r**3</em>(<em>y</em>) —&gt; <em>C</em> 也是满足因果顺序的。这个条件反映了读写操作之间的因果依赖关系。</li><li>(3) 这个条件表明因果顺序“→”满足传递关系 (<em>transitive relation</em>)。</li></ul><p>  从因果顺序的定义中，我们还能得到两个重要的结论：</p><ul><li>因果顺序是一种<strong>偏序关系</strong>。所谓偏序关系，就是说只有一部分操作是可以按照因果顺序进行比较的，而有一些操作之间是不能比较的。比如上图中的 <em>A</em> —&gt; <em>w**1</em>(<em>x</em>) 和 <em>D</em> —&gt; <em>w**3</em>(<em>x</em>) 这两个操作之间的关系，就不符合因果顺序三个条件中的任何一个。<em>r**2</em>(<em>x</em>) —&gt; <em>B</em> 和 <em>D</em> —&gt; <em>w**3</em>(<em>x</em>) 之间也同样如此，它们之间不存在因果顺序。这具有很深刻的物理学和哲学内涵，因为现实世界的事件之间的因果关系就是偏序的（先不展开讨论）。分布式系统里对于读写操作之间的这种因果顺序的定义，正是对现实世界中这种现象的一种刻画。</li><li>因果顺序不能有循环依赖。假如操作<em>o</em>1→<em>o</em>2→<em>o</em>‘→…→<em>o</em>1，由传递关系就应该有：<em>o</em>1→<em>o</em>1。这表示一个操作是它自己的「因」，这是荒谬的。换句话说，如果把因果顺序用一个图来表示，那么它应该是一个有向无环图 (<em>directed acyclic graph</em>)。</li></ul><p>  现在基于<strong>因果顺序</strong>的定义，我们可以给出<strong>因果一致性</strong>的定义了。</p><p>  <strong>因果一致性</strong>定义[7]：在一个并发执行过程中，站在其中任意一个进程<em>P**i</em>的视角上，考虑这个进程的所有读、写操作和所有其它进程的所有写操作（注意不包含读操作），得到一个操作序列。如果站在任意一个进程的视角上得到的这个操作序列都能够重排成一个线性有序的序列，并且该序列满足以下两个条件，那么这个并发执行过程就是满足因果一致性的：</p><ul><li><strong>条件I</strong>：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</li><li><strong>条件II</strong>：重排后的序列遵从前面定义的因果顺序“→”。</li></ul><p>  对比<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中的顺序一致性定义，因果一致性的定义有两个不同：</p><ol><li>顺序一致性是对所有进程的所有读写操作进行统一的重排，而因果一致性是站在每个进程的视角各自进行局部重排。这表示顺序一致性要求系统的所有进程都对操作排序达成一致的看法，而因果一致性允许每个进程对操作的排序有不同的看法。</li><li>因果一致性与顺序一致性的<strong>条件II</strong>不同。顺序一致性的<strong>条件II</strong>只是要求遵从进程的执行顺序，而因果一致性则有更强的要求——遵从<strong>因果顺序</strong>（而进程的执行顺序只是因果顺序的一部分）。</li></ol><p>  以前面图示的并发执行过程为例，我们先以<em>P</em>1的视角，需要考虑把<em>P</em>1的所有读写操作和<em>P</em>2、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p><ol><li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li></ol><p>  再以<em>P</em>2的视角，需要考虑把<em>P</em>2的所有读写操作和<em>P</em>1、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p><ol><li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**2</em>(<em>x</em>) —&gt; <em>B</em></li><li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li></ol><p>  最后以<em>P</em>3的视角，需要考虑把<em>P</em>3的所有读写操作和<em>P</em>1、<em>P</em>3的所有写操作进行重排，可以得到如下的有序序列：</p><ol><li><em>D</em> —&gt; <em>w**3</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>C</em> —&gt; <em>w**2</em>(<em>y</em>)</li><li><em>r**3</em>(<em>y</em>) —&gt; <em>C</em></li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  我们可以依次检查三个重排序列，会发现因果一致性的 <strong>条件I</strong>和<strong>条件II</strong>都是满足的（留给读者自己去检查，有疑问可以在评论区回复），所以前面图中的并发执行过程是满足因果一致性的。</p><p>  你可能会觉得因果一致性的定义有些复杂，那么它的设计初衷是什么呢？我们通过分析两个问题来做初步的解读：</p><ul><li>为什么因果一致性是站在各个进程的视角对部分操作进行排序，而不是对所有进程的操作进行全局排序？这是因为，因果顺序是一种偏序关系，这就允许站在不同进程的视角去观察各自所关心的部分操作，从而得到不同的观察结果（排序序列）且同时不违反因果律。假如因果顺序不是一种偏序，而是一种全局关系，那么就可以把所有操作按照同一个次序排序起来，那就变成跟顺序一致性一样了，每个进程也可以看到完全一样的排序序列了。所以说，这里隐含着一个结论：因果一致性是比顺序一致性更弱的一类一致性模型，而顺序一致性也意味着遵从了因果一致性。另外，也只有当站在不同进程的视角有不同的观察结果时，才可能在发生网络分区的时候，同时提供可用性。想象当一个节点同系统其它部分隔开了，这个节点不需要等待与其它节点联系，仍然可以使用旧版本的数据提供服务，同时不违反因果顺序即可。而如果像顺序一致性或者线性一致性那样，维持一个统一的全局排序，则需要在各个节点之间充分交换完数据才能达成一致。</li><li>为什么站在一个进程的视角要考虑所有其它进程的写操作呢？因为对于<strong>因果顺序</strong>来说，所有写操作都是潜在的「因」，而当前进程的读操作则代表了它的「看法」。进程的局部看法的形成，需要考虑所有的「因」，才能保证不违反因果律。</li></ul><p>  最后我们再来看一下，前一章节提到的因果一致性遵守的三条规则，是不是在因果一致性的定义中包含了：</p><ol><li>单进程写操作有序。因为每个进程进行局部重排的时候，都把所有进程的写操作考虑进去了，所以任何一个进程的多个写操作，在所有进程看来都是遵循同样的执行顺序。比如前面例子中<em>P</em>1的两个操作 <em>A</em> —&gt; <em>w**1</em>(<em>x</em>) 和 <em>B</em> —&gt; <em>w**1</em>(<em>x</em>)，在三次重排序列中都能保持次序。</li><li>“writes follow reads”规则。隐含在<strong>因果顺序</strong>的前两个条件里面。在前面例子中，进程<em>P</em>2先是读取到了<em>x&#x3D;B</em>，后写入了<em>y&#x3D;C</em>，然后进程<em>P</em>3先是读到了<em>y&#x3D;C</em>，接下来进程<em>P</em>3读取<em>x</em>的值，不能读到一个比<em>x&#x3D;B</em>更旧的值（满足）。</li><li>因果关系可传递。隐含在<strong>因果顺序</strong>的第三个条件里。</li></ol><p>  作为对比，下图是一个违反了“writes follow reads”的例子（因此不满足因果一致性）：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/6.webp" alt="图片"></p><h3 id="分布式系统事件排序"><a href="#分布式系统事件排序" class="headerlink" title="分布式系统事件排序"></a>分布式系统事件排序</h3><p>  因果一致性的概念[7]，是受到Lamport的经典论文[8]的启发而设计出来的。Lamport在1978年发表的经典论文《Time, Clocks, and the Ordering of Events in a Distributed System》，经常被认为是分布式领域中最重要的一篇论文。这篇论文定义了分布式系统中不同事件之间的一种偏序关系，称为“happened before”关系，即是对因果关系的一种刻画。</p><p>  Lamport定义了一种由不同进程组成的分布式系统模型，进程之间通过收发消息来传递信息。如下图：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/7.webp" alt="图片"></p><p>  在上图中，我们尝试对消息发送事件和消息接收事件进行排序（注意图中自下而上时间递增）。“happened before”关系也是用符号“→”来表示。</p><ul><li>在进程<em>Q</em>内部，<em>q</em>2表示一个消息接收事件，<em>q</em>4表示另一个消息发送事件，<em>q</em>2排在<em>q</em>4前面执行，所以<em>q</em>2→<em>q</em>4。</li><li><em>p</em>1和<em>q</em>2分别表示同一个消息的发送事件和接收事件，所以<em>p</em>1→<em>q</em>2；同理，<em>q</em>4→<em>r</em>3。</li><li>“happened before”满足传递关系。由<em>p</em>1→<em>q</em>2，<em>q</em>2→<em>q</em>4和<em>q</em>4→<em>r</em>3，可以推出<em>p</em>1→<em>r</em>3。</li></ul><p>  以上三种情况，与我们前面讨论的因果顺序定义中的三个条件，基本一一对应。因果一致性的概念应用在分布式存储系统上，相当于将“happened before”关系应用在了读写操作之上。</p><p>  可以看出，这里的“happened before”关系，也是一种偏序关系。比如<em>p</em>1和<em>q</em>1两个事件就是无法比较的，<em>q</em>4和<em>r</em>2也是无法比较的。无法比较的两个事件之间不满足“happened before”关系。</p><h3 id="因果一致性的难以理解之处"><a href="#因果一致性的难以理解之处" class="headerlink" title="因果一致性的难以理解之处"></a>因果一致性的难以理解之处</h3><p>  经过以上的讨论，相信你已经对因果一致性有了初步的理解了。现在我们来看一个稍显奇怪的例子（下图的例子出自论文[7]）。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/8.webp" alt="图片"></p><p>  上图表达了两个进程的并发执行过程。它是满足因果一致性的，因为站在进程<em>P</em>1和<em>P</em>2的视角，都能得到一个局部合理的排序（满足因果顺序）。</p><p>  站在<em>P</em>1视角，有：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>r**1</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  站在<em>P</em>2视角，有：</p><ol><li><em>B</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**2</em>(<em>x</em>) —&gt; <em>A</em></li></ol><p>  以上这些分析完全符合因果一致性的定义。但是，仔细看这个例子，如果接下来没有任何进程对数据对象<em>x</em>进行写操作了，那么<em>P</em>1永远读到的是<em>x&#x3D;B</em>，而<em>P</em>2永远读到的是<em>x&#x3D;A</em>。这似乎有些不可思议。</p><p>  发生这个现象的原因在于，进程<em>P</em>1和<em>P</em>2对于两个写操作的排序，「看法」不一致：</p><ul><li>在<em>P</em>1看来，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)发生在<em>B</em> —&gt; <em>w**2</em>(<em>x</em>)前面。</li><li>在<em>P</em>2看来，<em>B</em> —&gt; <em>w**2</em>(<em>x</em>)发生在<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)前面。</li></ul><p>  这就如同相对论难以理解一样：不同参照系的观察者对于不同事件的先后顺序，可能产生不同的看法。实际上，分别站在进程<em>P</em>1和<em>P</em>2的视角上，它们看到的都没有什么矛盾。矛盾发生在我们站在全局视角去看的时候。</p><p>  假设躲在进程<em>P</em>1和<em>P</em>2背后的两个用户，通过系统外的通信方式进行了交流，那么他们就会发现这个奇怪之处：他们竟然对于同一个数据对象<em>x</em>读到的值不同！但是站在因果一致性的分布式系统内部来看的话，不应该发生这种情况，因为进程之间的沟通，都应该在系统内发生。所谓发生在系统内的进程之间的沟通，必定是通过进程对于数据对象的读写操作进行的。如果进程<em>P</em>1或<em>P</em>2对数据对象<em>x</em>进行了写操作，那么它们就有机会对数据对象<em>x</em>的值达成同样的看法；或者很不走运，永远也达不成同样的看法，但它们如果不借助系统外的手段永远也发现不了这种不同（还是不违反因果律）。</p><p>  顺便提一句，如果要保证在系统外发生的因果联系也能在系统内永远被遵守，那么就要借助于Lamport在他的论文中提到的***Strong Clock Condition***了。</p><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>  我们前面提到，因果一致性对于分布式系统读写操作事件的排序，是对现实世界的事件之间因果关系的一种刻画。理解的难点在于，在我们所生活的这个宇宙中，事件之间的时间次序，只是一种偏序关系；对应的，事件之间的因果关系，也是一种偏序。</p><p>  在牛顿的绝对时空观中，时间是以某个固定速率向前流逝的绝对量，而不管我们站在哪个参照系的视角上。由此带来的推论是，宇宙中发生的任何一个事件，都可以根据它们发生的绝对时间点进行先后排序。也就是说，在绝对时空中的事件之间的排序是一种全序关系，任何两个事件都能比较先后。发生在前面的事件就有可能影响后面的事件，从而产生因果关系。试想一下，就在你读到这里的几秒之前，三体星系上发生了某个重大事件，按照绝对时空观的观点，它也可能对现在的你产生了影响。你大概会同意，这是不可能的，因为三体星系即使以最快的速度向地球传递信息，也要在4年之后才能到达。</p><p>  而在爱因斯坦的相对论中，这个问题就得到了解决。时间不再是一个绝对的量。不同参照系看到的时间流速可以快慢不同，甚至对两个事件的先后次序可以看法不同。但是，对于可能互相产生影响的事件，它们之间的先后次序，不管在什么参照系上看到的都应该是相同的，否则就违反了因果律。实际上，在相对论的时空中，结论是这样的：</p><ul><li>一个事件，和在它的「未来光锥」之内的任何其它事件，都是有偏序关系的。它们之间的先后次序，不管在什么参照系上看到的都应该是相同的。</li><li>一个事件，和在它的「未来光锥」之外的其它事件，是没有偏序关系的（也就不可能产生因果关系）。站在不同参照系上看这样的两个事件，它们的先后次序可能不同。</li></ul><p>  回到我们的分布式系统。一个分布式系统自成宇宙，它是对现实世界的一种刻画。分布式系统由不同的进程组成，而不同的进程分布在不同的空间，每个进程可以看成一个单独的参照系。因果一致性，本质上就是按照我们对于相对论宇宙的认识来进行系统建模的，这也是它的合理性的根基。然而，分布式系统毕竟只是一个模拟系统，它是服务于系统外的现实世界的。而在现实世界中，我们还可以有额外的传递信息的方式，这相当于在分布式系统自成体系的这个「宇宙」之外，可能存在更快的传递信息的维度。所以说，分布式系统只依靠自己的逻辑，是无法与现实世界完全达成一致的。而要做到对现实的完美刻画，就一定需要考虑现实世界的实时时钟（可以从Lamport的***Strong Clock Condition***入手）。</p><p>  到这里，我们已经触达到分布式系统（也包括这个宇宙时空）最深层的本质问题了。相信在这样的逻辑框架下，任何分布式系统的相关问题，都能很容易找到它在整个体系中的逻辑位置。至此，我们也完成了分布式一致性这个话题的「三部曲」了。其它两篇参见：</p><ul><li>《<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：到底什么是一致性？</a>》</li><li>《<a href="https://yangtzeshore.github.io/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-101-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：浅析强弱一致性</a>》</li></ul><p>  当然，分布式相关的话题还远没有结束，还有更多有意思的问题等着我们去探究。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li>[1] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li><li>[2] Martin Kleppmann, “Please Stop Calling Databases CP or AP”, 2015.</li><li>[3] Peter Bailis, Ali Ghodsi, “Eventual Consistency Today: Limitations, Extensions, and Beyond”, 2013.</li><li>[4] Werner Vogels, “Eventually Consistent”, 2008.</li><li>[5] Prince Mahajan, Lorenzo Alvisi, Mike Dahlin, “Consistency, Availability, and Convergence”, 2011.</li><li>[6] Peter Bailis, Ali Ghodsi, et al, “Bolt-on Causal Consistency”, 2013.</li><li>[7] Mustaque Ahamad, Gil Neiger, James E. Burns, et al, “Causal Memory: Definitions, Implementation and Programming”, 1994.</li><li>[8] Leslie Lamport, “Time, Clocks, and the Ordering of Events in a Distributed System”, 1978.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——条分缕析分布式：浅析强弱一致性</title>
    <link href="/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2021/01/03/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E6%B5%85%E6%9E%90%E5%BC%BA%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——条分缕析分布式：浅析强弱一致性"><a href="#分布式系统原理——条分缕析分布式：浅析强弱一致性" class="headerlink" title="分布式系统原理——条分缕析分布式：浅析强弱一致性"></a>分布式系统原理——条分缕析分布式：浅析强弱一致性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261790&idx=1&sn=08449ee5b39d93b25442c1e583e3ba99&scene=21#wechat_redirect">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p><p>  当前这篇文章至少比计划拖后了两个月。在上一篇文章《<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">条分缕析分布式：到底什么是一致性？</a>》中，我们仔细辨析了「一致性」相关的几个容易混淆的概念。而在本文中，我们会沿着逐步深入的思路，跟大家继续讨论顺序一致性、线性一致性、最终一致性等几个概念。</p><p>为了避免产生歧义，我们先明确一下这几个概念的英文表达：</p><ul><li>顺序一致性的英文是：<em>sequential consistency</em>。</li><li>线性一致性的英文是：<em>linearizability</em>。实际上，它就是CAP定理中的C，我们在<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中已经提到过。</li><li>最终一致性的英文是：<em>eventual consistency</em>。</li></ul><p>  在进行详细的技术性讨论之前，我们先把本文要讨论的几个重点问题和结论列出如下：</p><ul><li>线性一致性和顺序一致性，属于分布式系统的一致性模型 (<em>consistency model</em>)。这代表了分布式系统的一个非常非常重要的方面。</li><li>通常人们把线性一致性称为「强一致性」，把最终一致性称为「弱一致性」，但线性一致性和最终一致性其实存在本质的区别。严格来说，它们并不是一个范畴的概念。</li><li>一致性模型之间的「强弱」比较，是一个相对的概念。比如，线性一致性是比顺序一致性更强的一致性模型。当然，除了线性一致性和顺序一致性，也存在其它一些一致性模型（其中很多都比顺序一致性要弱）。</li><li>满足线性一致性的系统，也必定满足顺序一致性，但反过来不一定。这是由一致性模型之间的强弱关系决定的。</li></ul><p>  下面，我们就开始详细的解析。</p><h3 id="一致性模型的来历"><a href="#一致性模型的来历" class="headerlink" title="一致性模型的来历"></a>一致性模型的来历</h3><p>  我们之所以使用分布式系统，无非是因为分布式系统能带来一些「好处」，比如容错性、可扩展性等等。为了获得这些「好处」，分布式系统实现上常用的方法是复制 (<em>replication</em>) 和分片 (<em>sharding</em>)。而我们将要讨论的一致性模型 (<em>consistency model</em>)，主要是与复制有关。因此这里我们先关注一下复制的机制。</p><p>  复制指的是将同一份数据保存在多个网络节点上。而保存同一份数据拷贝的节点，被称为副本 (replica)。复制带来的具体「好处」主要是体现在两个方面：</p><ul><li>容错 (<em>fault tolerance</em>)。即使某些网络节点发生故障，由于原本保存着在故障节点上的数据在正常节点上还有备份，所以整个系统仍然可能是可用的。这也是我们期待分布式系统能够提供的「高可用」特性。</li><li>提升吞吐量。将一份数据复制多份并保存在多个副本节点上，还顺便带来一个好处：对于同一个数据对象的访问请求（至少是读请求）可以由多个副本节点分担，从而使得整个系统可以随着请求量的增加不断扩展。</li></ul><p>  一方面，复制带来了诸多好处；另一方面，它也带来了很多挑战，其中最重要的一个就是数据的一致性问题。由于同一份数据保存在了多个副本节点上，它们之间就存在数据不一致的风险。我们当然希望同一份数据的不同副本总是保持一致。换句话说，我们希望在其中一个副本上所做的修改，在其它副本上也能随时观察到（即读取到）。</p><p>  当然我们心里都清楚，让所有副本在任何时刻都保持一致，是不可能的。因为副本之间的数据同步即使速度再快，也是需要时间的。不过幸运的是，我们其实并不关心所有时刻的数据一致性情况。只要系统能够保证，每当我们去「观察」的时候（即读取数据副本的时候），系统表现出来的行为是一致的，就可以了。换句话说，即使在两次「观察」之间，系统内部出现了短暂的数据不一致的情况，只要系统保证外部用户无论如何都发现不了，我们也是可以满意的。</p><p>  这意味着，我们应该从系统用户（使用系统的开发者）的角度，来对数据一致性的要求进行定义。</p><p>实际上，早期的分布式系统设计者们对系统设计的要求，也是按照类似的思路进行的。在理想情况下，系统应该维持类似SSI (<em>single-system image</em>)[1]或<em>distribution transparency</em>[2]的特性。这两个概念要表达的核心意思是，系统内部有关分布式实现的复杂性应该对系统的外部用户透明；也就是说，对于系统的外部用户来说，系统应该表现得就好像只有一个单一的副本一样。如果系统能够提供这种「单一系统视图」或「透明性」，那么系统的使用者就能以比较简单的方式来使用系统；否则就可能带来很大的负担。</p><p>  系统“表现得就好像只有一个单一的副本”，这是一个相当「笼统」的说法。在此我们讨论3个具体的例子：</p><ol><li>我们先向一个副本节点写入<em>x</em>&#x3D;42，然后读取数据对象<em>x</em>的值。显然，不管我们从哪个副本节点上进行读取，我们都希望读到最新写入的值（也就是42）。只有这样才合理。</li><li>两个系统用户分别在两个副本节点上同时执行写操作。其中，用户A在第1个副本上执行<em>x</em>&#x3D;42；用户B在第2个副本上执行<em>x</em>&#x3D;43。然后用户C读取<em>x</em>的值。虽然两个写操作是「同时」进行的，但为了让系统“表现得像只有一个副本”，我们还是需要对它们进行一个先后排序。又因为它们是「同时」执行的，所以谁先谁后都有可能是合理的。如果我们认为<em>x</em>&#x3D;42在<em>x</em>&#x3D;43之前先执行，那么读取到的<em>x</em>的值就应该是43；反过来，如果我们认为<em>x</em>&#x3D;43在x&#x3D;42之前先执行，那么读取到的<em>x</em>的值就应该是42。</li><li>用户A先在第1个副本上执行<em>x</em>&#x3D;42，然后用户B再在第2个副本上执行<em>x</em>&#x3D;43，最后用户C在第3个副本上读取<em>x</em>的值。仍然为了让系统“表现得像只有一个副本”，直觉上看，用户C读取到的<em>x</em>的值似乎应该是43。但是，也不一定非要如此。因为两个写操作是分别由用户A和用户B发起的，他们并不知道彼此谁先谁后（虽然从时间上看用户A的写操作确实在先）。所以，我们也可以选择认为用户B执行<em>x</em>&#x3D;43在用户A执行<em>x</em>&#x3D;42之前。这样的话，用户C读取到的<em>x</em>的值就应该是42。当然，根据本文后面的讨论，这种排序就不满足线性一致性了，但却满足顺序一致性。</li></ol><p>  从这些例子不难看出，一个系统在数据一致性上的具体表现如何，取决于系统对关键事件（读写操作）的排序和执行采取什么样的规则和限制。比如在上面第3个例子中，出现了两种对于读写操作的排序。前一种排序是：</p><ol><li>用户A执行<em>x</em>&#x3D;42。</li><li>用户B执行<em>x</em>&#x3D;43。</li><li>用户C读取到<em>x</em>的值是43。</li></ol><p>而第3个例子中的后一种排序是：</p><ol><li>用户B执行<em>x</em>&#x3D;43。</li><li>用户A执行<em>x</em>&#x3D;42。</li><li>用户C读取到<em>x</em>的值是42。</li></ol><p>  虽然这两种排序结果不同，但它们都做到了让系统“表现得像只有一个副本”。它们的不同在于，前一种排序遵循了不同用户的操作的时间先后顺序，而后一种排序没有。实际上，如果我们要求系统满足线性一致性，就只能得到前一种排序结果；而如果只要求系统满足顺序一致性，就有可能得到后一种排序结果（等看完本文后面的讨论，你就能自己得到这些结论）。</p><p>  可以这么说，一个分布式系统对于读写操作的某种排序和执行规则，就定义了一种一致性模型 (<em>consistency model</em>)。当一个系统选定了某种特定的一致性模型（比如线性一致性或顺序一致性），那么你就只能看到这种一致性模型所允许的那些操作序列。还是拿前面第3个例子来说明：如果你选定了线性一致性模型，那么系统就不会向你呈现后一种排序，你只能看到前一种排序。</p><p>  另外，在前面的三个例子中，不管系统最终给出了哪种排序结果，所有系统的用户其实都对那种操作序列达成了一致的看法。还有一些一致性模型，并不要求所有用户对操作排序的结果达成唯一的一种看法。这样的一致性模型稍显复杂，我们会放在下一篇文章中再讨论（比如因果一致性）。</p><p>  接下来，为了更清晰地认识一致性模型，我们来深入到线性一致性和顺序一致性的一些细节中去。</p><h3 id="线性一致性和顺序一致性"><a href="#线性一致性和顺序一致性" class="headerlink" title="线性一致性和顺序一致性"></a>线性一致性和顺序一致性</h3><p>  在讨论之前，我们先把组成分布式系统的一些关键概念定义清楚：</p><ul><li>整个系统可以看成由多个<strong>进程</strong>和一个共享的<strong>数据存储</strong>组成。对于数据存储的读写操作由进程发起。这里的进程，相当于本文前面提到的系统用户或系统使用者。</li><li>同一个进程发起的读写操作是先后顺序执行的。注意，这里的「进程」概念跟我们平常编程时用到的进程有所不同，进程里面不再分多个线程了。</li><li>数据存储可能有多个副本，但我们在讨论一致性模型的时候，把它看成一个整体来看待，不区分读写操作提交到了具体哪个副本上。</li><li>每个操作的执行，从开始调用到执行结束，都需要花一定的时间。因此，一个进程发起的操作还没有执行完的时候，另一个进程的操作可能就已经开始了。</li></ul><p>  可见，系统的多个进程是并发执行的。下面我们通过一个例子来说明这种并发执行的情况，进而解释顺序一致性的概念。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/1.webp" alt="图片"></p><p>  上面是一个类似「时空图」的图像，表达了3个进程（<em>P</em>1、<em>P</em>2和<em>P</em>3）对于数据存储的读写执行过程。在这个图中，横向从左到右表示时间递增，黑色的线段表示每个操作的执行起止。线段上面的符号表示具体的读写操作：</p><ul><li><em>A</em> —&gt; <em>w**i</em>(<em>x</em>)，表示一个写操作：第<em>i</em>个进程向数据对象<em>x</em>写入了值<em>A</em>。</li><li><em>r**i</em>(<em>x</em>) —&gt; <em>A</em>，表示一个读操作：第<em>i</em>个进程从数据对象<em>x</em>中读到了值<em>A</em>。</li></ul><p>  现在我们要考察的问题是：上图的这样一个执行过程，是否满足顺序一致性？要回答这个问题，我们首先得知道顺序一致性的定义是什么。</p><p>  <strong>顺序一致性</strong>定义[3,4]：如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：</p><ul><li><strong>条件I</strong>：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。</li><li><strong>条件II</strong>：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。</li></ul><p>  以上图的执行过程为例，我们重排所有的6个读写操作，可以得到如下的有序序列：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li><li><em>C</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  很容易看出，这个序列是满足前面顺序一致性定义中的两个条件的：</p><ul><li>条件I：在这个重排后的序列中，每个读操作都返回了前面最近一次写入的值，比如第2个操作读到的值<em>A</em>，是前面第1个操作写入的；第4个操作读到的值<em>C</em>，是前面第3个操作写入的。</li><li>条件II：原来进程<em>P</em>1中的两个写操作，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)和<em>B</em> —&gt;<em>w**1</em>(<em>x</em>)，在这个重排后的序列中仍然保持了先后顺序。与此类似，原来进程<em>P</em>3中的3个读操作，在这个重排后的序列中也保持了原来的先后顺序。</li></ul><p>  所以现在我们可以回答前面的问题了：上图中的执行过程，是满足顺序一致性的。</p><p>  你可能会问，顺序一致性为什么会这样定义呢？这个定义的初衷是什么？</p><p>  我们可以试着这样理解：首先，重排成一个全局线性有序的序列，相当于系统对外表现出了一种「假象」，原本多进程并发执行的操作，好像是顺序执行的一样。本文前面提到过，理想情况下，分布式系统应该“表现得像只有一个副本”一样。顺序一致性正是遵循了这种「系统假象」，系统对外表现就好像在操作一个单一的副本，执行顺序也必然是可以看做顺序执行的。而条件I规定了系统的表现是合理的（即合乎逻辑的）；条件II则保证了以任何进程的视角来看，它所发起的操作执行顺序都是符合它原本的预期的。总之，一个满足顺序一致性的系统，对外表现就好像总是在操作一个副本一样。</p><p>  我们再通过一个例子来看一看这个问题的反面——不满足顺序一致性的执行过程是怎样的。</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/2.webp" alt="图片"></p><p>  这个图中的执行过程，与前面第一个图的执行过程非常相似，只是进程<em>P</em>3的几个操作的执行顺序稍有变化。</p><p>  我们根据前面顺序一致性的定义再来试着对这个执行过程中的所有操作进行重排：首先根据条件II和进程<em>P</em>1的执行顺序，我们知道，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)一定要排在<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)前面；再根据条件I，进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)一定要排在进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>B</em>前面。最后，再结合条件II和进程<em>P</em>3的执行顺序，我们能够得出结论，进程<em>P</em>1和进程<em>P</em>3的所有操作，在最终重排后的完整序列中，必然保持以下的顺序：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li><li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li><li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li></ol><p>  我们会发现，上面的序列有两个地方不满足条件I：</p><ul><li>第4个操作读到了值<em>C</em>，而前面最近一次写操作（第2个操作）所写入的值是<em>B</em>。</li><li>第5个操作读到了值<em>A</em>，而前面最近一次写操作（也是第2个操作）所写入的值是<em>B</em>。</li></ul><p>  我们还剩一个进程<em>P</em>2的写操作，即<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，没有放到最后这个序列中。也许我们可以试着将它放置到第3和第4个操作之间，这样就能把前面第一个不满足条件I的地方修复掉。但无论如何，也无法得到一个完全符合条件I和条件II的完整序列了。因此，前面第二个图中的执行过程，是不满足顺序一致性的。进一步说，如果一个系统的执行呈现出了这样的一种执行过程（如前面第二个图所示），那我们可以肯定地说，这个系统是没有遵守顺序一致性的。</p><p>  我们再来考察一下线性一致性的概念。线性一致性的定义[5]，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件I和条件II之外，还要同时满足一个条件：</p><ul><li><strong>条件III</strong>：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。</li></ul><p>  根据最新定义的条件III，我们来重新评判一下前面第一个图所展现出来的执行过程是不是满足它。为了阅读和讨论方便，我们把第一个图重新展示在下面：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/3.webp" alt="图片"></p><p>  针对条件III，我们分析一下各个操作之间的先后顺序：</p><ul><li>进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>2的<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，在执行时间上是重叠的，所以它们的排序不受条件III的约束。即，在重排后的序列中，这两个操作谁先谁后都可以。同样，进程<em>P</em>1的<em>B</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>A</em>，也是如此。</li><li>进程<em>P</em>1的<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)和进程<em>P</em>2的<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)，在执行时间上是不重叠的，即前一个操作都执行完了，后一个操作才开始执行。那么，这两个操作就必须满足条件III了：在重排后的序列中，<em>A</em> —&gt; <em>w**1</em>(<em>x</em>)必须排在<em>C</em> —&gt; <em>w**2</em>(<em>x</em>)前面。</li><li>与上面同样的道理，在重排后的序列中，进程<em>P</em>2的<em>C</em> —&gt;<em>w**2</em>(<em>x</em>)必须排在进程<em>P</em>3的<em>r**3</em>(<em>x</em>) —&gt; <em>A</em>之前。</li></ul><p>  容易看出，在遵守这样的先后关系约束的前提下，不管怎么重排，都无法得到一个满足条件I的完整序列了。所以说，前面第一个图所示的满足顺序一致性的执行过程，是不满足线性一致性的。</p><p>  下面我们举一个满足线性一致性的例子：</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/4.webp" alt="图片"></p><p>  上图的执行过程，所有操作重排后，可以得到如下的有序序列：</p><ol><li><em>A</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>A</em></li><li><em>C</em> —&gt; <em>w**2</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>C</em></li><li><em>B</em> —&gt; <em>w**1</em>(<em>x</em>)</li><li><em>r**3</em>(<em>x</em>) —&gt; <em>B</em></li></ol><p>  不难看出，这个序列是满足所有的条件I、条件II和条件III这三个条件的。因此，这个执行过程满足线性一致性。</p><p>  细心的你可能已经发现了，最后这个线性一致性的例子，得到的重排后的序列，与开始第一个顺序一致性的例子重排后的序列，完全相同。当然，这两个例子中原始的多进程并发执行过程，是不同的。这是符合预期的（没有什么可奇怪的）。</p><p>  现在我们可以仔细分析一下条件II和条件III，它们囊括了任意两个操作之间所有可能的先后关系：</p><ul><li>进程内的任意两个操作之间，总是先后顺序执行的（执行时间上不可能重叠）；而根据条件II，它们的先后顺序在最后重排后的序列中也会保持。</li><li>不同进程的不同操作之间，在执行时间上可能重叠（并发执行），也可能不重叠。根据条件III，不重叠的两个操作，它们在时间上的先后顺序，在最后重排后的序列中会得以保持。而对于执行时间上重叠的两个操作，它们在最后重排后的序列中的先后顺序没有规定。</li></ul><p>  最后，我们比较一下顺序一致性和线性一致性：</p><ul><li>它们都试图让系统“表现得像只有一个副本”一样。</li><li>它们都保证了程序执行顺序不会被打乱。体现在条件II对于进程内各个操作的排序保持上。</li><li>线性一致性考虑了时间先后顺序，而顺序一致性没有。</li><li>满足线性一致性的执行过程，肯定都满足顺序一致性；反之不一定。</li></ul><p>  注意一下上面第3点两者在时间先后顺序上的不同。这意味着：</p><ul><li>线性一致性隐含了时效性保证（recency guarantee）。它保证我们总是能读到数据最新的值。</li><li>在顺序一致性中，我们有可能读到旧版本的数据。比如，在本文第一个顺序一致性的例子中，在进程<em>P</em>2将数据对象<em>x</em>的值写成了<em>C</em>之后，进程<em>P</em>3仍然读到了旧的值（<em>A</em>）。</li></ul><h3 id="最终一致性和它的特殊性"><a href="#最终一致性和它的特殊性" class="headerlink" title="最终一致性和它的特殊性"></a>最终一致性和它的特殊性</h3><p>  我们在<a href="https://yangtzeshore.github.io/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-100-%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7/">上一篇文章</a>中提到过，CAP定理[6]中的C，指的就是线性一致性 (<em>linearizability</em>)。它也经常被称为「强一致性」。</p><p>  根据CAP定理，当存在网络分区的时候，我们必须在可用性 (<em>availability</em>) 和强一致性之间进行取舍。</p><p>  另外，即使在没有网络分区存在的情况下，我们也必须在延迟 (<em>latency</em>) 和强一致性之间进行取舍[7]。这是因为，系统维持强一致性是有成本的。想要维持越强的一致性，就需要在副本节点之间做更多的通信和协调工作，因此会降低操作的总延迟，进而降低整个系统的性能。</p><p>  从20世纪90年代中期开始，互联网开始蓬勃发展，系统的规模也变得越来越大。人们设计大型分布式系统的指导思想，也逐步开始更倾向于系统的高可用性和高性能。取舍的结果就是，降低系统提供的一致性保障。这其中非常重要的一条思路就是最终一致性[2]。</p><p>  最终一致性的设计思路，不再试图提供单一系统视图 (SSI)，即不再试图让系统“表现得像只有一个副本”一样。它允许读到旧版本的数据。最终一致性的原始出处是论文[2]，作者在论文中给出的最终一致性的定义如下：</p><blockquote><p>Eventual consistency. This is a specific form of weak consistency; the storage system guarantees that if no new updates are made to the object, eventually all accesses will return the last updated value.(译文：最终一致性是弱一致性的一种特殊形式；存储系统保证，如果对象没有新的修改操作，那么所有的访问最终都会返回最新写入的值。)</p></blockquote><p>  我们发现，虽然最终一致性和本文前面讨论的线性一致性或顺序一致性在命名上非常相似，但它的定义却与后两者存在非常大的差别。深层的原因在于，它们其实属于不同类别的系统属性 (<em>property</em>)。线性一致性和顺序一致性属于<em>safety property</em>（安全性）；而最终一致性属于<em>liveness property</em>（活性）[8]。</p><p>  一个并发程序或者一个分布式系统，它们的执行所展现出来的系统属性，可以分为两大类：</p><ul><li>***safety**<em>：它表示「坏事」永远不会发生。比如，一个系统如果遵守线性一致性或顺序一致性，那么就永远不会出现违反三个（对于顺序一致性来说是两个）条件的执行过程。而一旦系统出现问题，</em>safety*被违反了，我们也能明确指出是在哪个时间点上出现意外的。</li><li>**<em>liveness**<em>：它表示「好事」最终会发生。这种属性听起来会比较神奇：在任何一个时间点，你都无法判定</em>liveness*被违反了。因为，即使你期望的「好事」还没有发生，也不代表它未来不会发生。就像最终一致性一样，即使当前系统处于不一致的状态，也不代表未来系统就不会达到一致的状态。而只要系统存在“在未来某个时刻达到一致状态”的可能性，最终一致性就没有被违反。另外，可用性 (<em>availability</em>) 也属于</em>liveness*属性。</li></ul><p>  由此可见，我们在前一小节之所以能够将线性一致性和顺序一致性放在一起讨论和比较，是因为它们都属于<em>safety</em>属性。而最终一致性属于<em>liveness</em>属性，跟这两者存在本质的区别。实际上，最终一致性有点名不副实，它更好的名字可能是收敛性 (<em>convergence</em>)，表示所有副本最终都会收敛到相同的值[9]。</p><p>  通常来说，只有当<em>safety</em>和<em>liveness</em>这两种属性被同时考虑时，一个系统才能提供有意义的系统保证[1]。而当系统设计者遵循最终一致性的设计思路时，相当于放弃了所有的<em>safety</em>属性。这意味着，对于系统使用者来说，你必须针对数据不一致的可能性做好补偿措施 (<em>compensation</em>)。这也是最终一致性系统难用的地方。但不管怎么说，最终一致性仍然被认为是系统提供数据一致性的最低要求[1]。</p><h3 id="一致性的强弱关系"><a href="#一致性的强弱关系" class="headerlink" title="一致性的强弱关系"></a>一致性的强弱关系</h3><p>  在本文开头，我们提到过，通常人们把线性一致性称为「强一致性」，把最终一致性称为「弱一致性」。但对于指代特定的一种一致性模型来说，「强一致性」和「弱一致性」都不是一个好名字。因为强和弱，是个相对的概念。</p><p>  根据本文前面的讨论，从线性一致性，到顺序一致性，再到最终一致性，一致性的强度依次减弱。但是，一致性模型的强弱关系，其实是有更严格的定义的：</p><ul><li>当且仅当一个一致性模型所能接受的执行过程，都能被另一个一致性模型所接受时（前者的集合是后者集合的子集），我们就说前者是比后者「更强」(stronger) 的一致性模型。</li></ul><p>  按照这个更严格的强弱关系定义，线性一致性是比顺序一致性更强的一致性模型。这是因为，线性一致性比顺序一致性多了一个条件III，所以凡是满足线性一致性的执行过程，肯定也满足顺序一致性。</p><p>  我们仔细分析一下也能知道，一致性模型的强弱关系定义，是基于<em>safety</em>属性定义的。所以，将线性一致性或顺序一致性与最终一致性比较强弱，这并不是一个严格的做法。实际上，就像我们前一小节所讨论的，最终一致性在<em>safety</em>方面提供的保证为零，它是属于<em>liveness</em>的概念。一个系统可以在提供最终一致性的同时，也提供另外一种更强一点的带有<em>safety</em>属性的一致性（比如因果一致性）。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  就如同我在之前另外一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261626&idx=1&sn=6b32cc7a7a62bee303a8d1c4952d9031&scene=21#wechat_redirect">漫谈分布式系统、拜占庭将军问题与区块链</a>》中所指出的，<strong>理解问题本身比知道问题的答案要重要的多</strong>。本文中，我们辨析了线性一致性、顺序一致性、最终一致性这些概念，以及他们的关系和区别。由此我们了解到了分布式系统的一些核心问题，但我们并未讨论怎么解决这些问题。比如，采用什么算法才能提供线性一致性；面对最终一致性的系统，应该怎样编程，包括怎样处理边界情况，等等。相对于理解问题本身而言，这些反而都是细节。</p><p>  在这个系列的下一篇文章中，我们将依然遵循这样的思路，具体解析因果一致性，以及分布式系统更深层的事件排序问题。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li>[1] Peter Bailis, Ali Ghodsi, “Eventual Consistency Today: Limitations, Extensions, and Beyond”, 2013.</li><li>[2] Werner Vogels, “Eventually Consistent”, 2008.</li><li>[3] Leslie Lamport, “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Progranm”, 1979.</li><li>[4] Mustaque Ahamad, Gil Neiger, James E. Burns, et al, “Causal Memory: Definitions, Implementation and Programming”, 1994.</li><li>[5] Maurice P. Herlihy, Jeannette M. Wing, “Linearizability: A Correctness Condition for Concurrent Objects”, 1990.</li><li>[6] Seth Gilbert, Nancy Lynch, “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web”, 2002.</li><li>[7] Peter Bailis, Ali Ghodsi, et al, “Bolt-on Causal Consistency”, 2013.</li><li>[8] Bowen Alpern, Fred B. Schneider, “Defining Liveness”, 1985.</li><li>[9] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li><li>[10] Prince Mahajan, Lorenzo Alvisi, Mike Dahlin, “Consistency, Availability, and Convergence”, 2011.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Z 字形变换</title>
    <link href="/2021/01/03/ZigzagConversion/"/>
    <url>/2021/01/03/ZigzagConversion/</url>
    
    <content type="html"><![CDATA[<h2 id="Z-字形变换"><a href="#Z-字形变换" class="headerlink" title="Z 字形变换"></a>Z 字形变换</h2><ul><li><a href="https://yangtzeshore.github.io/2021/01/03/ZigzagConversion/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2021/01/03/ZigzagConversion/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/zigzag-conversion/submissions/">Z 字形变换</a></p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">L</span>   <span class="hljs-built_in">C</span>   <span class="hljs-built_in">I</span>   <span class="hljs-variable">R</span><br><span class="hljs-built_in">E</span> <span class="hljs-variable">T</span> <span class="hljs-built_in">O</span> <span class="hljs-built_in">E</span> <span class="hljs-variable">S</span> <span class="hljs-built_in">I</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">G</span><br><span class="hljs-built_in">E</span>   <span class="hljs-built_in">D</span>   <span class="hljs-variable">H</span>   <span class="hljs-built_in">N</span><br></code></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">convert</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> numRows</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>示例1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;LEETCODEISHIRING&quot;</span>, <span class="hljs-attr">numRows</span> = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">&quot;LCIRETOESIIGEDHN&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">输入<span class="hljs-operator">:</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LEETCODEISHIRING&quot;</span><span class="hljs-operator">,</span> <span class="hljs-variable">numRows</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出<span class="hljs-operator">:</span> <span class="hljs-string">&quot;LDREOEIIECIHNTSG&quot;</span><br>解释<span class="hljs-operator">:</span><br><br><span class="hljs-variable">L</span>     <span class="hljs-built_in">D</span>     <span class="hljs-variable">R</span><br><span class="hljs-built_in">E</span>   <span class="hljs-built_in">O</span> <span class="hljs-built_in">E</span>   <span class="hljs-built_in">I</span> <span class="hljs-built_in">I</span><br><span class="hljs-built_in">E</span> <span class="hljs-built_in">C</span>   <span class="hljs-built_in">I</span> <span class="hljs-variable">H</span>   <span class="hljs-built_in">N</span><br><span class="hljs-variable">T</span>     <span class="hljs-variable">S</span>     <span class="hljs-variable">G</span><br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>这一版性能不是很好，看了性能好的解法，是找出了z的排队规律，实现了性能提升。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ZigzagConversion &#123;<br><br>    <span class="hljs-built_in">public</span> static String convert(String s, <span class="hljs-type">int</span> numRows) &#123;<br>        <span class="hljs-keyword">if</span> (numRows == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br><br>        <span class="hljs-type">char</span>[][] result = <span class="hljs-built_in">new</span> <span class="hljs-type">char</span>[numRows][s.length()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>                result[i][j] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">row</span> = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> flip = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br><br>            result[<span class="hljs-keyword">row</span>][col] = s.charAt(i);<br>            <span class="hljs-keyword">if</span> (flip) &#123;<br>                <span class="hljs-keyword">row</span> <span class="hljs-comment">--;</span><br>                col ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">row</span> ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == numRows - <span class="hljs-number">1</span>) &#123;<br>                flip = <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">row</span> == <span class="hljs-number">0</span>) &#123;<br>                flip = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br><br>        StringBuilder stringBuilder = <span class="hljs-built_in">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (result[i][j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    stringBuilder.append(result[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><br>        String s = &quot;LEETCODEISHIRING&quot;;<br>        <span class="hljs-type">int</span> numRows = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(convert(s, numRows));<br><br>        s = &quot;LEETCODEISHIRING&quot;;<br><br>        numRows = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(convert(s, numRows));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是一字排开，遍历字符串。还可以优化，不需要一个数组作为结果集，直接用拼接的方式承接结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——条分缕析分布式：到底什么是一致性？</title>
    <link href="/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <url>/2021/01/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%9D%A1%E5%88%86%E7%BC%95%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%9A%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——条分缕析分布式：到底什么是一致性？"><a href="#分布式系统原理——条分缕析分布式：到底什么是一致性？" class="headerlink" title="分布式系统原理——条分缕析分布式：到底什么是一致性？"></a>分布式系统原理——条分缕析分布式：到底什么是一致性？</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261779&idx=1&sn=9fb74c24f8863837d584a96536ba8189&scene=21#wechat_redirect">这篇博客</a>，作为整理和收录，方便后续查阅。本篇文章非常推荐，与作者接下来的几篇文章都很不错，对于网上的分布式理论见解很深，且引的参考文章都很不错，可以参考看看，提升分布式系统理解很有帮助。</p><p>  凡是做服务器开发的技术同学，估计都对分布式系统以及相关的理论感兴趣。而对于分布式理论，大家讨论的最多的恐怕就是「分布式一致性」问题了。然而，不管是学术界还是业界的发展历史上，对于「一致性」这个概念的理解，始终充满了混乱。</p><p>  如果你问一个技术同学，到底什么是分布式一致性，估计会得到五花八门的答案。这其中比较常见的说法可能是这样的：一致性就是多个服务器节点中的数据保持一致（至少百度百科上差不多就是这么说的）。而如果再讨论得深入一点，可能就会谈到所谓的分布式一致性协议，比如Paxos之类的；还有CAP定理，也跟「一致性」有关。</p><p>  但是，「一致性」这个词是非常有迷惑性的。如果用英文来表达的话，跟「一致性」有关的至少有两个词：<em>consistency</em>和<em>consensus</em>。它们经常都被翻译成「一致性」，这进一步加剧了这个概念被滥用的程度。为了接下来讨论方便，我们先简单地澄清一下：</p><ul><li>网上通常提到的诸如Paxos之类的分布式一致性协议，其实是<em>consensus</em>这个词。它如果被翻译成「共识」，可能会更好一些。为了表达清晰，本文后面在讨论<em>consensus</em>问题的时候，尽量使用「共识」这个词。</li><li>ACID或CAP里C，用的都是<em>consistency</em>这个词，但真实含义迥然不同。</li><li>此外，还经常会听到人们关于「强一致性」的说法，而且这种说法通常都会牵涉到CAP定理或者「分布式事务」的概念。「强一致性」与CAP定理确实关系密切，但与「分布式事务」的关系却不知从何而来。</li></ul><p>  下面，我们就对这些概念进行详细的解析。</p><h3 id="ACID中的一致性"><a href="#ACID中的一致性" class="headerlink" title="ACID中的一致性"></a>ACID中的一致性</h3><p>  ACID是数据库事务的四个特性，分别是原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)和持久性 (Durability)。</p><p>  我们现在关注的是其中的C，即一致性<em>Consistency</em>。它是什么意思呢？通俗地说，它指的是任何一个数据库事务的执行，都应该让整个数据库保持在「一致」的状态。那怎样的状态才算「一致」呢？举个例子，假设在银行账户之间进行转账。显然，「转账」这个操作应该确保在转账前后账户总额保持不变，这是任何一个转账操作必须要遵守的规定。现在假设要从账户A向账户B转账100元，于是我们启动了一个数据库事务。在这个事务中，可以先从账号A中减去100元，再往账户B中增加100元。这样的一个事务操作，满足了“转账前后账户总额保持不变”的规定，因此我们说：这个事务操作保持了数据库的「一致性」；同时，在这个事务执行前后，数据库都处于一种「一致」的状态。</p><p>  从上一段的描述中，我们容易看出：</p><ul><li>ACID中的「一致性」，是对于整个数据库的「一致」状态的维持。抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。</li><li>所谓状态是不是「一致」，其实是由业务层规定的。比如前面这个转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。</li></ul><p>  我们再来看一下，为了让事务总是能保持ACID的一致性，我们需要在实现上考虑哪些因素呢？</p><p>  至少两个方面需要考虑：一个是出错情况 (failure&#x2F;error)；一个是并发 (concurrency) 行为。</p><p>  首先，对于任何系统来说，错误都是在所难免的。而错误又可以细分为两类。</p><p>  第一类，事务本身的实现逻辑可能存在错误。比如，从账户A向账户B转账100元，在这个事务中，如果我们只从账号A中减去了100元，但忘记了往账户B中增加100元，那么这个事务就是错误的。显然，避免第一类错误，是保持一致性的前提，这需要应用层进行恰当的编码来保证。</p><p>  第二类，则是意想不到的各种软硬件错误。比如，还是从账户A向账户B转账100元，事务本身的实现逻辑没有问题，它先执行了从账号A中减去了100元，但在执行往账户B中增加100元之前，却发生了意想不到的错误，比如进程突然crash了，或是磁盘满了，或是网络突然不通了，或是其它任何可能的硬件错误。这时候，事务只执行了前一半，势必会破坏数据库整体状态的一致性。那怎么办呢？这其实就需要ACID中的A（原子性）来保障了。简言之，原子性保障了事务的执行要么全部成功，要么全部失败，而不允许出现“只执行了一半”这种“部分成功”的情况。</p><p>  其次，并发行为也可能会影响事务的一致性。在数据库系统中，并发行为体现在可能存在多个事务同时操作同一份数据的情况。还是拿前面转账的例子来说，假设有两个事务：事务1从账户A向账户B转账100元，事务2从账户A向账户C转账50元。如果两个事务先后顺序执行，自然没有问题。但如果两个事务同时执行了，那么可能会出现下面的执行序列（假设账号A的初始余额为x元）：</p><ol><li>&lt;事务1&gt;：读取账户A的余额，读到了x元；</li><li>&lt;事务2&gt;：读取账户A的余额，也读到了x元；</li><li>&lt;事务1&gt;：向账户A中写入(x-100)元；</li><li>&lt;事务2&gt;：向账户A中写入(x-50)元；</li><li>……</li></ol><p>  上面的执行过程，账户A中最后被写入的值是(x-50)元，显然是不对的（事务的一致性会被破坏）。如果两个转账的事务能正确执行完，那么账户A的余额应该是(x-150)元才对。</p><p>  这个并发的问题怎么处理呢？这就需要ACID中的I（隔离性）来保障了。什么是隔离性呢？它对于并发执行的多个事务进行合理的排序，保障了不同事务的执行互不干扰。换言之，隔离性这种特性，能够让并发执行的多个事务就好像是按照「先后顺序」执行的一样。</p><p>  经过上面的分析，现在关于ACID中的一致性，我们可以得到一些结论了：</p><ul><li>ACID中的一致性，是个很偏应用层的概念。这跟ACID中的原子性、隔离性和持久性有很大的不同。原子性、隔离性和持久性，都是数据库本身所提供的技术特性；而一致性，则是由特定的业务场景规定的。怪不得《Designing Data-Intensive Applications》[1]一书的作者在书中写道：”<em>The letter C doesn’t really belong in ACID</em>“。</li><li>要真正做到ACID中的一致性，它是要依赖数据库的原子性和隔离性的（应对错误和并发）。但是，就算数据库提供了所有你所需要的技术特性，也不一定能保证ACID的一致性。这还取决于你在应用层对于事务本身的实现逻辑是否正确无误。</li><li>最后，ACID中的一致性，甚至跟分布式都没什么直接关系。它跟分布式的唯一关联在于，在分布式环境下，它所依赖的数据库原子性和隔离性更难实现。</li></ul><p>  总之，ACID中的一致性，是一个非常特殊的概念。除了数据库事务处理，它很难扩展到其它场景，也跟分布式理论中的其它「一致性」概念没有什么关系。</p><h3 id="分布式事务与共识算法的关系"><a href="#分布式事务与共识算法的关系" class="headerlink" title="分布式事务与共识算法的关系"></a>分布式事务与共识算法的关系</h3><p>  先说共识问题 (consensus problem)。这是分布式系统中的一个十分基础而核心的问题，它表示如何在分布式系统中的多个节点之间就某事达成共识。</p><p>  网上通常提到的「分布式一致性协议」，或者「分布式一致性算法」，一般来说就是解决这里的共识问题的算法。用词的不同，是由于中英文翻译造成的。这些算法或协议，经常包含Paxos之类，但也可能包括两阶段提交协议(2PC)或三阶段提交协议(3PC)。</p><p>  人们既然经常将Paxos、2PC、3PC这些算法放在一起讨论，那么它们之间势必存在着某种相似性的。但这种相似性是怎么来的呢？我们仔细分析一下。Paxos，是解决共识问题的通用算法。它允许每个节点提出自己的提议(称为proposal），而Paxos算法能够不借助于任何中心化节点，保证各个节点之间对于提议最终达成一致。这里的proposal，是一个抽象的概念，它可以包含任何你想达成共识的数值。2PC和3PC，则是为了解决分布式事务提交问题的。</p><p>  这样从表面看起来，Paxos和2PC、3PC，这两类算法似乎没有多少相似性。2PC和3PC是跟分布式事务强相关的，而Paxos跟分布式事务没有什么特别的关系。为了分析更深层次的本质，我们探究一下2PC和3PC产生的背景。</p><p>  回到事务的概念。事务本来和分布式没什么直接关系的，就算在一个单节点的数据库上，要实现出事务的ACID特性，也不是那么容易的。只是，如同在前一章节的结尾我们提到的，在分布式环境下，事务的ACID特性更难实现。在前一章中我们主要关注ACID中的一致性，现在我们关注一下ACID中的原子性 (Atomicity)。</p><p>  ACID中的原子性，要求事务的执行要么全部成功，要么全部失败，而不允许出现“部分成功”的情况。在分布式事务中，这要求参与事务的所有节点，要么全部执行Commit操作，要么全部执行Abort操作。换句话说，参与事务的所有节点，需要在“执行Commit还是Abort”这一点上达成一致（其实就是共识）。这个问题在学术界被称为<strong>原子提交问题</strong>（Atomic Commitment Problem）[2]，而能够解决原子提交问题的算法，则被称为<strong>原子提交协议</strong>（Atomic Commitment Protocal，简称***ACP***）[3]。2PC和3PC，属于原子提交协议两种不同的具体实现。</p><p>  分析到这里，我们似乎发现了<strong>原子提交问题</strong>与<strong>共识问题</strong>的关联性：</p><ul><li>共识问题，解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。</li><li>原子提交问题，解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。</li><li>所以，原子提交问题是共识问题的一个特例。</li></ul><p>  这个酷似「三段论」式的论述，看起来“合情合理”。实际上，学术界在很长一段时间内都认为，分布式事务的原子提交问题是拜占庭将军问题（Byzantine Generals Problem）的一个退化形式[4]。什么是拜占庭将军问题呢？简单来说，它也是分布式系统的一种<strong>共识问题</strong>，而且是容错性要求最高的一种共识问题。我们在这里不展开讨论拜占庭将军问题了，如果你对细节感兴趣，欢迎阅读我之前的另一篇文章“<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261626&idx=1&sn=6b32cc7a7a62bee303a8d1c4952d9031&scene=21#wechat_redirect">漫谈分布式系统、拜占庭将军问题与区块链</a>”。总之，学术界以前的这种观点，跟我们刚刚分析得到的结论（原子提交问题是共识问题的一个特例）差不多。</p><p>  但是，分布式系统的诡异之处就要体现在这里，一些细节的不同，可能导致非常大的差异。如果你仔细看前文的描述，会发现这样一个细节：当我们描述共识问题的时候，我们说的是在<strong>多个节点</strong>之间达成共识；而当我们描述原子提交问题的时候，我们说的是在<strong>所有节点</strong>之间达成共识。这个细微的差别，让这两类问题，几乎变成了完全不同的问题（谁也替代不了谁）。</p><p>  从两类问题各自的应用场景来看，这个差异是合理的，也是容易理解的。以解决共识问题的Paxos协议为例，它只要求网络中的大部分节点达成共识就可以了，这样Paxos才能提供一定的容错性，只要网络中发生故障的节点不超过一半仍然能够正常工作（不会被阻塞）。然而，解决原子提交问题的2PC或3PC则不同。即使只有一个节点发生故障了，其它节点也不能擅自决策进行Commit操作。因为这样的话，这个事务就只是「部分地执行成功了」，违反了ACID原子性的要求。所以，原子提交协议必须保证在参与分布式事务的<strong>所有节点</strong>（包括故障的节点）上对于“执行Commit还是Abort”达成共识。</p><p>  故障的节点可能什么都做不了，如何参与达成共识呢？这里的意思是，等故障节点恢复之后，它的决策（Commit或是Abort）必须与其它所有节点保持一致。那么，这是不是意味着，只要有节点发生故障，原子提交协议就一定会阻塞呢？这里有点让人奇怪，答案是「不一定」。根源就在于Abort和Commit并不是对等的决策。假设有一个节点宕机了，其它节点大可以选择Abort决策（注意不能选择Commit），从而让整个事务Abort掉（没有被阻塞住，等待宕机的节点恢复）。等宕机的那个节点恢复了，它会发现相应的事务已经执行Abort了，那么它也按照Abort处理就好了。在这个过程中，参与分布式事务的<strong>所有节点</strong>（包括宕机的这个节点）对于“执行Commit还是Abort”也是达成了共识的（这个共识是Abort）。正是这些细微却至关重要的细节，让2PC和3PC这种看似简单的协议实现起来没有那么容易。</p><p>  论文[5]进一步澄清了这一问题，原子提交问题被抽象成一个新的一致性问题，称为uniform consensus问题，它是与通常的共识问题（consensus problem）不同的问题，而且是更难的问题。uniform consensus，要求所有节点（包括故障节点）都要达成共识；而consensus问题只关注没有发生故障的节点达成共识。</p><p>  至此，我们总结一下本章节的结论：</p><ul><li>共识问题（consensus problem），解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。它只关注没有发生故障的节点达成共识就可以了。</li><li>在分布式事务中，ACID中的原子性，引出了原子提交问题，它解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。原子提交问题属于uniform consensus问题，要求所有节点（包括故障节点）都要达成共识，是比consensus问题更难的一类问题。</li><li>Paxos和解决拜占庭将军问题的算法，解决的是consensus问题；2PC&#x2F;3PC，解决的是一个特定的uniform consensus问题。</li></ul><h3 id="CAP与线性一致性"><a href="#CAP与线性一致性" class="headerlink" title="CAP与线性一致性"></a>CAP与线性一致性</h3><p>  CAP的三个字母分别代表了分布式系统的三个特性：一致性（Consistency）、可用性（Availability）和分区容错性（Partition-tolerance）。而CAP定理指出：任何一个分布式系统只能同时满足三个特性中的两个。但是，这一描述曾经引发了非常多的误解。</p><p>  为了进一步展开讨论，我们先关注CAP中的C，也就是一致性。它是什么意思呢？在证明CAP定理的原始论文中[6]，C指的是<em>linearizable consistency</em>，也就是「线性一致性」。更精简的英文表达则是<em>linearizability</em>。</p><p>  这听起来可能稍微有点奇怪，但事实就是这样。<strong>线性一致性</strong>（<em>linearizability</em>）是CAP中的C的原始定义。而很多人在谈到CAP时，则会把这个C看成是<strong>强一致性</strong>（<em>strong consistency</em>）。这其实也没错，因为线性一致性的另一个名字，就是强一致性[1]。只不过，相比「线性一致性」来说，「强一致性」并不是一个好名字。因为，从这个名字你看不出来它真实的含义（到底「强」在哪？）。在下面的讨论中，我们统一使用线性一致性(<em>linearizability</em>)这个词汇。</p><p>  那线性一致性是什么意思呢？它精确的形式化定义[7]非常抽象，且难以理解。大体上是说，在一个并发执行的环境中，不同的操作之间可能是有严格的先后关系的（一个操作执行结束之后另一个操作才开始执行），也可能是并发执行的（一个操作还没执行结束，另一个操作就开始执行了）；如果能够把所有操作排列成一个「合法」的全局线性顺序，那么这些操作就是满足线性一致性的。当然，在这个重新排列的过程中，原来就存在的严格的先后关系，必须得以保持。</p><p>  但是，怎么才算合法呢？我们具体到一个存储系统中通过例子来说明。假如我们先往某个数据对象中写入了一个值（假设是1），然后在写入操作结束之后，我们再把这个数据对象读出来（在写入和读取操作之间没有其它的写入操作了）。如果我们发现读取到的值是1，那么就是合法的；而如果读出来的值不是1，那么就是非法的。再假设，我们又执行了一次读取操作，发现读出来的值仍然是1，那么就是合法的；否则就是非法的。也就是说，如果一个读操作已经读到了某个值，那么下一个对于同一个数据对象的读操作就必须读取到同样的值（除非在两次读操作之间还存在别的写入操作）。</p><p>  这些例子都比较容易理解，因为站在观察者的角度它们是符合逻辑的。因此，对于一个分布式存储系统来说，线性一致性的含义可以用一个具体的描述来取代：对于任何一个数据对象来说，<strong>系统表现得就像它只有一个副本一样</strong>[1]。“表现得像只有一个副本”，也就相当于满足了前面的「合法」条件。显然，如果系统对于每个数据对象真的只存一个副本，那么肯定是满足线性一致性的。但是单一副本不具有容错性，所以分布式存储系统一般都会对数据进行复制（replication），也就是保存多个副本。这时，在一个分布式多副本的存储系统中，要提供线性一致性的保证，就需要付出额外的成本了。</p><p>  网上对于CAP的一致性的通俗解释，通常有两种：</p><ol><li>一致性是指：在分布式系统完成某写操作后的任何读操作，都应该获取到该写操作写入的那个最新的值。显然，如果系统“表现得像只有一个副本”一样，这个描述是成立的。不过这只是描述了线性一致性的一个特例而已，有以偏概全的嫌疑。</li><li>一致性是指：保持所有节点在同一个时刻具有相同的、逻辑一致的数据。显然这种解释并不是从观察者的角度来描述的，而是试图从系统内部的行为（内部实现）来描述的。「所有节点」，可能指的是「所有副本」；至于“在同一个时刻具有相同的、逻辑一致的数据”这个说法，则似乎离线性一致性的本来含义偏离太远了。从逻辑上说，“表现得像只有一个副本”，并不一定需要系统“在同一个时刻具有相同的、逻辑一致的数据”。线性一致性可能有很多种实现方式，而这种解释规定了一种具体的系统实现，同样有以偏概全的嫌疑。</li></ol><p>  我们前面提到，线性一致性，也被称为强一致性。之所以这么说，大概是因为线性一致性要求多个副本上的数据必须保持如此之「强」的一致性，以至于“让系统表现得就像只有一个副本”。</p><p>  另外，网上的资料提到强一致性的时候，还有可能会关联到分布式事务上面，比如2PC&#x2F;3PC这些原子提交协议。但把它们关联到一起的说法，其深层次含义到底是什么，只能靠猜测。分布式事务处理的并不是同一个数据对象的多个副本的问题，而指的是将针对多个数据对象的各种操作组合起来，提供ACID的特性。将分布式事务看成是强一致性的保证，猜测可能实际上指的就是ACID的原子性。总之，「强一致性」这个词很容易产生误解，所以建议谨慎使用。</p><p>  在历史上，CAP定理具有巨大的知名度，但它实际的影响力却没有想象的那么大。随着分布式理论的发展，我们逐渐认识到，CAP并不是一个「大一统」的理论，远不能涵盖分布式系统设计中方方面面的问题。相反，CAP引发了很多误解和理解上的混乱（细节不讨论了）。因此，可以预见到，未来CAP定理的影响将会进一步被削弱。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>  本文我们辨析了分布式系统中的诸多被称为「一致性」的概念。但这个话题还没有完，我将在下一篇文章中跟大家继续讨论顺序一致性、线性一致性、最终一致性等概念。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li>[1] Martin Kleppmann,《Designing Data-Intensive Applications》, 2017.</li><li>[2] Vassos Hadzilacos, “On The Relationship Between The Atomic Commitment And Consensus Problems”, 1990.</li><li>[3] Philip A. Bernstein, Vassos Hadzilacos, Nathan Goodman, 《Concurrency Control And Recovery in Database Systems》, 1987.</li><li>[4] Jim Gray, “A Comparison Of The Byzantine Agreement Problem And The Transaction Commit Problem”, 1988.</li><li>[5] Bernadette Charron-Bost, André Schiper, “Uniform Consensus Is Harder Than Consensus”, 2001.</li><li>[6] Seth Gilbert, Nancy Lynch, “Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web”, 2002.</li><li>[7] MAURICE P. HERLIHY, JEANNETTE M. WING, “Linearizability: A Correctness Condition for Concurrent Objects”, 1990.</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestPalindrome</title>
    <link href="/2021/01/02/LongestPalindrome/"/>
    <url>/2021/01/02/LongestPalindrome/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><p>示例 1:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;babad&quot;</span><br>输出<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bab&quot;</span><br>注意<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;aba&quot;</span> 也是一个有效答案。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>1、下面第一版自己写的，比较粗糙</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LongestPalindrome &#123;<br><br>    <span class="hljs-built_in">public</span> static String longestPalindrome(String s) &#123;<br><br>        <span class="hljs-keyword">if</span> (s.length() &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s.length() - <span class="hljs-number">1</span>; j &gt; i; j <span class="hljs-comment">--) &#123;</span><br>                <span class="hljs-keyword">if</span> (checkPalindrome(s.substring(i, j + <span class="hljs-number">1</span>))) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>                        start = i;<br>                        end = j;<br>                        maxLength = j - i + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j - i + <span class="hljs-number">1</span> &lt;= maxLength) &#123;<br>                    break;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s.length() - i &lt;= maxLength) &#123;<br>                break;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">boolean</span> checkPalindrome(String s) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(s.length() - i - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        String s = &quot;bbabba&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;cbbd&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;bb&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bbabb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是多次循环判断找回文。</li></ul><p>2、第一版耗时太久，下面第二版就优化了一下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LongestPalindrome &#123;<br><br>    <span class="hljs-built_in">public</span> static String longestPalindrome(String s) &#123;<br><br>        <span class="hljs-keyword">if</span> (s.length() &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; s.length()) &#123;<br>            <span class="hljs-type">int</span> left = <span class="hljs-keyword">index</span>, right = <span class="hljs-keyword">index</span>;<br>            // 先找到字符一样的字符串<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; s.length() - <span class="hljs-number">1</span> &amp;&amp; s.charAt(<span class="hljs-keyword">index</span>) == s.charAt(<span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">index</span> ++;<br>                right ++;<br>            &#125;<br>            // 从某个点开始，向两边扩散寻找最长串<br>            <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;<br>                left <span class="hljs-comment">--;</span><br>                right ++;<br>            &#125;<br>            left ++;<br>            <br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; maxLength) &#123;<br>                maxLength = right - left +<span class="hljs-number">1</span>;right <span class="hljs-comment">--;</span><br>                start = left;<br>            &#125;<br>            <span class="hljs-keyword">index</span> ++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">start</span> + maxLength);<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        String s = &quot;bbabba&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;cbbd&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>        s = &quot;bb&quot;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(longestPalindrome(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bbabb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bb</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是分两种情况，第一种，找最长相同字符串，第二种，就是从某个字符开始，向两边扩散，找回文。当然这两种是可以放在一起的，如代码。这样就解决了双重循环找回文的次数，耗时当然少了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FindMedianSortedArrays</title>
    <link href="/2021/01/01/FindMedianSortedArrays/"/>
    <url>/2021/01/01/FindMedianSortedArrays/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p><p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p><p>示例 1:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span><br>输出：2.00000<br>解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">2.50000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0.00000</span><br></code></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = []<br>输出：<span class="hljs-number">2.00000</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>1、下面第一版自己写的，比较粗糙</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> FindMedianSortedArrays &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">double</span> findMedianSortedArrays(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br>        <span class="hljs-type">int</span> [] nums3 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nums1.length + nums2.length];<br>        <span class="hljs-keyword">if</span> (nums2.length == <span class="hljs-number">0</span> &amp;&amp; nums1.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums1.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> getMidNum(nums2);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums2.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> getMidNum(nums1);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; ;) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;<br>                nums3[k] = nums1[i];<br>                i++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;<br>                nums3[k] = nums2[j];<br>                j++;<br>                k++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[i] == nums2[j]) &#123;<br>                nums3[k] = nums2[j];<br>                j++;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == nums1.length) &#123;<br>                <span class="hljs-keyword">for</span> (; j &lt; nums2.length; j++, k++) &#123;<br>                    nums3[k] = nums2[j];<br>                &#125;<br>                break;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == nums2.length) &#123;<br>                <span class="hljs-keyword">for</span> (; i &lt; nums1.length; i++, k++) &#123;<br>                    nums3[k] = nums1[i];<br>                &#125;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(Arrays.toString(nums3));<br>        <span class="hljs-keyword">return</span> getMidNum(nums3);<br>    &#125;<br><br>    private static <span class="hljs-type">double</span> getMidNum(<span class="hljs-type">int</span>[] nums3) &#123;<br>        <span class="hljs-keyword">if</span>(nums3.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums3[(nums3.length - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (nums3[(nums3.length - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span>] + nums3[(nums3.length)/<span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span>[] nums1 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, nums2 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums1, nums2));<br>        <span class="hljs-type">int</span>[] nums3 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, nums4 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums3, nums4));<br>        <span class="hljs-type">int</span>[] nums5 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;, nums6 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums5, nums6));<br>        <span class="hljs-type">int</span>[] nums7 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;, nums8 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums7, nums8));<br>        <span class="hljs-type">int</span>[] nums9 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">2</span>&#125;, nums10 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums9, nums10));<br>        <span class="hljs-type">int</span>[] nums11 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;, nums12 = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(findMedianSortedArrays(nums11, nums12));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-number">2.0</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-number">2.5</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><span class="hljs-number">0.0</span><br><span class="hljs-number">1.0</span><br><span class="hljs-number">2.0</span><br>[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><span class="hljs-number">0.0</span><br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>就是将两个数组合成一个数组，但是考虑几种情况，然后做处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongestSubstringWithoutRepeatingCharacters</title>
    <link href="/2020/12/29/LongestSubstringWithoutRepeatingCharacters/"/>
    <url>/2020/12/29/LongestSubstringWithoutRepeatingCharacters/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package algorithm;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LongestSubstringWithoutRepeatingCharacters &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> lengthOfLongestSubstring(String s) &#123;<br>        // 记录字符上一次出现的位置<br>        <span class="hljs-type">int</span>[] last = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++) &#123;<br>            last[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n = s.length();<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; // 窗口开始位置<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            // 字符转数字<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = s.charAt(i);<br>            // 最主要的就是这一行，找到起始位置：分两种情况：<br>            // 一直都是不同的字符，那<span class="hljs-keyword">start</span>不变<br>            // 遇到重复的，也分两种情况，一种是和起始重复，从重复的字符+<span class="hljs-number">1</span>位<br>            // 一种是和后面的字符重复，也是从重复的字符+<span class="hljs-number">1</span>位<br>            start = Math.max(<span class="hljs-keyword">start</span>, last[<span class="hljs-keyword">index</span>] + <span class="hljs-number">1</span>);<br>            // 记录最长串长度<br>            result = Math.max(result, i - <span class="hljs-keyword">start</span> + <span class="hljs-number">1</span>);<br>            // 记录最新的该字符所在位置<br>            last[<span class="hljs-keyword">index</span>] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLongestSubstring(&quot;abcabcbb&quot;));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLongestSubstring(&quot;bbbbb&quot;));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lengthOfLongestSubstring(&quot;cd&quot;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>1<br>2<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>找到起始位置：分两种情况：一直都是不同的字符，那start不变；遇到重复的，也分两种情况，一种是和起始重复，从起始重复的字符+1位，一种是和后面的字符重复，也是从后面的字符重复的字符+1位。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——使用场景</title>
    <link href="/2020/10/30/Zookeeper%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2020/10/30/Zookeeper%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper——使用场景"><a href="#Zookeeper——使用场景" class="headerlink" title="Zookeeper——使用场景"></a>Zookeeper——使用场景</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  大致来说，zookeeper 的使用场景如下，举几个简单的：</p><ul><li>分布式协调</li><li>分布式锁</li><li>元数据&#x2F;配置信息管理</li><li>HA 高可用性</li></ul><h3 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h3><p>  这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上<strong>对某个节点的值注册个监听器</strong>，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-distributed-coordination.png" alt="zookeeper-distributed-coordination"></a></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>  举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也<strong>尝试去创建</strong>那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-distributed-lock-demo.png" alt="zookeeper-distributed-lock-demo"></a></p><h3 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h3><p>  zookeeper 可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持 zookeeper 么？</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-meta-data-manage.png" alt="zookeeper-meta-data-manage"></a></p><h3 id="HA-高可用性"><a href="#HA-高可用性" class="headerlink" title="HA 高可用性"></a>HA 高可用性</h3><p>  这个应该是很常见的，比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个<strong>重要进程一般会做主备</strong>两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/Zookeeper-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Zookeeper/zookeeper-active-standby.png" alt="zookeeper-active-standby"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/zookeeper-application-scenarios.md">1. zookeeper-application-scenarios</a></p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统原理——CAP定理</title>
    <link href="/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CAP%E5%AE%9A%E7%90%86/"/>
    <url>/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94CAP%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统原理——CAP定理"><a href="#分布式系统原理——CAP定理" class="headerlink" title="分布式系统原理——CAP定理"></a>分布式系统原理——CAP定理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-cap.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="分布式系统-CAP-定理-P-代表什么含义"><a href="#分布式系统-CAP-定理-P-代表什么含义" class="headerlink" title="分布式系统 CAP 定理 P 代表什么含义"></a>分布式系统 CAP 定理 P 代表什么含义</h3><p>  作者之前在看 CAP 定理时抱有很大的疑惑，CAP 定理的定义是指在分布式系统中三者只能满足其二，也就是存在分布式 CA 系统的。作者在网络上查阅了很多关于 CAP 文章，虽然这些文章对于 P 的解释五花八门，但总结下来这些观点大多都是指 P 是不可缺少的，也就是说在分布式系统只能是 AP 或者 CP，这种理论与我之前所认识的理论（存在分布式 CA 系统）是冲突的，所以才有了疑惑。</p><blockquote><p>这个定理起源于加州大学柏克莱分校（University of California, Berkeley）的计算机科学家埃里克·布鲁尔在 2000 年的分布式计算原理研讨会（PODC）上提出的一个猜想。 在 2002 年，麻省理工学院（MIT）的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为一个定理。</p></blockquote><h4 id="什么是-CAP-定理（CAP-theorem）"><a href="#什么是-CAP-定理（CAP-theorem）" class="headerlink" title="什么是 CAP 定理（CAP theorem）"></a>什么是 CAP 定理（CAP theorem）</h4><p>  在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li><li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）</li></ul><h4 id="分区容错性（Partition-tolerance）"><a href="#分区容错性（Partition-tolerance）" class="headerlink" title="分区容错性（Partition tolerance）"></a>分区容错性（Partition tolerance）</h4><p>  理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。</p><ul><li>P 指的是分区容错性，分区现象产生后需要容错，容错是指在 A 与 C 之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况） 本身就没有分区 ，既然没有分区则就更没有分区容错性 P。</li><li>无论我设计的系统是 AP 还是 CP 系统如果没有出现不一致不可用。 则该系统就处于 CA 状态</li><li>P 的体现前提是得有分区情况存在</li></ul><blockquote><p>文章来源：<a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">维基百科 CAP 定理</a></p></blockquote><h3 id="几个常用的-CAP-框架对比"><a href="#几个常用的-CAP-框架对比" class="headerlink" title="几个常用的 CAP 框架对比"></a>几个常用的 CAP 框架对比</h3><table><thead><tr><th>框架</th><th>所属</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td></tr><tr><td>Zookeeper</td><td>CP</td></tr><tr><td>Consul</td><td>CP</td></tr></tbody></table><h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><blockquote><p>Eureka 保证了可用性，实现最终一致性。</p></blockquote><p>  Eureka 所有节点都是平等的所有数据都是相同的，且 Eureka 可以相互交叉注册。<br>  Eureka client 使用内置轮询负载均衡器去注册，有一个检测间隔时间，如果在一定时间内没有收到心跳，才会移除该节点注册信息；如果客户端发现当前 Eureka 不可用，会切换到其他的节点，如果所有的 Eureka 都跪了，Eureka client 会使用最后一次数据作为本地缓存；所以以上的每种设计都是他不具备<code>一致性</code>的特性。</p><p>  注意：因为 Eureka AP 的特性和请求间隔同步机制，在服务更新时候一般会手动通过 Eureka 的 api 把当前服务状态设置为<code>offline</code>，并等待 2 个同步间隔后重新启动，这样就能保证服务更新节点对整体系统的影响。</p><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><blockquote><p>强一致性</p></blockquote><p>  Zookeeper 在选举 leader 时会停止服务，只有成功选举 leader 成功后才能提供服务，选举时间较长；内部使用 paxos 选举投票机制，只有获取半数以上的投票才能成为 leader，否则重新投票，所以部署的时候最好集群节点不小于 3 的奇数个（但是谁能保证跪掉后节点也是基数个呢）；Zookeeper 健康检查一般是使用 tcp 长链接，在内部网络抖动时或者对应节点阻塞时候都会变成不可用，这里还是比较危险的。</p><h4 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h4><p>  和 Zookeeper 一样数据 CP。</p><p>  Consul 注册时候只有过半的节点都写入成功才认为注册成功；leader 挂掉时，重新选举期间整个 Consul 不可用,保证了强一致性但牺牲了可用性。<br>  有很多 blog 说 Consul 属于 ap，官方已经确认他为 CP 机制 原文地址：<a href="https://www.consul.io/docs/intro/vs/serf%E3%80%82">https://www.consul.io/docs/intro/vs/serf。</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-cap.md">1. distributed-system-cap</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——5. 分布式事务</title>
    <link href="/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%945.%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%945.%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——5-分布式事务"><a href="#分布式系统设计——5-分布式事务" class="headerlink" title="分布式系统设计——5. 分布式事务"></a>分布式系统设计——5. 分布式事务</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-transaction.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。</p><p>  分布式事务的实现主要有以下 6 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>SAGA 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="两阶段提交方案-XA-方案"><a href="#两阶段提交方案-XA-方案" class="headerlink" title="两阶段提交方案&#x2F;XA 方案"></a>两阶段提交方案&#x2F;XA 方案</h3><p>  所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>  这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>  这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>  如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>  如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-XA.png" alt="distributed-transacion-XA"></a></p><h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p>  TCC 的全称是： <code>Try</code> 、 <code>Confirm</code> 、 <code>Cancel</code> 。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>  这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个<strong>事务回滚</strong>实际上是<strong>严重依赖于你自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大，非常之恶心。</p><p>  比如说我们，一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>  而且最好是你的各个业务执行的时间都比较短。</p><p>  但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-TCC.png" alt="distributed-transacion-TCC"></a></p><h3 id="Saga-方案"><a href="#Saga-方案" class="headerlink" title="Saga 方案"></a>Saga 方案</h3><p>  金融核心等业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而对于更多的金融核心以上的业务系统 往往会选择补偿事务，补偿事务处理在 30 多年前就提出了 Saga 理论，随着微服务的发展，近些年才逐步受到大家的关注。目前业界比较公认的是采用 Saga 作为长事务的解决方案。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>  业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。下图左侧是正常的事务流程，当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程，反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-saga.png" alt="distributed-transacion-TCC"></a></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>  对于一致性要求高、短流程、并发高 的场景，如：金融核心系统，会优先考虑 TCC 方案。而在另外一些场景下，我们并不需要这么强的一致性，只需要保证最终一致性即可。</p><p>  比如 很多金融核心以上的业务（渠道层、产品层、系统集成层），这些系统的特点是最终一致即可、流程多、流程长、还可能要调用其它公司的服务。这种情况如果选择 TCC 方案开发的话，一来成本高，二来无法要求其它公司的服务也遵循 TCC 模式。同时流程长，事务边界太长，加锁时间长，也会影响并发性能。</p><p>  所以 Saga 模式的适用场景是：</p><ul><li>业务流程长、业务流程多；</li><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>一阶段提交本地事务，无锁，高性能；</li><li>参与者可异步执行，高吞吐；</li><li>补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不保证事务的隔离性。</li></ul><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>  本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>  这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>  这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-local-message-table.png" alt="distributed-transaction-local-message-table"></a></p><h3 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h3><p>  这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>  大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-5-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/distributed-transaction-reliable-message.png" alt="distributed-transaction-reliable-message"></a></p><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>  这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><h3 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h3><p>  如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>  你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>  友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>  当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-transaction.md">1. distributed-transaction</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——6. Dubbo服务治理</title>
    <link href="/2020/10/25/Dubbo%E2%80%94%E2%80%946.%20Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <url>/2020/10/25/Dubbo%E2%80%94%E2%80%946.%20Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——6-Dubbo服务治理"><a href="#Dubbo——6-Dubbo服务治理" class="headerlink" title="Dubbo——6. Dubbo服务治理"></a>Dubbo——6. Dubbo服务治理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  <strong>服务治理</strong>，这个问题如果问你，其实就是看看你有没有<strong>服务治理</strong>的思想，因为这个是做过复杂微服务的人肯定会遇到的一个问题。</p><p>  <strong>服务降级</strong>，这个是涉及到复杂分布式系统中必备的一个话题，因为分布式系统互相来回调用，任何一个系统故障了，你不降级，直接就全盘崩溃？那就太坑爹了吧。</p><p>  <strong>失败重试</strong>，分布式系统中网络请求如此频繁，要是因为网络问题不小心失败了一次，是不是要重试？</p><p>  <strong>超时重试</strong>，跟上面一样，如果不小心网络慢一点，超时了，如何重试？</p><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><h4 id="1-调用链路自动生成"><a href="#1-调用链路自动生成" class="headerlink" title="1. 调用链路自动生成"></a>1. 调用链路自动生成</h4><p>  一个大型的分布式系统，或者说是用现在流行的微服务架构来说吧，<strong>分布式系统由大量的服务组成</strong>。那么这些服务之间互相是如何调用的？调用链路是啥？说实话，几乎到后面没人搞的清楚了，因为服务实在太多了，可能几百个甚至几千个服务。</p><p>  那就需要基于 dubbo 做的分布式系统中，对各个服务之间的调用自动记录下来，然后自动将<strong>各个服务之间的依赖关系和调用链路生成出来</strong>，做成一张图，显示出来，大家才可以看到对吧。</p><p><a href="https://yangtzeshore.github.io/2020/10/25/Dubbo-6-Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-service-invoke-road.png" alt="dubbo-service-invoke-road"></a></p><h4 id="2-服务访问压力以及时长统计"><a href="#2-服务访问压力以及时长统计" class="headerlink" title="2. 服务访问压力以及时长统计"></a>2. 服务访问压力以及时长统计</h4><p>  需要自动统计<strong>各个接口和服务之间的调用次数以及访问延时</strong>，而且要分成两个级别。</p><ul><li>一个级别是接口粒度，就是每个服务的每个接口每天被调用多少次，TP50&#x2F;TP90&#x2F;TP99，三个档次的请求延时分别是多少；</li><li>第二个级别是从源头入口开始，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的 TP50&#x2F;TP90&#x2F;TP99，分别是多少。</li></ul><p>  这些东西都搞定了之后，后面才可以来看当前系统的压力主要在哪里，如何来扩容和优化啊。</p><h4 id="3-其它"><a href="#3-其它" class="headerlink" title="3. 其它"></a>3. 其它</h4><ul><li>服务分层（避免循环依赖）</li><li>调用链路失败监控和报警</li><li>服务鉴权</li><li>每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）</li></ul><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>  比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。</p><p>  举个栗子，我们有接口 <code>HelloService</code> 。 <code>HelloServiceImpl</code> 有该接口的具体实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">public interface HelloService &#123;<br>   void sayHello();<br>&#125;<br>public class HelloServiceImpl implements HelloService &#123;<br>    public void sayHello() &#123;<br>        System.out.println(&quot;hello world......&quot;);<br>    &#125;<br>&#125;<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo-provider&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.zhss.service.HelloService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;helloServiceImpl&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10000&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zhss.service.HelloServiceImpl&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo-consumer&quot;</span>  /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fooService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.test.service.FooService&quot;</span>  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10000&quot;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;return null&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  我们调用接口失败的时候，可以通过 <code>mock</code> 统一返回 null。</p><p>  mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+ <code>Mock</code> ” 后缀。然后在 Mock 类里实现自己的降级逻辑。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HelloServiceMock</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">HelloService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> sayHello() &#123;<br>        <span class="hljs-comment">// 降级逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="失败重试和超时重试"><a href="#失败重试和超时重试" class="headerlink" title="失败重试和超时重试"></a>失败重试和超时重试</h3><p>  所谓失败重试，就是 consumer 调用 provider 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。配置如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;dubbo:reference <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;xxxx&quot;</span> <span class="hljs-attribute">interface</span>=<span class="hljs-string">&quot;xx&quot;</span> <span class="hljs-attribute">check</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attribute">async</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attribute">retries</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attribute">timeout</span>=<span class="hljs-string">&quot;2000&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>  举个栗子。</p><p>  某个服务的接口，要耗费 5s，你这边不能干等着，你这边配置了 timeout 之后，我等待 2s，还没返回，我直接就撤了，不能干等你。</p><p>  可以结合你们公司具体的场景来说说你是怎么设置这些参数的：</p><ul><li><code>timeout</code> ：一般设置为 <code>200ms</code> ，我们认为不能超过 <code>200ms</code> 还没返回。</li><li><code>retries</code> ：设置 retries，一般是在读请求的时候，比如你要查询个数据，你可以设置个 retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">1. dubbo-service-management</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——5. Dubbo的 spi 思想</title>
    <link href="/2020/10/25/Dubbo%E2%80%94%E2%80%945.%20Dubbo%E7%9A%84%20spi%20%E6%80%9D%E6%83%B3/"/>
    <url>/2020/10/25/Dubbo%E2%80%94%E2%80%945.%20Dubbo%E7%9A%84%20spi%20%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——5-Dubbo的-spi-思想"><a href="#Dubbo——5-Dubbo的-spi-思想" class="headerlink" title="Dubbo——5. Dubbo的 spi 思想"></a>Dubbo——5. Dubbo的 spi 思想</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-spi.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="spi-是啥？"><a href="#spi-是啥？" class="headerlink" title="spi 是啥？"></a>spi 是啥？</h3><p>  spi，简单来说，就是 <code>service provider interface</code> ，说白了是什么意思呢，比如你有个接口，现在这个接口有 3 个实现类，那么在系统运行的时候对这个接口到底选择哪个实现类呢？这就需要 spi 了，需要<strong>根据指定的配置</strong>或者是<strong>默认的配置</strong>，去<strong>找到对应的实现类</strong>加载进来，然后用这个实现类的实例对象。</p><p>  举个栗子。</p><p>  你有一个接口 A。A1&#x2F;A2&#x2F;A3 分别是接口 A 的不同实现。你通过配置 <code>接口 A = 实现 A2</code> ，那么在系统实际运行的时候，会加载你的配置，用实现 A2 实例化一个对象来提供服务。</p><p>  spi 机制一般用在哪儿？<strong>插件扩展的场景</strong>，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 spi 思想就用上了。</p><h3 id="Java-spi-思想的体现"><a href="#Java-spi-思想的体现" class="headerlink" title="Java spi 思想的体现"></a>Java spi 思想的体现</h3><p>  spi 经典的思想体现，大家平时都在用，比如说 jdbc。</p><p>  Java 定义了一套 jdbc 的接口，但是 Java 并没有提供 jdbc 的实现类。</p><p>  但是实际上项目跑的时候，要使用 jdbc 接口的哪些实现类呢？一般来说，我们要<strong>根据自己使用的数据库</strong>，比如 mysql，你就将 <code>mysql-jdbc-connector.jar</code> 引入进来；oracle，你就将 <code>oracle-jdbc-connector.jar</code> 引入进来。</p><p>  在系统跑的时候，碰到你使用 jdbc 的接口，他会在底层使用你引入的那个 jar 中提供的实现类。</p><h3 id="dubbo-的-spi-思想"><a href="#dubbo-的-spi-思想" class="headerlink" title="dubbo 的 spi 思想"></a>dubbo 的 spi 思想</h3><p>  dubbo 也用了 spi 思想，不过没有用 jdk 的 spi 机制，是自己实现的一套 spi 机制。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Protocol protocol <span class="hljs-operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>  Protocol 接口，在系统运行的时候，dubbo 会判断一下应该选用这个 Protocol 接口的哪个实现类来实例化对象来使用。</p><p>  它会去找一个你配置的 Protocol，将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。</p><p>  上面那行代码就是 dubbo 里大量使用的，就是对很多组件，都是保留一个接口和多个实现，然后在系统运行的时候动态根据配置去找到对应的实现类。如果你没配置，那就走默认的实现好了，没问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SPI(&quot;dubbo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Protocol</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultPort</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Adaptive</span><br>    &lt;T&gt; Exporter&lt;T&gt; <span class="hljs-title function_">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException;<br><br>    <span class="hljs-meta">@Adaptive</span><br>    &lt;T&gt; Invoker&lt;T&gt; <span class="hljs-title function_">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  在 dubbo 自己的 jar 里，在 <code>/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code> 文件中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dubbo=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.DubboProtocol</span><br>http=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.HttpProtocol</span><br>hessian=com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.rpc</span><span class="hljs-selector-class">.protocol</span><span class="hljs-selector-class">.hessian</span>.HessianProtocol<br></code></pre></td></tr></table></figure><p>  所以说，这就看到了 dubbo 的 spi 机制默认是怎么玩儿的了，其实就是 Protocol 接口， <code>@SPI(&quot;dubbo&quot;)</code> 说的是，通过 SPI 机制来提供实现类，实现类是通过 dubbo 作为默认 key 去配置文件里找到的，配置文件名称与接口全限定名一样的，通过 dubbo 作为 key 可以找到默认的实现类就是 <code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</code> 。</p><p>  如果想要动态替换掉默认的实现类，需要使用 <code>@Adaptive</code> 接口，Protocol 接口中，有两个方法加了 <code>@Adaptive</code> 注解，就是说那俩接口会被代理实现。</p><p>  啥意思呢？</p><p>  比如这个 Protocol 接口搞了俩 <code>@Adaptive</code> 注解标注了方法，在运行的时候会针对 Protocol 生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据 url 中的 protocol 来获取那个 key，默认是 dubbo，你也可以自己指定，你如果指定了别的 key，那么就会获取别的实现类的实例了。</p><h3 id="如何自己扩展-dubbo-中的组件"><a href="#如何自己扩展-dubbo-中的组件" class="headerlink" title="如何自己扩展 dubbo 中的组件"></a>如何自己扩展 dubbo 中的组件</h3><p>  下面来说说怎么来自己扩展 dubbo 中的组件。</p><p>  自己写个工程，要是那种可以打成 jar 包的，里面的 <code>src/main/resources</code> 目录下，搞一个 <code>META-INF/services</code> ，里面放个文件叫： <code>com.alibaba.dubbo.rpc.Protocol</code> ，文件里搞一个 <code>my=com.bingo.MyProtocol</code> 。自己把 jar 弄到 nexus 私服里去。</p><p>  然后自己搞一个 <code>dubbo provider</code> 工程，在这个工程里面依赖你自己搞的那个 jar，然后在 spring 配置文件里给个配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;dubbo:protocol <span class="hljs-attribute">name</span>=”my” <span class="hljs-attribute">port</span>=”20000” /&gt;<br></code></pre></td></tr></table></figure><p>  provider 启动的时候，就会加载到我们 jar 包里的 <code>my=com.bingo.MyProtocol</code> 这行配置里，接着会根据你的配置使用你定义好的 MyProtocol 了，这个就是简单说明一下，你通过上述方式，可以替换掉大量的 dubbo 内部的组件，就是扔个你自己的 jar 包，然后配置一下即可。</p><p>[<img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-spi.png" alt="dubbo-spi">](<a href="https://yangtzeshore.github.io/2020/10/25/Dubbo-5-Dubbo%E7%9A%84">https://yangtzeshore.github.io/2020/10/25/Dubbo-5-Dubbo的</a> spi 思想&#x2F;)</p><p>  dubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 <code>key=实现类</code> 。</p><p>  然后对于对应的组件，类似 <code>&lt;dubbo:protocol&gt;</code> 用你的那个 key 对应的实现类来实现某个接口，你可以自己去扩展 dubbo 的各种功能，提供你自己的实现。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-spi.md">1. dubbo-spi</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——4. 分布式锁</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%944.%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%944.%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——4-分布式锁"><a href="#分布式系统设计——4-分布式锁" class="headerlink" title="分布式系统设计——4. 分布式锁"></a>分布式系统设计——4. 分布式锁</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-lock-redis-vs-zookeeper.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h3><p>  官方叫做 <code>RedLock</code> 算法，是 Redis 官方支持的分布式锁算法。</p><p>  这个分布式锁有 3 个重要的考量点：</p><ul><li>互斥（只能有一个客户端获取锁）</li><li>不能死锁</li><li>容错（只要大部分 Redis 节点创建了这把锁就可以）</li></ul><h4 id="Redis-最普通的分布式锁"><a href="#Redis-最普通的分布式锁" class="headerlink" title="Redis 最普通的分布式锁"></a>Redis 最普通的分布式锁</h4><p>  第一个最普通的实现方式，就是在 Redis 里使用 <code>SET key value [EX seconds] [PX milliseconds] NX</code> 创建一个 key，这样就算加锁。其中：</p><ul><li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功，如果此时 redis 中存在这个 <code>key</code>，那么设置失败，返回 <code>nil</code>。</li><li><code>EX seconds</code>：设置 <code>key</code> 的过期时间，精确到秒级。意思是 <code>seconds</code> 秒后锁自动释放，别人创建的时候如果发现已经有了就不能加锁了。</li><li><code>PX milliseconds</code>：同样是设置 <code>key</code> 的过期时间，精确到毫秒级。</li></ul><p>  比如执行以下命令：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> resource_name <span class="hljs-comment">my_random_value PX 30000 NX</span><br></code></pre></td></tr></table></figure><p>  释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(&quot;get&quot;,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(&quot;del&quot;,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>  为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p><p>  但是这样是肯定不行的。因为如果是普通的 Redis 单实例，那就是单点故障。或者是 Redis 普通主从，那 Redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p><h4 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h4><p>  这个场景是假设有一个 Redis cluster，有 5 个 Redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code> ；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li></ol><p><a href="https://yangtzeshore.github.io/2020/10/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E5%88%86%E5%B8%83%E5%BC%8F/redis-redlock.png" alt="redis-redlock"></a></p><p>  <a href="https://redis.io/">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a> 。</p><h3 id="zk-分布式锁"><a href="#zk-分布式锁" class="headerlink" title="zk 分布式锁"></a>zk 分布式锁</h3><p>  zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能<strong>注册个监听器</strong>监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ZooKeeperSession</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZooKeeperSession</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CountDownLatch connectedSemaphore = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">private</span> ZooKeeper zookeeper;<br>    <span class="hljs-keyword">private</span> CountDownLatch latch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZooKeeperSession</span>()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.zookeeper = <span class="hljs-keyword">new</span> ZooKeeper(<span class="hljs-string">&quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;</span>, <span class="hljs-number">50000</span>, <span class="hljs-keyword">new</span> ZooKeeperWatcher());<br>            <span class="hljs-keyword">try</span> &#123;<br>                connectedSemaphore.<span class="hljs-keyword">await</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;ZooKeeper session established......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取分布式锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param productId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">acquireDistributedLock</span>(<span class="hljs-params">Long productId</span>)</span> &#123;<br>        String path = <span class="hljs-string">&quot;/product-lock-&quot;</span> + productId;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            zookeeper.create(path, <span class="hljs-string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 相当于是给node注册一个监听器，去看看这个监听器是否存在</span><br>                    Stat stat = zk.exists(path, <span class="hljs-literal">true</span>);<br><br>                    <span class="hljs-keyword">if</span> (stat != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">this</span>.latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>                        <span class="hljs-keyword">this</span>.latch.<span class="hljs-keyword">await</span>(waitTime, TimeUnit.MILLISECONDS);<br>                        <span class="hljs-keyword">this</span>.latch = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    zookeeper.create(path, <span class="hljs-string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ee) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放掉一个分布式锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param productId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseDistributedLock</span>(<span class="hljs-params">Long productId</span>)</span> &#123;<br>        String path = <span class="hljs-string">&quot;/product-lock-&quot;</span> + productId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zookeeper.delete(path, <span class="hljs-number">-1</span>);<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;release the lock for product[id=&quot;</span> + productId + <span class="hljs-string">&quot;]......&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建立 zk session 的 watcher</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZooKeeperWatcher</span> <span class="hljs-title">implements</span> <span class="hljs-title">Watcher</span> &#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span>(<span class="hljs-params">WatchedEvent <span class="hljs-keyword">event</span></span>)</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Receive watched event: &quot;</span> + <span class="hljs-keyword">event</span>.getState());<br><br>            <span class="hljs-keyword">if</span> (KeeperState.SyncConnected == <span class="hljs-keyword">event</span>.getState()) &#123;<br>                connectedSemaphore.countDown();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.latch != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.latch.countDown();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装单例的静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ZooKeeperSession instance;<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            instance = <span class="hljs-keyword">new</span> ZooKeeperSession();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZooKeeperSession <span class="hljs-title">getInstance</span>()</span> &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取单例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZooKeeperSession <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Singleton.getInstance();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化单例的便捷方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        getInstance();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以采用另一种方式，创建临时顺序节点：</p><p>  如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 ZooKeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooKeeperDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> &#123;<br><br>    <span class="hljs-keyword">private</span> ZooKeeper zk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">locksRoot</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/locks&quot;</span>;<br>    <span class="hljs-keyword">private</span> String productId;<br>    <span class="hljs-keyword">private</span> String waitNode;<br>    <span class="hljs-keyword">private</span> String lockNode;<br>    <span class="hljs-keyword">private</span> CountDownLatch latch;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">connectedLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">30000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZooKeeperDistributedLock</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.productId = productId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;</span>;<br>            zk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(address, sessionTimeout, <span class="hljs-built_in">this</span>);<br>            connectedLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (event.getState() == KeeperState.SyncConnected) &#123;<br>            connectedLatch.countDown();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.latch != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.latch.countDown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireDistributedLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.tryLock()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                waitForLock(waitNode, sessionTimeout);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// 传入进去的locksRoot + “/” + productId</span><br>    <span class="hljs-comment">// 假设productId代表了一个商品id，比如说1</span><br>    <span class="hljs-comment">// locksRoot = locks</span><br>    <span class="hljs-comment">// /locks/10000000000，/locks/10000000001，/locks/10000000002</span><br>            lockNode = zk.create(locksRoot + <span class="hljs-string">&quot;/&quot;</span> + productId, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br><br>            <span class="hljs-comment">// 看看刚创建的节点是不是最小的节点</span><br>     <span class="hljs-comment">// locks：10000000000，10000000001，10000000002</span><br>            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="hljs-literal">false</span>);<br>            Collections.sort(locks);<br><br>            <span class="hljs-keyword">if</span>(lockNode.equals(locksRoot+<span class="hljs-string">&quot;/&quot;</span>+ locks.get(<span class="hljs-number">0</span>)))&#123;<br>                <span class="hljs-comment">//如果是最小的节点,则表示取得锁</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果不是最小的节点，找到比自己小1的节点</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">previousLockIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; locks.size(); i++) &#123;<br><span class="hljs-keyword">if</span>(lockNode.equals(locksRoot + “/” + locks.get(i))) &#123;<br>             previousLockIndex = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>   &#125;<br><br>   <span class="hljs-built_in">this</span>.waitNode = locks.get(previousLockIndex);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">waitForLock</span><span class="hljs-params">(String waitNode, <span class="hljs-type">long</span> waitTime)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException &#123;<br>        <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zk.exists(locksRoot + <span class="hljs-string">&quot;/&quot;</span> + waitNode, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (stat != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.latch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);<br>            <span class="hljs-built_in">this</span>.latch = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 删除/locks/10000000000节点</span><br>            <span class="hljs-comment">// 删除/locks/10000000001节点</span><br>            System.out.println(<span class="hljs-string">&quot;unlock &quot;</span> + lockNode);<br>            zk.delete(lockNode, -<span class="hljs-number">1</span>);<br>            lockNode = <span class="hljs-literal">null</span>;<br>            zk.close();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LockException</span><span class="hljs-params">(String e)</span> &#123;<br>            <span class="hljs-built_in">super</span>(e);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LockException</span><span class="hljs-params">(Exception e)</span> &#123;<br>            <span class="hljs-built_in">super</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="redis-分布式锁和-zk-分布式锁的对比"><a href="#redis-分布式锁和-zk-分布式锁的对比" class="headerlink" title="redis 分布式锁和 zk 分布式锁的对比"></a>redis 分布式锁和 zk 分布式锁的对比</h3><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li></ul><p>  另外一点就是，如果是 Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p><p>  Redis 分布式锁大家没发现好麻烦吗？遍历上锁，计算时间等等……zk 的分布式锁语义清晰实现简单。</p><p>  所以先不分析太多的东西，就说这两点，我个人实践认为 zk 的分布式锁比 Redis 的分布式锁牢靠、而且模型简单易用。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-lock-redis-vs-zookeeper.md">1. distributed-lock-redis-vs-zookeeper</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——3. RPC 框架简单设计</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%943.%20RPC%20%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%943.%20RPC%20%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——3-RPC-框架简单设计"><a href="#分布式系统设计——3-RPC-框架简单设计" class="headerlink" title="分布式系统设计——3. RPC 框架简单设计"></a>分布式系统设计——3. RPC 框架简单设计</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-rpc-design.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  举个栗子，说个最简单的回答思路：</p><ul><li>上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信息，可以用 zookeeper 来做，对吧。</li><li>然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上。</li><li>接着你就该发起一次请求了，咋发起？当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。</li><li>然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是。</li><li>接着找到一台机器，就可以跟它发送请求了，第一个问题咋发送？你可以说用 netty 了，nio 方式；第二个问题发送啥格式数据？你可以说用 hessian 序列化协议了，或者是别的，对吧。然后请求过去了。</li><li>服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。</li></ul><p>  这就是一个最最基本的 rpc 框架的思路。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-rpc-design.md">1. dubbo-rpc-design</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——2. 接口请求顺序性</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%942.%20%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%80%A7/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%942.%20%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——2-接口请求顺序性"><a href="#分布式系统设计——2-接口请求顺序性" class="headerlink" title="分布式系统设计——2. 接口请求顺序性"></a>分布式系统设计——2. 接口请求顺序性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-request-sequence.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是<strong>有时候</strong>可能确实是需要<strong>严格的顺序</strong>保证。给大家举个例子，你服务 A 调用服务 B，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。</p><p>  本来应该是 “先插入 -&gt; 再删除”，这条数据应该没了，结果现在 “先删除 -&gt; 再插入”，数据还存在，最后你死都想不明白是怎么回事。</p><p>  所以这都是分布式系统一些很常见的问题。</p><p>  首先，一般来说，个人建议是，你们从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，因为一旦引入顺序性保障，比如使用<strong>分布式锁</strong>，会<strong>导致系统复杂度上升</strong>，而且会带来<strong>效率低下</strong>，热点数据压力过大等问题。</p><p>  下面我给个我们用过的方案吧，简单来说，首先你得用 Dubbo 的一致性 hash 负载均衡策略，将比如某一个订单 id 对应的请求都给分发到某个机器上去，接着就是在那个机器上，因为可能还是多线程并发执行的，你可能得立即将某个订单 id 对应的请求扔一个<strong>内存队列</strong>里去，强制排队，这样来确保他们的顺序性。</p><p><a href="https://yangtzeshore.github.io/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-2-%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%80%A7/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/distributed-system-request-sequence.png" alt="distributed-system-request-sequence"></a></p><p>  但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成<strong>热点</strong>怎么办？解决这些问题又要开启后续一连串的复杂技术方案…… 曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？</p><p>  最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是其它什么，避免这种问题的产生。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-request-sequence.md">1. distributed-system-request-sequence</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统设计——1. 接口幂等性</title>
    <link href="/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%941.%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2020/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%941.%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式系统设计——1-接口幂等性"><a href="#分布式系统设计——1-接口幂等性" class="headerlink" title="分布式系统设计——1. 接口幂等性"></a>分布式系统设计——1. 接口幂等性</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-idempotency.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  一个分布式系统中的某个接口，该如何保证幂等性？这个事儿其实是你做分布式系统的时候必须要考虑的一个生产环境的技术问题。啥意思呢？</p><p>  你看，假如你有个服务提供一些接口供外部调用，这个服务部署在了 5 台机器上，接着有个接口就是<strong>付款接口</strong>。然后人家用户在前端上操作的时候，不知道为啥，总之就是一个订单<strong>不小心发起了两次支付请求</strong>，然后这俩请求分散在了这个服务部署的不同的机器上，好了，结果一个订单扣款扣两次。</p><p>  或者是订单系统调用支付系统进行支付，结果不小心因为<strong>网络超时</strong>了，然后订单系统走了前面我们看到的那个重试机制，咔嚓给你重试了一把，好，支付系统收到一个支付请求两次，而且因为负载均衡算法落在了不同的机器上，尴尬了。。。</p><p>  所以你肯定得知道这事儿，否则你做出来的分布式系统恐怕容易埋坑。</p><p>  这个不是技术问题，这个没有通用的一个方法，这个应该<strong>结合业务</strong>来保证幂等性。</p><p>  所谓<strong>幂等性</strong>，就是说一个接口，多次发起同一个请求，你这个接口得保证结果是准确的，比如不能多扣款、不能多插入一条数据、不能将统计值多加了 1。这就是幂等性。</p><p>  其实保证幂等性主要是三点：</p><ul><li>对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。</li><li>每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。</li><li>每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。</li></ul><p>  实际运作过程中，你要结合自己的业务来，比如说利用 Redis，用 orderId 作为唯一键。只有成功插入这个支付流水，才可以执行实际的支付扣款。</p><p>  要求是支付一个订单，必须插入一条支付流水，order_id 建一个唯一键 <code>unique key</code> 。你在支付一个订单之前，先插入一条支付流水，order_id 就已经进去了。你就可以写一个标识到 Redis 里面去， <code>set order_id payed</code> ，下一次重复请求过来了，先查 Redis 的 order_id 对应的 value，如果是 <code>payed</code> 就说明已经支付过了，你就别重复支付了。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-system-idempotency.md">1. distributed-system-idempotenc</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——4. Dubbo负载均衡策略</title>
    <link href="/2020/10/25/Dubbo%E2%80%94%E2%80%944.%20Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/25/Dubbo%E2%80%94%E2%80%944.%20Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——4-Dubbo负载均衡策略"><a href="#Dubbo——4-Dubbo负载均衡策略" class="headerlink" title="Dubbo——4. Dubbo负载均衡策略"></a>Dubbo——4. Dubbo负载均衡策略</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-load-balancing.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="dubbo-负载均衡策略"><a href="#dubbo-负载均衡策略" class="headerlink" title="dubbo 负载均衡策略"></a>dubbo 负载均衡策略</h3><h4 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h4><p>  默认情况下，dubbo 是 RandomLoadBalance ，即<strong>随机</strong>调用实现负载均衡，可以对 provider 不同实例<strong>设置不同的权重</strong>，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。</p><p>  算法思想很简单。假设有一组服务器 servers &#x3D; <code>[A, B, C]</code>，他们对应的权重为 weights &#x3D; <code>[5, 3, 2]</code>，权重总和为 10。现在把这些权重值平铺在一维坐标值上，<code>[0, 5)</code> 区间属于服务器 A，<code>[5, 8)</code> 区间属于服务器 B，<code>[8, 10)</code> 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 <code>[0, 10)</code> 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字 3 会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为 5000 次，服务器 B 被选中的次数约为 3000 次，服务器 C 被选中的次数约为 2000 次。</p><h4 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h4><p>  这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。</p><p>举个栗子。</p><p>  跟运维同学申请机器，有的时候，我们运气好，正好公司资源比较充足，刚刚有一批热气腾腾、刚刚做好的虚拟机新鲜出炉，配置都比较高：8 核 + 16G 机器，申请到 2 台。过了一段时间，我们感觉 2 台机器有点不太够，我就去找运维同学说，“哥儿们，你能不能再给我一台机器”，但是这时只剩下一台 4 核 + 8G 的机器。我要还是得要。</p><p>  这个时候，可以给两台 8 核 16G 的机器设置权重 4，给剩余 1 台 4 核 8G 的机器设置权重 2。</p><h4 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h4><p>  官网对 <code>LeastActiveLoadBalance</code> 的解释是“<strong>最小活跃数负载均衡</strong>”，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求，那么此时请求会优先分配给该服务提供者。</p><p>  最小活跃数负载均衡算法的基本思想是这样的：</p><p>  每个服务提供者会对应着一个活跃数 <code>active</code>。初始情况下，所有服务提供者的 <code>active</code> 均为 0。每当收到一个请求，对应的服务提供者的 <code>active</code> 会加 1，处理完请求后，<code>active</code> 会减 1。所以，如果服务提供者性能较好，处理请求的效率就越高，那么 <code>active</code> 也会下降的越快。因此可以给这样的服务提供者优先分配请求。</p><p>  当然，除了最小活跃数，<code>LeastActiveLoadBalance</code> 在实现上还引入了权重值。所以准确的来说，<code>LeastActiveLoadBalance</code> 是基于加权最小活跃数算法实现的。</p><h4 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h4><p>  一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。<strong>如果你需要的不是随机负载均衡</strong>，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。</p><blockquote><p>关于 dubbo 负载均衡策略更加详细的描述，可以查看官网 <a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a> 。</p></blockquote><h3 id="dubbo-集群容错策略"><a href="#dubbo-集群容错策略" class="headerlink" title="dubbo 集群容错策略"></a>dubbo 集群容错策略</h3><h4 id="Failover-Cluster-模式"><a href="#Failover-Cluster-模式" class="headerlink" title="Failover Cluster 模式"></a>Failover Cluster 模式</h4><p>  失败自动切换，自动重试其他机器，<strong>默认</strong>就是这个，常见于读操作。（失败重试其它机器）</p><p>可以通过以下几种方式配置重试次数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;2&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>  或者</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;dubbo:<span class="hljs-keyword">reference</span> retries=<span class="hljs-string">&quot;2&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>  或者</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;dubbo:<span class="hljs-keyword">reference</span>&gt;<br>    &lt;dubbo:<span class="hljs-keyword">method</span> <span class="hljs-title function_">name</span>=&quot;<span class="hljs-title function_">findFoo</span>&quot; <span class="hljs-title function_">retries</span>=&quot;2&quot; /&gt;<br>&lt;/<span class="hljs-title function_">dubbo</span>:<span class="hljs-keyword">reference</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="Failfast-Cluster-模式"><a href="#Failfast-Cluster-模式" class="headerlink" title="Failfast Cluster 模式"></a>Failfast Cluster 模式</h4><p>  一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败）</p><h4 id="Failsafe-Cluster-模式"><a href="#Failsafe-Cluster-模式" class="headerlink" title="Failsafe Cluster 模式"></a>Failsafe Cluster 模式</h4><p>  出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。</p><p>  配置示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>  或者</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&lt;dubbo:<span class="hljs-keyword">reference</span> <span class="hljs-keyword">cluster</span>=<span class="hljs-string">&quot;failsafe&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="Failback-Cluster-模式"><a href="#Failback-Cluster-模式" class="headerlink" title="Failback Cluster 模式"></a>Failback Cluster 模式</h4><p>  失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。</p><h4 id="Forking-Cluster-模式"><a href="#Forking-Cluster-模式" class="headerlink" title="Forking Cluster 模式"></a>Forking Cluster 模式</h4><p>  <strong>并行调用</strong>多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</p><h4 id="Broadcast-Cluster-模式"><a href="#Broadcast-Cluster-模式" class="headerlink" title="Broadcast Cluster 模式"></a>Broadcast Cluster 模式</h4><p>  逐个调用所有的 provider。任何一个 provider 出错则报错（从 <code>2.1.0</code> 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><blockquote><p>关于 dubbo 集群容错策略更加详细的描述，可以查看官网 <a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html</a> 。</p></blockquote><h3 id="dubbo-动态代理策略"><a href="#dubbo-动态代理策略" class="headerlink" title="dubbo 动态代理策略"></a>dubbo 动态代理策略</h3><p>  默认使用 javassist 动态字节码生成，创建代理类。但是可以通过 spi 扩展机制配置自己的动态代理策略。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-load-balancing.md">1. dubbo-load-balancing</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单点登录的三种实现方式</title>
    <link href="/2020/10/23/Dubbo%E2%80%94%E2%80%943.%20Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/10/23/Dubbo%E2%80%94%E2%80%943.%20Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——3-Dubbo序列化协议"><a href="#Dubbo——3-Dubbo序列化协议" class="headerlink" title="Dubbo——3. Dubbo序列化协议"></a>Dubbo——3. Dubbo序列化协议</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-serialization-protocol.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  <strong>序列化</strong>，就是把数据结构或者是一些对象，转换为二进制串的过程，而<strong>反序列化</strong>是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-3-Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/serialize-deserialize.png" alt="serialize-deserialize"></a></p><h3 id="dubbo-支持不同的通信协议"><a href="#dubbo-支持不同的通信协议" class="headerlink" title="dubbo 支持不同的通信协议"></a>dubbo 支持不同的通信协议</h3><ul><li>dubbo 协议</li></ul><p>  <strong>默认</strong>就是走 dubbo 协议，单一长连接，进行的是 NIO 异步通信，基于 hessian 作为序列化协议。使用的场景是：传输数据量小（每次请求在 100kb 以内），但是并发量很高。</p><p>  为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就 100 个连接。然后后面直接基于长连接 NIO 异步通信，可以支撑高并发请求。</p><p>  长连接，通俗点说，就是建立连接过后可以持续发送请求，无须再建立连接。</p><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-3-Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-keep-connection.png" alt="dubbo-keep-connection"></a></p><p>  而短连接，每次要发送请求之前，需要先重新建立一次连接。</p><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-3-Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-not-keep-connection.png" alt="dubbo-not-keep-connection"></a></p><ul><li>rmi 协议</li></ul><p>  走 Java 二进制序列化，多个短连接，适合消费者和提供者数量差不多的情况，适用于文件的传输，一般较少用。</p><ul><li>hessian 协议</li></ul><p>  走 hessian 序列化协议，多个短连接，适用于提供者数量比消费者数量还多的情况，适用于文件的传输，一般较少用。</p><ul><li>http 协议</li></ul><p>  走表单序列化。</p><ul><li>webservice</li></ul><p>  走 SOAP 文本序列化。</p><h3 id="dubbo-支持的序列化协议"><a href="#dubbo-支持的序列化协议" class="headerlink" title="dubbo 支持的序列化协议"></a>dubbo 支持的序列化协议</h3><p>  dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。但是 hessian 是其默认的序列化协议。</p><h3 id="说一下-Hessian-的数据结构"><a href="#说一下-Hessian-的数据结构" class="headerlink" title="说一下 Hessian 的数据结构"></a>说一下 Hessian 的数据结构</h3><p>  Hessian 的对象序列化机制有 8 种原始类型：</p><ul><li>原始二进制数据</li><li>boolean</li><li>64-bit date（64 位毫秒值的日期）</li><li>64-bit double</li><li>32-bit int</li><li>64-bit long</li><li>null</li><li>UTF-8 编码的 string</li></ul><p>  另外还包括 3 种递归类型：</p><ul><li>list for lists and arrays</li><li>map for maps and dictionaries</li><li>object for objects</li></ul><p>  还有一种特殊的类型：</p><ul><li>ref：用来表示对共享对象的引用。</li></ul><h3 id="为什么-PB-的效率是最高的？"><a href="#为什么-PB-的效率是最高的？" class="headerlink" title="为什么 PB 的效率是最高的？"></a>为什么 PB 的效率是最高的？</h3><p>  其实 PB 之所以性能如此好，主要得益于两个：<strong>第一</strong>，它使用 proto 编译器，自动进行序列化和反序列化，速度非常快，应该比 <code>XML</code> 和 <code>JSON</code> 快上了 <code>20~100</code> 倍；<strong>第二</strong>，它的数据压缩效果好，就是说它序列化后的数据量体积小。因为体积小，传输起来带宽和速度上会有优化。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-serialization-protocol.md">1. dubbo-serialization-protocol</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——2. Dubbo工作原理</title>
    <link href="/2020/10/23/Dubbo%E2%80%94%E2%80%942.%20Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/23/Dubbo%E2%80%94%E2%80%942.%20Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——2-Dubbo工作原理"><a href="#Dubbo——2-Dubbo工作原理" class="headerlink" title="Dubbo——2. Dubbo工作原理"></a>Dubbo——2. Dubbo工作原理</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="dubbo-工作原理"><a href="#dubbo-工作原理" class="headerlink" title="dubbo 工作原理"></a>dubbo 工作原理</h3><ul><li>第一层：service 层，接口层，给服务提供者和消费者来实现的</li><li>第二层：config 层，配置层，主要是对 dubbo 进行各种配置的</li><li>第三层：proxy 层，服务代理层，无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信</li><li>第四层：registry 层，服务注册层，负责服务的注册与发现</li><li>第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</li><li>第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控</li><li>第七层：protocal 层，远程调用层，封装 rpc 调用</li><li>第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步</li><li>第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口</li><li>第十层：serialize 层，数据序列化层</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>第一步：provider 向注册中心去注册</li><li>第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务</li><li>第三步：consumer 调用 provider</li><li>第四步：consumer 和 provider 都异步通知监控中心</li></ul><p><a href="https://yangtzeshore.github.io/2020/10/23/Dubbo-2-Dubbo%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/Dubbo/dubbo-operating-principle.png" alt="dubbo-operating-principle"></a></p><h3 id="注册中心挂了可以继续通信吗？"><a href="#注册中心挂了可以继续通信吗？" class="headerlink" title="注册中心挂了可以继续通信吗？"></a>注册中心挂了可以继续通信吗？</h3><p>  可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息<strong>拉取到本地缓存</strong>，所以注册中心挂了可以继续通信。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md">1. dubbo-operating-principle</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——1. 引入Dubbo</title>
    <link href="/2020/10/23/Dubbo%E2%80%94%E2%80%941.%20%E5%BC%95%E5%85%A5Dubbo/"/>
    <url>/2020/10/23/Dubbo%E2%80%94%E2%80%941.%20%E5%BC%95%E5%85%A5Dubbo/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo——1-引入Dubbo"><a href="#Dubbo——1-引入Dubbo" class="headerlink" title="Dubbo——1. 引入Dubbo"></a>Dubbo——1. 引入Dubbo</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/why-dubbo.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  为什么要进行系统拆分？如何进行系统拆分？拆分后不用 dubbo 可以吗？</p><p>  其实为啥会这样呢？这就是因为整个大行业技术发展的原因。</p><p>  早些年，印象中在 2010 年初的时候，整个 IT 行业，很少有人谈分布式，更不用说微服务，虽然很多 BAT 等大型公司，因为系统的复杂性，很早就是分布式架构，大量的服务，只不过微服务大多基于自己搞的一套框架来实现而已。</p><p>  但是确实，那个年代，大家很重视 ssh2，很多中小型公司几乎大部分都是玩儿 struts2、spring、hibernate，稍晚一些，才进入了 spring mvc、spring、mybatis 的组合。那个时候整个行业的技术水平就是那样，当年 oracle 很火，oracle 管理员很吃香，oracle 性能优化啥的都是 IT 男的大杀招啊。连大数据都没人提，当年 OCP、OCM 等认证培训机构，火的不行。</p><p>  但是确实随着时代的发展，慢慢的，很多公司开始接受分布式系统架构了，这里面尤为对行业有至关重要影响的，是阿里的 dubbo，<strong>某种程度上而言，阿里在这里推动了行业技术的前进</strong>。</p><p>  正是因为有阿里的 dubbo，很多中小型公司才可以基于 dubbo，来把系统拆分成很多的服务，每个人负责一个服务，大家的代码都没有冲突，服务可以自治，自己选用什么技术都可以，每次发布如果就改动一个服务那就上线一个服务好了，不用所有人一起联调，每次发布都是几十万行代码，甚至几百万行代码了。</p><h3 id="为什么要将系统进行拆分？"><a href="#为什么要将系统进行拆分？" class="headerlink" title="为什么要将系统进行拆分？"></a>为什么要将系统进行拆分？</h3><p>  网上查查，答案极度零散和复杂，很琐碎，原因一大坨。但是我这里给大家直观的感受：</p><p>  要是<strong>不拆分</strong>，一个大系统几十万行代码，20 个人维护一份代码，简直是悲剧啊。代码经常改着改着就冲突了，各种代码冲突和合并要处理，非常耗费时间；经常我改动了我的代码，你调用了我的，导致你的代码也得重新测试，麻烦的要死；然后每次发布都是几十万行代码的系统一起发布，大家得一起提心吊胆准备上线，几十万行代码的上线，可能每次上线都要做很多的检查，很多异常问题的处理，简直是又麻烦又痛苦；而且如果我现在打算把技术升级到最新的 spring 版本，还不行，因为这可能导致你的代码报错，我不敢随意乱改技术。</p><p>  假设一个系统是 20 万行代码，其中 A 在里面改了 1000 行代码，但是此时发布的时候是这个 20 万行代码的大系统一块儿发布。就意味着 20 万上代码在线上就可能出现各种变化，20 个人，每个人都要紧张地等在电脑面前，上线之后，检查日志，看自己负责的那一块儿有没有什么问题。</p><p>  A 就检查了自己负责的 1 万行代码对应的功能，确保 ok 就闪人了；结果不巧的是，A 上线的时候不小心修改了线上机器的某个配置，导致另外 B 和 C 负责的 2 万行代码对应的一些功能，出错了。</p><p>  几十个人负责维护一个几十万行代码的单块应用，每次上线，准备几个礼拜，上线 -&gt; 部署 -&gt; 检查自己负责的功能。</p><p>  <strong>拆分了以后</strong>，整个世界清爽了，几十万行代码的系统，拆分成 20 个服务，平均每个服务就 1~2 万行代码，每个服务部署到单独的机器上。20 个工程，20 个 git 代码仓库，20 个开发人员，每个人维护自己的那个服务就可以了，是自己独立的代码，跟别人没关系。再也没有代码冲突了，爽。每次就测试我自己的代码就可以了，爽。每次就发布我自己的一个小服务就可以了，爽。技术上想怎么升级就怎么升级，保持接口不变就可以了，真爽。</p><p>  所以简单来说，一句话总结，如果是那种代码量多达几十万行的中大型项目，团队里有几十个人，那么如果不拆分系统，<strong>开发效率极其低下</strong>，问题很多。但是拆分系统之后，每个人就负责自己的一小部分就好了，可以随便玩儿随便弄。分布式系统拆分之后，可以大幅度提升复杂系统大型团队的开发效率。</p><p>  但是同时，也要<strong>提醒</strong>的一点是，系统拆分成分布式系统之后，大量的分布式系统面临的问题也是接踵而来，所以后面的问题都是在<strong>围绕分布式系统带来的复杂技术挑战</strong>在说。</p><h3 id="如何进行系统拆分？"><a href="#如何进行系统拆分？" class="headerlink" title="如何进行系统拆分？"></a>如何进行系统拆分？</h3><p>  这个问题说大可以很大，可以扯到领域驱动模型设计上去，说小了也很小。</p><p>  系统拆分为分布式系统，拆成多个服务，拆成微服务的架构，是需要拆很多轮的。并不是说上来一个架构师一次就给拆好了，而以后都不用拆。</p><p>  第一轮；团队继续扩大，拆好的某个服务，刚开始是 1 个人维护 1 万行代码，后来业务系统越来越复杂，这个服务是 10 万行代码，5 个人；第二轮，1 个服务 -&gt; 5 个服务，每个服务 2 万行代码，每人负责一个服务。</p><p>  如果是多人维护一个服务，最理想的情况下，几十个人，1 个人负责 1 个或 2~3 个服务；某个服务工作量变大了，代码量越来越多，某个同学，负责一个服务，代码量变成了 10 万行了，他自己不堪重负，他现在一个人拆开，5 个服务，1 个人顶着，负责 5 个人，接着招人，2 个人，给那个同学带着，3 个人负责 5 个服务，其中 2 个人每个人负责 2 个服务，1 个人负责 1 个服务。</p><p>  个人建议，一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>  大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等吧。</p><p>  但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。</p><p>  扯深了实在很深，所以这里先给大家举个例子，你自己感受一下，<strong>核心意思就是根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆</strong>。你根据自己负责系统的例子，来考虑一下就好了。</p><h3 id="拆分后不用-dubbo-可以吗？"><a href="#拆分后不用-dubbo-可以吗？" class="headerlink" title="拆分后不用 dubbo 可以吗？"></a>拆分后不用 dubbo 可以吗？</h3><p>  当然可以了，大不了最次，就是各个系统之间，直接基于 spring mvc，就纯 http 接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为 http 接口通信维护起来成本很高，你要考虑<strong>超时重试</strong>、<strong>负载均衡</strong>等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了 5 台机器，你怎么把请求均匀地甩给那 5 台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p><p>  所以 dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡、服务实例上下线自动感知、超时重试等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/why-dubbo.md">1. why-dubbo</a></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AddTwoNumbers</title>
    <link href="/2020/10/23/AddTwoNumbers/"/>
    <url>/2020/10/23/AddTwoNumbers/</url>
    
    <content type="html"><![CDATA[<h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br>输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTwoNumbers</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span> || carry != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l1Val</span> <span class="hljs-operator">=</span> l1 != <span class="hljs-literal">null</span> ? l1.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l2Val</span> <span class="hljs-operator">=</span> l2 != <span class="hljs-literal">null</span> ? l2.val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sumVal</span> <span class="hljs-operator">=</span> l1Val + l2Val + carry;<br>            carry = sumVal / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">sumNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sumVal % <span class="hljs-number">10</span>);<br>            cursor.next = sumNode;<br>            cursor = sumNode;<br><br>            <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> l1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        cursor.next = next;<br>        cursor = next;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">3</span>);<br>        cursor.next = next;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">5</span>);<br>        cursor = l2;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">6</span>);<br>        cursor.next = next;<br>        cursor = next;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">4</span>);<br>        cursor.next = next;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">listNode</span> <span class="hljs-operator">=</span> addTwoNumbers(l1, l2);<br>        print(listNode);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(ListNode listNode)</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            System.out.println(listNode.val);<br>            listNode = listNode.next;<br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != listNode);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode next;<br><br>        ListNode() &#123;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        ListNode(<span class="hljs-type">int</span> val, ListNode next) &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打印：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">7<br>0<br>8<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>链路是从个位到最高位，所以可以用最简单的加进位就可以解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主流扫码登录技术原理</title>
    <link href="/2020/10/22/%E4%B8%BB%E6%B5%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/22/%E4%B8%BB%E6%B5%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="主流扫码登录技术原理"><a href="#主流扫码登录技术原理" class="headerlink" title="主流扫码登录技术原理"></a>主流扫码登录技术原理</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://my.oschina.net/u/4231722/blog/3154805">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="1、基本技术原理"><a href="#1、基本技术原理" class="headerlink" title="1、基本技术原理"></a>1、基本技术原理</h3><h4 id="1-1-扫码登录功能到底是什么样的？"><a href="#1-1-扫码登录功能到底是什么样的？" class="headerlink" title="1.1 扫码登录功能到底是什么样的？"></a>1.1 扫码登录功能到底是什么样的？</h4><p>  首先介绍下什么是扫码登录。现在大部分同学手机上都装有微信、qq和淘宝这一类的软件。而这些app都有他们相对应的网页端。为了让用户在使用他们的网页时登录更加方便和安全，使用手机扫一扫就可以登录的服务，就显的自然而然了。</p><p>  有很多小伙伴可能会感到很神奇，网页上只是显示了个二维码，它怎么就知道是哪个手机扫到了二维码，并且进行登录的呢？而且，登录完成以后，还能直接把用户信息显示给用户，真的是很神奇啊。</p><h4 id="1-2-扫码登录功能的完整技术逻辑"><a href="#1-2-扫码登录功能的完整技术逻辑" class="headerlink" title="1.2 扫码登录功能的完整技术逻辑"></a>1.2 扫码登录功能的完整技术逻辑</h4><h5 id="1）网页端与服务器的配合逻辑："><a href="#1）网页端与服务器的配合逻辑：" class="headerlink" title="1）网页端与服务器的配合逻辑："></a><strong>1）网页端与服务器的配合逻辑：</strong></h5><p>  接下来就是对于这个服务的详细实现。</p><p>  首先用户打开网站的登录页面的时候，向浏览器的服务器发送获取登录二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，再过期后，用户登录二维码需要进行刷新重新获取。</p><p>  同时，将这个key值和本公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片（二维码生成，网上有很多现成的接口和源码，这里不再介绍）。然后，将二维码图片和uuid一起返回给用户浏览器。</p><p>  浏览器拿到二维码和uuid后，会每隔一秒向浏览器发送一次，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。这里有的同学就会奇怪了，服务器只存了个uuid在redis中作为key值，怎么会有用户的id信息呢？</p><p>  这里确实会有用户的id信息，这个id信息是由手机服务器存入redis中的。具体请继续阅读“手机端与服务器的配合逻辑”。</p><h5 id="2）手机端与服务器的配合逻辑："><a href="#2）手机端与服务器的配合逻辑：" class="headerlink" title="2）手机端与服务器的配合逻辑："></a>2）手机端与服务器的配合逻辑：</h5><p>  话说，浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：请掏出您的手机，打开扫一扫进行登录。</p><p>  用户拿出手机扫描二维码，就可以得到一个验证信息和一个uuid（扫描二维码获取字符串的功能在网上同样有很多demo，这里就不详细介绍了）。</p><p>  由于手机端已经进行过了登录，在访问手机端的服务器的时候，参数中都回携带一个用户的token，手机端服务器可以从中解析到用户的userId（这里从token中取值而不是手机端直接传userid是为了安全，直接传userid可能会被截获和修改，token是加密的，被修改的风险会小很多）。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登录请求（这里的服务器是手机服务器，手机端的服务器跟网页端服务器不是同一台服务器）。</p><p>  服务器收到请求后，首先对比参数中的验证信息，确定是否为用户登录请求接口。如果是，返回一个确认信息给手机端。</p><p>  手机端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。用户确认是进行的登录操作后，手机再次发送请求。服务器拿到uuId和userId后，将用户的userid作为value值存入redis中以uuid作为key的键值对中。</p><h5 id="3）登录成功时的逻辑："><a href="#3）登录成功时的逻辑：" class="headerlink" title="3）登录成功时的逻辑："></a><strong>3）登录成功时的逻辑：</strong></h5><p>  然后，浏览器再次发送请求的时候，浏览器端的服务器就可以得到一个用户Id，并调用登录的方法，声成一个浏览器端的token，再浏览器再次发送请求的时候，将用户信息返回给浏览器，登录成功。这里存储用户id而不是直接存储用户信息是因为，手机端的用户信息，不一定是和浏览器端的用户信息完全一致。</p><h5 id="4）详细的技术原理总结如下图所示："><a href="#4）详细的技术原理总结如下图所示：" class="headerlink" title="4）详细的技术原理总结如下图所示："></a><strong>4）详细的技术原理总结如下图所示：</strong><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133020067-530842155.png" alt="img"></h5><h3 id="2、淘宝的扫码登录技术实现"><a href="#2、淘宝的扫码登录技术实现" class="headerlink" title="2、淘宝的扫码登录技术实现"></a>2、淘宝的扫码登录技术实现</h3><p>  本节我们以淘宝的扫码登录为例，来实际研究分析一下淘宝的扫码登录实现逻辑。</p><p>  <strong>登录界面 <a href="https://login.taobao.com/member/login.jhtml">https://login.taobao.com/member/login.jhtml</a> 传回来的参数为：</strong></p><p><strong><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133034248-917120898.png" alt="img"></strong></p><p>  <strong>然后请求(GET)报文是这样的:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">https://qrlogin.taobao.com/qrcodelogin/qrcodeLoginCheck.<span class="hljs-keyword">do</span>?lgToken=2c3b4d53ef0513787bf4ce711ea5ba53<span class="hljs-variable">&amp;defaulturl</span>=<span class="hljs-variable">&amp;_ksTS</span>=1540106757739_2804<span class="hljs-variable">&amp;callback</span>=jsonp2805<br></code></pre></td></tr></table></figure><p>  关键的就是lgToken，是网页的唯一ID，当打开了二维码登录的时候，网页在轮询(应该是长轮询long polling)调用接口去请求服务器。</p><p>  <strong>如果没有扫码，返回的为：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133115512-1195606596.png" alt="img"></p><p>  <strong>如果扫了的话则会返回：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><br>  <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10001&quot;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mobile scan QRCode success&quot;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  长时间没有扫码的话，网页端会停止轮询，二维码失效！</p><p>  <strong>当手机端确认登录后，接口返回的是：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10006&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;success&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://login.taobao.com/member/loginByIm.do?uid=cntaobaoxxx&amp;token=ff82fc0d1d395a33d3b38ec5a4981336&amp;time=1530179143250&amp;asker=qrcodelogin&amp;ask_version=1.0.0&amp;defaulturl=https://www.taobao.com&amp;webpas=0b7aed2d43f01825183e4a49c6cae47d1479929926&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  表示登录成功，当然手机端与服务端在点击”确认登录”之间的交互可能就是这样：网页端生成的lgToken去请求服务端，服务端记住了这个lgToken并认为登录了，当网页端再次轮询请求接口时，就返回真正的登录态Token，网页端此时就可以凭着这个Token来登录了。</p><p>  <strong>详细的技术逻辑如下图所示：</strong></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133133018-1177752969.png" alt="img"></p><h3 id="3、微信的扫码登录技术实现"><a href="#3、微信的扫码登录技术实现" class="headerlink" title="3、微信的扫码登录技术实现"></a>3、微信的扫码登录技术实现</h3><h4 id="3-1-技术原理流程图"><a href="#3-1-技术原理流程图" class="headerlink" title="3.1 技术原理流程图"></a>3.1 技术原理流程图</h4><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133146058-1514561154.png" alt="img"></p><p>  微信的网页版访问地址是：<a href="https://wx.qq.com/%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%82">https://wx.qq.com/，有兴趣也可以自行深入研究。</a></p><h4 id="3-2-实际的技术实现逻辑"><a href="#3-2-实际的技术实现逻辑" class="headerlink" title="3.2 实际的技术实现逻辑"></a>3.2 实际的技术实现逻辑</h4><h5 id="1）获取唯一的uuid-以及包含uid信息的二维码："><a href="#1）获取唯一的uuid-以及包含uid信息的二维码：" class="headerlink" title="1）获取唯一的uuid, 以及包含uid信息的二维码："></a><strong>1）获取唯一的uuid, 以及包含uid信息的二维码：</strong></h5><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133203183-678380281.jpg" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取uuid</span><br><br><span class="hljs-attr">getUUID</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>  vare = t.<span class="hljs-title function_">defer</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span> = &#123;&#125;,<br><br>  $.<span class="hljs-title function_">ajax</span>(&#123;<br><br>    <span class="hljs-attr">url</span>: i.<span class="hljs-property">API_jsLogin</span>,<br><br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;script&quot;</span><br><br>  &#125;).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-number">200</span> == <span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span>.<span class="hljs-property">code</span> ? e.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span>.<span class="hljs-property">uuid</span>) : e.<span class="hljs-title function_">reject</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">QRLogin</span>.<span class="hljs-property">code</span>)<br><br>  &#125;).<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    e.<span class="hljs-title function_">reject</span>()<br><br>  &#125;),<br><br>  e.<span class="hljs-property">promise</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）浏览器轮询服务器，获取扫码状态："><a href="#2）浏览器轮询服务器，获取扫码状态：" class="headerlink" title="2）浏览器轮询服务器，获取扫码状态："></a><strong>2）浏览器轮询服务器，获取扫码状态：</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 查看扫码状态</span><br><br><span class="hljs-attr">checkLogin</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e, a</span>) &#123;<br><br>  varn = t.<span class="hljs-title function_">defer</span>()<br><br>    , a = a || <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">code</span> = <span class="hljs-number">0</span>,<br><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">checkLoginPromise</span> = $.<span class="hljs-title function_">ajax</span>(&#123;<br><br>    <span class="hljs-attr">url</span>: i.<span class="hljs-property">API_login</span> + <span class="hljs-string">&quot;?loginicon=true&amp;uuid=&quot;</span>+ e + <span class="hljs-string">&quot;&amp;tip=&quot;</span>+ a + <span class="hljs-string">&quot;&amp;r=&quot;</span>+ ~newDate,<br><br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;script&quot;</span>,<br><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">35e3</span><br><br>  &#125;).<span class="hljs-title function_">done</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;/&quot;</span>+ location.<span class="hljs-property">host</span> + <span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;/&quot;</span>+ location.<span class="hljs-property">host</span> + <span class="hljs-string">&quot;/&quot;</span>) &lt; <span class="hljs-number">0</span>)<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">void</span> (location.<span class="hljs-property">href</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span>);<br><br>    vare = &#123;<br><br>      <span class="hljs-attr">code</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">code</span>,<br><br>      <span class="hljs-attr">redirect_uri</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">redirect_uri</span>,<br><br>      <span class="hljs-attr">userAvatar</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">userAvatar</span><br><br>    &#125;;<br><br>    n.<span class="hljs-title function_">resolve</span>(e)<br><br>  &#125;).<span class="hljs-title function_">fail</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>    n.<span class="hljs-title function_">reject</span>()<br><br>  &#125;),<br><br>  n.<span class="hljs-property">promise</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）根据服务器返回的扫码状态，进行相应的操作："><a href="#3）根据服务器返回的扫码状态，进行相应的操作：" class="headerlink" title="3）根据服务器返回的扫码状态，进行相应的操作："></a><strong>3）根据服务器返回的扫码状态，进行相应的操作：</strong></h5><p><strong>408 扫码超时</strong>： 如果手机没有扫码或没有授权登录，服务器会阻塞约25s，然后返回状态码 408 -&gt; 前端继续轮询</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133232664-619837065.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133238085-2012989280.jpg" alt="img"></p><p><strong>400 二维码失效</strong>：大约5分钟的时间内不扫码，二维码失效</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133253419-957680642.jpg" alt="img"></p><p><strong>201 已扫码</strong>：如果手机已经扫码，服务器立即返回状态码和用户的基本信息 （window.code&#x3D;201,window.code.userAvator&#x3D;”…”），-&gt; 前端继续轮询</p><p><img src="https://github.com/yangtzeshore/images/blob/main/%E7%99%BB%E5%BD%95/848699-20200108133307430-591182141.jpg?raw=true" alt="img"></p><p><strong>200 已授权</strong>：如果手机点击了确认登录，服务器返回200及token -&gt; 前端停止轮询, 获取到token，重定向到目标页</p><p><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E7%99%BB%E5%BD%95/848699-20200108133317300-545669571.jpg" alt="img"></p><p><strong>具体的代码示例如下：</strong></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">// 根据服务器返回的扫码状态，进行相应的操作<br><br>functiono(c) &#123;<br><br>  <span class="hljs-attribute">switch(c.code) &#123;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case200</span>:<br><br>    t<span class="hljs-variable">.newLoginPage</span>(c<span class="hljs-variable">.redirect_uri</span>)<span class="hljs-variable">.then</span>(function(t) &#123;<br><br>      varo = t<span class="hljs-variable">.match</span>(/&lt;ret&gt;(.*)&lt;\/ret&gt;/)<br><br>        , r = t<span class="hljs-variable">.match</span>(/&lt;script&gt;(.*)&lt;\/script&gt;/)<br><br>        , c = t<span class="hljs-variable">.match</span>(/&lt;skey&gt;(.*)&lt;\/skey&gt;/)<br><br>        , s = t<span class="hljs-variable">.match</span>(/&lt;wxsid&gt;(.*)&lt;\/wxsid&gt;/)<br><br>        , l = t<span class="hljs-variable">.match</span>(/&lt;wxuin&gt;(.*)&lt;\/wxuin&gt;/)<br><br>        , d = t<span class="hljs-variable">.match</span>(/&lt;pass_ticket&gt;(.*)&lt;\/pass_ticket&gt;/)<br><br>        , f = t<span class="hljs-variable">.match</span>(/&lt;message&gt;(.*)&lt;\/message&gt;/)<br><br>        , u = t<span class="hljs-variable">.match</span>(/&lt;redirecturl&gt;(.*)&lt;\/redirecturl&gt;/);<br><br>      <span class="hljs-attribute">returnu ? void (window.location.href = u[1])</span> : o &amp;&amp; &quot;0&quot;!= o[1] ? (alert(f &amp;&amp; f[1] || &quot;登录失败&quot;),<br><br>      i<span class="hljs-variable">.report</span>(i<span class="hljs-variable">.AUTH_FAIL_COUNT</span>, 1),<br><br>      void location<span class="hljs-variable">.reload</span>()) : (e.$emit(&quot;newLoginPage&quot;, &#123;<br><br>        Ret: o &amp;&amp; o[1],<br><br>        SKey: c &amp;&amp; c[1],<br><br>        Sid: s &amp;&amp; s[1],<br><br>        Uin: l &amp;&amp; l[1],<br><br>        Passticket: d &amp;&amp; d[1],<br><br>        Code: r<br><br>      &#125;),<br><br>      void (a<span class="hljs-variable">.getCookie</span>(&quot;webwx_data_ticket&quot;) || n<span class="hljs-variable">.report</span>(n<span class="hljs-variable">.ReportType</span><span class="hljs-variable">.cookieError</span>, &#123;<br><br>        text: &quot;webwx_data_ticket 票据丢失&quot;,<br><br>        cookie: document<span class="hljs-variable">.cookie</span><br><br>      &#125;)))<br><br>    &#125;);<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case201</span>:<br><br>    e<span class="hljs-variable">.isScan</span> = !0,<br><br>    n<span class="hljs-variable">.report</span>(n<span class="hljs-variable">.ReportType</span><span class="hljs-variable">.timing</span>, &#123;<br><br>      timing: &#123;<br><br>        scan: Date<span class="hljs-variable">.now</span>()<br><br>      &#125;<br><br>    &#125;),<br><br>    t<span class="hljs-variable">.checkLogin</span>(e<span class="hljs-variable">.uuid</span>)<span class="hljs-variable">.then</span>(o, function(t) &#123;<br><br>      !t &amp;&amp; window<span class="hljs-variable">.checkLoginPromise</span> &amp;&amp; (e<span class="hljs-variable">.isBrokenNetwork</span> = !0)<br><br>    &#125;);<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case408</span>:<br><br>    t<span class="hljs-variable">.checkLogin</span>(e<span class="hljs-variable">.uuid</span>)<span class="hljs-variable">.then</span>(o, function(t) &#123;<br><br>      !t &amp;&amp; window<span class="hljs-variable">.checkLoginPromise</span> &amp;&amp; (e<span class="hljs-variable">.isBrokenNetwork</span> = !0)<br><br>    &#125;);<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case400</span>:<br><br>  case500:<br><br>  case0:<br><br>    vars = a<span class="hljs-variable">.getCookie</span>(&quot;refreshTimes&quot;) || 0;<br><br>    <span class="hljs-attribute">s &lt; 5 ? (s++,</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">    a.setCookie(&quot;refreshTimes&quot;, s, .5),</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">    document.location.reload())</span> : e<span class="hljs-variable">.isNeedRefresh</span> = !0;<br><br>    <span class="hljs-attribute">break;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  case202</span>:<br><br>    e<span class="hljs-variable">.isScan</span> = !1,<br><br>    e<span class="hljs-variable">.isAssociationLogin</span> = !1,<br><br>    a<span class="hljs-variable">.setCookie</span>(&quot;login_frequency&quot;, 0, 2),<br><br>    window<span class="hljs-variable">.checkLoginPromise</span> &amp;&amp; (window<span class="hljs-variable">.checkLoginPromise</span><span class="hljs-variable">.abort</span>(),<br><br>    window<span class="hljs-variable">.checkLoginPromise</span> = null),<br><br>    r()<br><br>  &#125;<br><br>  e<span class="hljs-variable">.code</span> = c<span class="hljs-variable">.code</span>,<br><br>  e<span class="hljs-variable">.userAvatar</span> = c<span class="hljs-variable">.userAvatar</span>,<br><br>  a<span class="hljs-variable">.log</span>(&quot;get code&quot;, c<span class="hljs-variable">.code</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>  微信网页端扫码登录时，轮询的数据返回采用的是JSONP的形式，这是为了解决跨域问题。</p><p>  微信网页端扫码登录时，轮询采用了后台根据扫码情况阻塞前台请求，优化轮询及减少前端的无效轮询。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://my.oschina.net/u/4231722/blog/3154805">1. 主流的扫码登录技术原理</a></p>]]></content>
    
    
    <categories>
      
      <category>登录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TwoSum</title>
    <link href="/2020/10/22/TwoSum/"/>
    <url>/2020/10/22/TwoSum/</url>
    
    <content type="html"><![CDATA[<h2 id="TwoSum"><a href="#TwoSum" class="headerlink" title="TwoSum"></a>TwoSum</h2><ul><li><a href="https://yangtzeshore.github.io/2020/10/19/TwoSum/#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D">题目介绍</a></li><li><a href="https://yangtzeshore.github.io/2020/10/19/TwoSum/#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95">题目解法</a></li></ul><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p><a href="https://leetcode-cn.com/problems/two-sum/">两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9<br><br>因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9<br>所以返回 <span class="hljs-comment">[0, 1]</span><br></code></pre></td></tr></table></figure><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] indexs = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">2</span>];<br>        // k 数值, v 下标<br>        Map&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt; hashMap = <span class="hljs-built_in">new</span> HashMap&lt;<span class="hljs-type">Integer</span>, <span class="hljs-type">Integer</span>&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hashMap.containsKey(nums[i])) &#123;<br>                indexs[<span class="hljs-number">0</span>] = hashMap.<span class="hljs-keyword">get</span>(nums[i]);<br>                indexs[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>            hashMap.put(target - nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> indexs;<br>    &#125;<br></code></pre></td></tr></table></figure><p>思路：</p><ul><li>利用隐藏的条件，必定有两个数满足target。</li><li>那么遍历数字，将补数作为key存入hashmap，如果后面遍历到补数自然就能返回下标。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——5. 读写分离</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%945.%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%945.%20%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——5-读写分离"><a href="#分库分表——5-读写分离" class="headerlink" title="分库分表——5. 读写分离"></a>分库分表——5. 读写分离</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="实现-MySQL-读写分离"><a href="#实现-MySQL-读写分离" class="headerlink" title="实现 MySQL 读写分离"></a>实现 MySQL 读写分离</h3><p>  其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h3 id="MySQL-主从复制原理"><a href="#MySQL-主从复制原理" class="headerlink" title="MySQL 主从复制原理"></a>MySQL 主从复制原理</h3><p>  主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-5-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/mysql-master-slave.png" alt="mysql-master-slave"></a></p><p>  这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>  而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>  所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><p>  这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p><p>  所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p><h3 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h3><p>  以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p><p>  是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000&#x2F;s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p><p>  我们通过 MySQL 命令：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">show</span> <span class="hljs-built_in">status</span><br></code></pre></td></tr></table></figure><p>  查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p><p>  一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li><li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000&#x2F;s，并行复制还是没意义。</li><li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li><li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/mysql-read-write-separation.md">1. mysql-read-write-separation</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——4. 主键生成策略</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%944.%20%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%944.%20%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——4-主键生成策略"><a href="#分库分表——4-主键生成策略" class="headerlink" title="分库分表——4. 主键生成策略"></a>分库分表——4. 主键生成策略</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="基于数据库的实现方案"><a href="#基于数据库的实现方案" class="headerlink" title="基于数据库的实现方案"></a>基于数据库的实现方案</h3><h4 id="数据库自增-id"><a href="#数据库自增-id" class="headerlink" title="数据库自增 id"></a>数据库自增 id</h4><p>  这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p><p>  这个方案的好处就是方便简单，谁都会用；<strong>缺点就是单库生成</strong>自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是<strong>无论如何都是基于单个数据库</strong>。</p><p>  <strong>适合的场景</strong>：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你<strong>并发不高，但是数据量太大</strong>导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p><h4 id="设置数据库-sequence-或者表自增字段步长"><a href="#设置数据库-sequence-或者表自增字段步长" class="headerlink" title="设置数据库 sequence 或者表自增字段步长"></a>设置数据库 sequence 或者表自增字段步长</h4><p>  可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p><p>  比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-4-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-id-sequence-step.png" alt="database-id-sequence-step"></a></p><p>  <strong>适合的场景</strong>：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>  好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><p>  适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">UUID.randomUUID<span class="hljs-function"><span class="hljs-params">()</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span>.<span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)</span> -&gt;</span> sfsdf23423rr234sfdaf<br></code></pre></td></tr></table></figure><h3 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a>获取系统当前时间</h3><p>  这个就是获取当前时间即可，但是问题是，<strong>并发很高的时候</strong>，比如一秒并发几千，<strong>会有重复的情况</strong>，这个是肯定不合适的。基本就不用考虑了。</p><p>  适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h3 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a>snowflake 算法</h3><p>  snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号。</p><ul><li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li><li>41 bits：表示的是时间戳，单位是毫秒。41 bits 可以表示的数字多达 <code>2^41 - 1</code> ，也就是可以标识 <code>2^41 - 1</code> 个毫秒值，换算成年就是表示 69 年的时间。</li><li>10 bits：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bits 里 5 个 bits 代表机房 id，5 个 bits 代表机器 id。意思就是最多代表 <code>2^5</code> 个机房（32 个机房），每个机房里可以代表 <code>2^5</code> 个机器（32 台机器）。</li><li>12 bits：这个是用来记录同一个毫秒内产生的不同 id，12 bits 可以代表的最大正整数是 <code>2^12 - 1 = 4096</code> ，也就是说可以用这个 12 bits 代表的数字来区分<strong>同一个毫秒内</strong>的 4096 个不同的 id。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> | <span class="hljs-number">0001100</span> <span class="hljs-number">10100010</span> <span class="hljs-number">10111110</span> <span class="hljs-number">10001001</span> <span class="hljs-number">01011100</span> <span class="hljs-number">00</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">1</span> <span class="hljs-number">1001</span> | <span class="hljs-number">0000</span> <span class="hljs-number">00000000</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdWorker</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> workerId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> datacenterId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> sequence;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IdWorker</span><span class="hljs-params">(<span class="hljs-type">long</span> workerId, <span class="hljs-type">long</span> datacenterId, <span class="hljs-type">long</span> sequence)</span> &#123;<br>        <span class="hljs-comment">// sanity check for workerId</span><br>        <span class="hljs-comment">// 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0</span><br>        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    String.format(<span class="hljs-string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>                    String.format(<span class="hljs-string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));<br>        &#125;<br>        System.out.printf(<br>                <span class="hljs-string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,<br>                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);<br><br>        <span class="hljs-built_in">this</span>.workerId = workerId;<br>        <span class="hljs-built_in">this</span>.datacenterId = datacenterId;<br>        <span class="hljs-built_in">this</span>.sequence = sequence;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">twepoch</span> <span class="hljs-operator">=</span> <span class="hljs-number">1288834974657L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">workerIdBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">5L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">datacenterIdBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">5L</span>;<br><br>    <span class="hljs-comment">// 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxWorkerId</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);<br><br>    <span class="hljs-comment">// 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">maxDatacenterId</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; datacenterIdBits);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequenceBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">12L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">workerIdShift</span> <span class="hljs-operator">=</span> sequenceBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">datacenterIdShift</span> <span class="hljs-operator">=</span> sequenceBits + workerIdBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">timestampLeftShift</span> <span class="hljs-operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">sequenceMask</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">lastTimestamp</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getWorkerId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> workerId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDatacenterId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> datacenterId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTimestamp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这儿就是获取当前时间戳，单位是毫秒</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> timeGen();<br><br>        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<br>                    <span class="hljs-string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;<br>            <span class="hljs-comment">// 这个意思是说一个毫秒内最多只能有4096个数字</span><br>            <span class="hljs-comment">// 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span><br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;<br>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;<br>                timestamp = tilNextMillis(lastTimestamp);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sequence = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span><br>        lastTimestamp = timestamp;<br><br>        <span class="hljs-comment">// 这儿就是将时间戳左移，放到 41 bit那儿；</span><br>        <span class="hljs-comment">// 将机房 id左移放到 5 bit那儿；</span><br>        <span class="hljs-comment">// 将机器id左移放到5 bit那儿；将序号放最后12 bit；</span><br>        <span class="hljs-comment">// 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型</span><br>        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift)<br>                | (workerId &lt;&lt; workerIdShift) | sequence;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">tilNextMillis</span><span class="hljs-params">(<span class="hljs-type">long</span> lastTimestamp)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> timeGen();<br>        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;<br>            timestamp = timeGen();<br>        &#125;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">timeGen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-comment">// ---------------测试---------------</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IdWorker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdWorker</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            System.out.println(worker.nextId());<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个<strong>机房</strong> id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的<strong>机器</strong> id（但是最大只能是 32 以内），剩下的那个 12 bit 序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p><p>  所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p><p>  利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p><p>  这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-global-id-generate.md">1. database-shard-global-id-generate</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——3. 动态扩容缩容方案</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%943.%20%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%943.%20%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——3-动态扩容缩容方案"><a href="#分库分表——3-动态扩容缩容方案" class="headerlink" title="分库分表——3. 动态扩容缩容方案"></a>分库分表——3. 动态扩容缩容方案</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="停机扩容（不推荐）"><a href="#停机扩容（不推荐）" class="headerlink" title="停机扩容（不推荐）"></a>停机扩容（不推荐）</h3><p>  这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然<strong>分库分表</strong>就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。</p><p>  从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万。那么你写个工具，多弄几台机器并行跑，1 小时数据就导完了。这没有问题。</p><p>  如果 3 个库 + 12 个表，跑了一段时间了，数据量都 1~2 亿了。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。所以不能这么搞。</p><h3 id="优化后的方案"><a href="#优化后的方案" class="headerlink" title="优化后的方案"></a>优化后的方案</h3><p>  一开始上来就是 32 个库，每个库 32 个表，那么总共是 1024 张表。</p><p>  这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题。</p><p>  每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 32 <em>1000 &#x3D; 32000 的写并发，如果每个库承载 1500 的写并发，32</em> 1500 &#x3D; 48000 的写并发，接近 5 万每秒的写入并发，前面再加一个 MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。</p><p>  有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128 个库，256 个库，512 个库。</p><p>  1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p><p>  每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p><p>  谈分库分表的扩容，<strong>第一次分库分表，就一次性给他分个够</strong>，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p><p>  一个实践是利用 <code>32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p><table><thead><tr><th>orderId</th><th>id % 32 (库)</th><th>id &#x2F; 32 % 32 (表)</th></tr></thead><tbody><tr><td>259</td><td>3</td><td>8</td></tr><tr><td>1189</td><td>5</td><td>5</td></tr><tr><td>352</td><td>0</td><td>11</td></tr><tr><td>4593</td><td>17</td><td>15</td></tr></tbody></table><p>  刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个 MySQL 服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 MySQL 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p><p>  比如说最多可以扩展到 32 个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是 1024 个表。</p><p>  这么搞，是不用自己写代码做数据迁移的，都交给 DBA 来搞好了，但是 DBA 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p><p>  哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p><p>  这里对步骤做一个总结：</p><ol><li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32 库 * 32 表，对于大部分公司来说，可能几年都够了。</li><li>路由的规则，orderId 模 32 &#x3D; 库，orderId &#x2F; 32 模 32 &#x3D; 表。</li><li>扩容的时候，申请增加更多的数据库服务器，装好 MySQL，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li><li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li><li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li><li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-dynamic-expand.md">1. database-shard-dynamic-expand</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——2. 迁移方案</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%942.%20%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%942.%20%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——2-迁移方案"><a href="#分库分表——2-迁移方案" class="headerlink" title="分库分表——2. 迁移方案"></a>分库分表——2. 迁移方案</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表<strong>动态切换</strong>到分库分表上？</p><h3 id="停机迁移方案"><a href="#停机迁移方案" class="headerlink" title="停机迁移方案"></a>停机迁移方案</h3><p>  我先给你说一个最 low 的方案，就是很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。</p><p>  接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个<strong>导数的一次性工具</strong>，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。</p><p>  导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。</p><p>  验证一下，ok 了，完美，大家伸个懒腰，看看看凌晨 4 点钟的北京夜景，打个滴滴回家吧。</p><p>  但是这个方案比较 low，谁都能干，我们来看看高大上一点的方案。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-shard-method-1.png" alt="database-shard-method-1"></a></p><h3 id="双写迁移方案"><a href="#双写迁移方案" class="headerlink" title="双写迁移方案"></a>双写迁移方案</h3><p> 1. 将新的库配置为源库的从库用来同步数据；如果需要将数据同步到多库多表，那么可以使用一些第三方工具获取 Binlog 的增量日志（比如开源工具 Canal），在获取增量日志之后就可以按照分库分表的逻辑写入到新的库表中了。</p><p> 2. 同时我们需要改造业务代码，在数据写入的时候不仅要写入旧库也要写入新库。当然，基于性能的考虑，我们可以异步地写入新库，只要保证旧库写入成功即可。但是我们需要注意的是，需要将写入新库失败的数据记录在单独的日志中，这样方便后续对这些数据补写，保证新库和旧库的数据一致性。</p><p> 3. 然后我们就可以开始校验数据了。由于数据库中数据量很大，做全量的数据校验不太现实。你可以抽取部分数据，具体数据量依据总体数据量而定，只要保证这些数据是一致的就可以。</p><p> 4. 双写时加开关，默认关闭双写，上线完成后关闭同步，同时打开开关，在低峰期的话数据丢失的概率不高。再配合数据校验的工作，是可以保证一致性的。</p><p> 5. 如果一切顺利，我们就可以将读流量切换到新库了。由于担心一次切换全量读流量可能会对系统产生未知的影响，所以这里最好采用灰度的方式来切换，比如开始切换 10% 的流量，如果没有问题再切换到 50% 的流量，最后再切换到 100%。</p><p> 6. 由于有双写的存在，所以在切换的过程中出现任何的问题都可以将读写流量随时切换到旧库去，保障系统的性能。</p><p> 7. 在观察了几天发现数据的迁移没有问题之后，就可以将数据库的双写改造成只写新库，数据的迁移也就完成了。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-shard-method-2.webp" alt="database-shard-method-2"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard-method.md">1. database-shard-method</a></p><p><a href="https://www.jianshu.com/p/ab2efddfafbd">2. 数据迁移之同步双写方案</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表——1. 基本了解</title>
    <link href="/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%941.%20%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"/>
    <url>/2020/10/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%941.%20%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表——1-基本了解"><a href="#分库分表——1-基本了解" class="headerlink" title="分库分表——1. 基本了解"></a>分库分表——1. 基本了解</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><h3 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h3><p>  说白了，分库分表是两回事儿，大家可别搞混了，可能是光分库不分表，也可能是光分表不分库，都有可能。</p><p>  假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20 万，每天活跃用户就 1 万，每天单表数据量就 1000，然后高峰期每秒钟并发请求最多就 10 个。我的天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p><p>  结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p><p>  好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是 1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢……</p><p>  再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p><p>  但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的 <code>5000~8000</code> ！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p><p>  好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>  比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大</strong>，会极大影响你的 sql <strong>执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>  分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>  分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p><p>  这就是所谓的<strong>分库分表</strong>，为啥要分库分表？你明白了吧。</p><table><thead><tr><th align="center"></th><th align="left">分库分表前</th><th align="left">分库分表后</th></tr></thead><tbody><tr><td align="center">并发支撑情况</td><td align="left">MySQL 单机部署，扛不住高并发</td><td align="left">MySQL 从单机到多机，能承受的并发增加了多倍</td></tr><tr><td align="center">磁盘使用情况</td><td align="left">MySQL 单机磁盘容量几乎撑满</td><td align="left">拆分为多个库，数据库服务器磁盘使用率大大降低</td></tr><tr><td align="center">SQL 执行性能</td><td align="left">单表数据量太大，SQL 越跑越慢</td><td align="left">单表数据量减少，SQL 执行效率明显提升</td></tr></tbody></table><h3 id="分库分表中间件"><a href="#分库分表中间件" class="headerlink" title="分库分表中间件"></a>分库分表中间件</h3><p>  这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p><p>比较常见的包括：</p><ul><li>Cobar</li><li>TDDL</li><li>Atlas</li><li>Sharding-jdbc</li><li>Mycat</li></ul><h4 id="Cobar"><a href="#Cobar" class="headerlink" title="Cobar"></a>Cobar</h4><p>  阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p><h4 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h4><p>  淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p><h4 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h4><p>  360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p><h4 id="Sharding-jdbc"><a href="#Sharding-jdbc" class="headerlink" title="Sharding-jdbc"></a>Sharding-jdbc</h4><p>  当当开源的，属于 client 层方案，是<a href="https://shardingsphere.apache.org/"> <code>ShardingSphere</code> </a>的 client 层方案，<a href="https://shardingsphere.apache.org/"> <code>ShardingSphere</code> </a>还提供 proxy 层的方案 Sharding-Proxy。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</p><h4 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h4><p>  基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。</p><p>  Sharding-jdbc 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖；</p><p>  Mycat 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</p><p>  通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。</p><h3 id="垂直拆分和水平拆分"><a href="#垂直拆分和水平拆分" class="headerlink" title="垂直拆分和水平拆分"></a>垂直拆分和水平拆分</h3><p>  <strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-split-horizon.png" alt="database-split-horizon"></a></p><p>  <strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><p><a href="https://yangtzeshore.github.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1-%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/database/database-split-vertically.png" alt="database-split-vertically"></a></p><p>  这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p><p>  还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是<strong>让每个表的数据量控制在一定范围内</strong>，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的 SQL 越复杂，就最好让单表行数越少。</p><p>  好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，<strong>中间件可以根据你指定的某个字段值</strong>，比如说 userid，<strong>自动路由到对应的库上去，然后再自动路由到对应的表里去</strong>。</p><p>  你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p><p>  而且这儿还有两种<strong>分库分表的方式</strong>：</p><ul><li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li><li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。</li></ul><p>   range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p><p>  hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/database-shard.md">1. database-shard</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高并发系统设计</title>
    <link href="/2020/10/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/10/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  这篇文章取自<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/high-concurrency-design.md">这篇博客</a>，作为整理和收录，方便后续查阅。</p><p>  其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？</p><p>  我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较 low，结果业务发展太快，有的时候系统扛不住压力就挂了。</p><p>  当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒 5000&#x2F;8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。</p><p>  所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。</p><p>  那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：</p><p>可以分为以下 6 点：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><a href="https://yangtzeshore.github.io/2020/10/21/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><img src="https://raw.githubusercontent.com/yangtzeshore/images/main/%E9%AB%98%E5%B9%B6%E5%8F%91/high-concurrency-system-design.png" alt="high-concurrency-system-design"></a></p><h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>  将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>  缓存，必须得用缓存。大部分的高并发场景，都是<strong>读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的<strong>读场景，怎么用缓存来抗高并发</strong>。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>  MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>  分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表<strong>拆分为多个表</strong>，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>  读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，<strong>主库写</strong>入，<strong>从库读</strong>取，搞一个读写分离。<strong>读流量太多</strong>的时候，还可以<strong>加更多的从库</strong>。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>  Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><p>  上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p><p>  说句实话，毕竟你真正厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是无比复杂的，一旦做过一次，并且做好了，你在这个市场上就会非常的吃香。</p><p>  其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/high-concurrency-design.md">1. high-concurrency-design</a></p>]]></content>
    
    
    <categories>
      
      <category>高并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
